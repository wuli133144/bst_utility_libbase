// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.RPC.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.RPC.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace RPC {

void protobuf_ShutdownFile_IM_2eRPC_2eproto() {
  delete TarsInfo::default_instance_;
  delete GroupIDName::default_instance_;
  delete CourseGroupInfo::default_instance_;
  delete GroupMsgId::default_instance_;
  delete GroupMsgRes::default_instance_;
  delete IMRPCGetCourseGroupInfoReq::default_instance_;
  delete IMRPCGetCourseGroupInfoRsp::default_instance_;
  delete IMRPCSendGroupMsgReq::default_instance_;
  delete IMRPCSendGroupMsgRsp::default_instance_;
  delete IMRPCDeleteGroupMsgReq::default_instance_;
  delete IMRPCDeleteGroupMsgRsp::default_instance_;
  delete IMRPCCreateLiveChatRoomReq::default_instance_;
  delete IMRPCCreateLiveChatRoomRsp::default_instance_;
  delete IMRPCCloseLiveChatRoomReq::default_instance_;
  delete IMRPCCloseLiveChatRoomRsp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eRPC_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eRPC_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  TarsInfo::default_instance_ = new TarsInfo();
  GroupIDName::default_instance_ = new GroupIDName();
  CourseGroupInfo::default_instance_ = new CourseGroupInfo();
  GroupMsgId::default_instance_ = new GroupMsgId();
  GroupMsgRes::default_instance_ = new GroupMsgRes();
  IMRPCGetCourseGroupInfoReq::default_instance_ = new IMRPCGetCourseGroupInfoReq();
  IMRPCGetCourseGroupInfoRsp::default_instance_ = new IMRPCGetCourseGroupInfoRsp();
  IMRPCSendGroupMsgReq::default_instance_ = new IMRPCSendGroupMsgReq();
  IMRPCSendGroupMsgRsp::default_instance_ = new IMRPCSendGroupMsgRsp();
  IMRPCDeleteGroupMsgReq::default_instance_ = new IMRPCDeleteGroupMsgReq();
  IMRPCDeleteGroupMsgRsp::default_instance_ = new IMRPCDeleteGroupMsgRsp();
  IMRPCCreateLiveChatRoomReq::default_instance_ = new IMRPCCreateLiveChatRoomReq();
  IMRPCCreateLiveChatRoomRsp::default_instance_ = new IMRPCCreateLiveChatRoomRsp();
  IMRPCCloseLiveChatRoomReq::default_instance_ = new IMRPCCloseLiveChatRoomReq();
  IMRPCCloseLiveChatRoomRsp::default_instance_ = new IMRPCCloseLiveChatRoomRsp();
  TarsInfo::default_instance_->InitAsDefaultInstance();
  GroupIDName::default_instance_->InitAsDefaultInstance();
  CourseGroupInfo::default_instance_->InitAsDefaultInstance();
  GroupMsgId::default_instance_->InitAsDefaultInstance();
  GroupMsgRes::default_instance_->InitAsDefaultInstance();
  IMRPCGetCourseGroupInfoReq::default_instance_->InitAsDefaultInstance();
  IMRPCGetCourseGroupInfoRsp::default_instance_->InitAsDefaultInstance();
  IMRPCSendGroupMsgReq::default_instance_->InitAsDefaultInstance();
  IMRPCSendGroupMsgRsp::default_instance_->InitAsDefaultInstance();
  IMRPCDeleteGroupMsgReq::default_instance_->InitAsDefaultInstance();
  IMRPCDeleteGroupMsgRsp::default_instance_->InitAsDefaultInstance();
  IMRPCCreateLiveChatRoomReq::default_instance_->InitAsDefaultInstance();
  IMRPCCreateLiveChatRoomRsp::default_instance_->InitAsDefaultInstance();
  IMRPCCloseLiveChatRoomReq::default_instance_->InitAsDefaultInstance();
  IMRPCCloseLiveChatRoomRsp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eRPC_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eRPC_2eproto_once_);
void protobuf_AddDesc_IM_2eRPC_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eRPC_2eproto_once_,
                 &protobuf_AddDesc_IM_2eRPC_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eRPC_2eproto {
  StaticDescriptorInitializer_IM_2eRPC_2eproto() {
    protobuf_AddDesc_IM_2eRPC_2eproto();
  }
} static_descriptor_initializer_IM_2eRPC_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int TarsInfo::kFdFieldNumber;
const int TarsInfo::kUidFieldNumber;
const int TarsInfo::kRequestIdFieldNumber;
const int TarsInfo::kPortFieldNumber;
const int TarsInfo::kIpFieldNumber;
#endif  // !_MSC_VER

TarsInfo::TarsInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.TarsInfo)
}

void TarsInfo::InitAsDefaultInstance() {
}

TarsInfo::TarsInfo(const TarsInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.TarsInfo)
}

void TarsInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  fd_ = 0u;
  uid_ = 0u;
  request_id_ = 0u;
  port_ = 0u;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TarsInfo::~TarsInfo() {
  // @@protoc_insertion_point(destructor:IM.RPC.TarsInfo)
  SharedDtor();
}

void TarsInfo::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TarsInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TarsInfo& TarsInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

TarsInfo* TarsInfo::default_instance_ = NULL;

TarsInfo* TarsInfo::New() const {
  return new TarsInfo;
}

void TarsInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TarsInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(fd_, port_);
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool TarsInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.TarsInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 fd = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fd_)));
          set_has_fd();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uid;
        break;
      }

      // required uint32 uid = 2;
      case 2: {
        if (tag == 16) {
         parse_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_request_id;
        break;
      }

      // required uint32 request_id = 3;
      case 3: {
        if (tag == 24) {
         parse_request_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &request_id_)));
          set_has_request_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_port;
        break;
      }

      // required uint32 port = 4;
      case 4: {
        if (tag == 32) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ip;
        break;
      }

      // required string ip = 5;
      case 5: {
        if (tag == 42) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.TarsInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.TarsInfo)
  return false;
#undef DO_
}

void TarsInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.TarsInfo)
  // required uint32 fd = 1;
  if (has_fd()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->fd(), output);
  }

  // required uint32 uid = 2;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->uid(), output);
  }

  // required uint32 request_id = 3;
  if (has_request_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->request_id(), output);
  }

  // required uint32 port = 4;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->port(), output);
  }

  // required string ip = 5;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->ip(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.TarsInfo)
}

int TarsInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 fd = 1;
    if (has_fd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fd());
    }

    // required uint32 uid = 2;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // required uint32 request_id = 3;
    if (has_request_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->request_id());
    }

    // required uint32 port = 4;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // required string ip = 5;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TarsInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TarsInfo*>(&from));
}

void TarsInfo::MergeFrom(const TarsInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fd()) {
      set_fd(from.fd());
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_request_id()) {
      set_request_id(from.request_id());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void TarsInfo::CopyFrom(const TarsInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TarsInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void TarsInfo::Swap(TarsInfo* other) {
  if (other != this) {
    std::swap(fd_, other->fd_);
    std::swap(uid_, other->uid_);
    std::swap(request_id_, other->request_id_);
    std::swap(port_, other->port_);
    std::swap(ip_, other->ip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TarsInfo::GetTypeName() const {
  return "IM.RPC.TarsInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupIDName::kGroupIdFieldNumber;
const int GroupIDName::kGroupNameFieldNumber;
#endif  // !_MSC_VER

GroupIDName::GroupIDName()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.GroupIDName)
}

void GroupIDName::InitAsDefaultInstance() {
}

GroupIDName::GroupIDName(const GroupIDName& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.GroupIDName)
}

void GroupIDName::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  group_id_ = 0u;
  group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupIDName::~GroupIDName() {
  // @@protoc_insertion_point(destructor:IM.RPC.GroupIDName)
  SharedDtor();
}

void GroupIDName::SharedDtor() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupIDName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupIDName& GroupIDName::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

GroupIDName* GroupIDName::default_instance_ = NULL;

GroupIDName* GroupIDName::New() const {
  return new GroupIDName;
}

void GroupIDName::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    group_id_ = 0u;
    if (has_group_name()) {
      if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        group_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupIDName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.GroupIDName)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_name;
        break;
      }

      // required string group_name = 2;
      case 2: {
        if (tag == 18) {
         parse_group_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.GroupIDName)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.GroupIDName)
  return false;
#undef DO_
}

void GroupIDName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.GroupIDName)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // required string group_name = 2;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->group_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.GroupIDName)
}

int GroupIDName::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required string group_name = 2;
    if (has_group_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_name());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupIDName::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupIDName*>(&from));
}

void GroupIDName::MergeFrom(const GroupIDName& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_group_name()) {
      set_group_name(from.group_name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupIDName::CopyFrom(const GroupIDName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupIDName::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupIDName::Swap(GroupIDName* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    std::swap(group_name_, other->group_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupIDName::GetTypeName() const {
  return "IM.RPC.GroupIDName";
}


// ===================================================================

#ifndef _MSC_VER
const int CourseGroupInfo::kGroupIdFieldNumber;
const int CourseGroupInfo::kGroupNameFieldNumber;
const int CourseGroupInfo::kCreatorNameFieldNumber;
const int CourseGroupInfo::kIdentityFieldNumber;
#endif  // !_MSC_VER

CourseGroupInfo::CourseGroupInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.CourseGroupInfo)
}

void CourseGroupInfo::InitAsDefaultInstance() {
}

CourseGroupInfo::CourseGroupInfo(const CourseGroupInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.CourseGroupInfo)
}

void CourseGroupInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  group_id_ = 0u;
  group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  creator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  identity_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CourseGroupInfo::~CourseGroupInfo() {
  // @@protoc_insertion_point(destructor:IM.RPC.CourseGroupInfo)
  SharedDtor();
}

void CourseGroupInfo::SharedDtor() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (creator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete creator_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CourseGroupInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CourseGroupInfo& CourseGroupInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

CourseGroupInfo* CourseGroupInfo::default_instance_ = NULL;

CourseGroupInfo* CourseGroupInfo::New() const {
  return new CourseGroupInfo;
}

void CourseGroupInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CourseGroupInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(group_id_, identity_);
    if (has_group_name()) {
      if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        group_name_->clear();
      }
    }
    if (has_creator_name()) {
      if (creator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        creator_name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CourseGroupInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.CourseGroupInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_name;
        break;
      }

      // required string group_name = 2;
      case 2: {
        if (tag == 18) {
         parse_group_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_creator_name;
        break;
      }

      // required string creator_name = 3;
      case 3: {
        if (tag == 26) {
         parse_creator_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_creator_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_identity;
        break;
      }

      // required uint32 identity = 4;
      case 4: {
        if (tag == 32) {
         parse_identity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &identity_)));
          set_has_identity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.CourseGroupInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.CourseGroupInfo)
  return false;
#undef DO_
}

void CourseGroupInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.CourseGroupInfo)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // required string group_name = 2;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->group_name(), output);
  }

  // required string creator_name = 3;
  if (has_creator_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->creator_name(), output);
  }

  // required uint32 identity = 4;
  if (has_identity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->identity(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.CourseGroupInfo)
}

int CourseGroupInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required string group_name = 2;
    if (has_group_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_name());
    }

    // required string creator_name = 3;
    if (has_creator_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->creator_name());
    }

    // required uint32 identity = 4;
    if (has_identity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->identity());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CourseGroupInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CourseGroupInfo*>(&from));
}

void CourseGroupInfo::MergeFrom(const CourseGroupInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_group_name()) {
      set_group_name(from.group_name());
    }
    if (from.has_creator_name()) {
      set_creator_name(from.creator_name());
    }
    if (from.has_identity()) {
      set_identity(from.identity());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CourseGroupInfo::CopyFrom(const CourseGroupInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CourseGroupInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void CourseGroupInfo::Swap(CourseGroupInfo* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    std::swap(group_name_, other->group_name_);
    std::swap(creator_name_, other->creator_name_);
    std::swap(identity_, other->identity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CourseGroupInfo::GetTypeName() const {
  return "IM.RPC.CourseGroupInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupMsgId::kGroupIdFieldNumber;
const int GroupMsgId::kMsgIdFieldNumber;
#endif  // !_MSC_VER

GroupMsgId::GroupMsgId()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.GroupMsgId)
}

void GroupMsgId::InitAsDefaultInstance() {
}

GroupMsgId::GroupMsgId(const GroupMsgId& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.GroupMsgId)
}

void GroupMsgId::SharedCtor() {
  _cached_size_ = 0;
  group_id_ = 0u;
  msg_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupMsgId::~GroupMsgId() {
  // @@protoc_insertion_point(destructor:IM.RPC.GroupMsgId)
  SharedDtor();
}

void GroupMsgId::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupMsgId::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupMsgId& GroupMsgId::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

GroupMsgId* GroupMsgId::default_instance_ = NULL;

GroupMsgId* GroupMsgId::New() const {
  return new GroupMsgId;
}

void GroupMsgId::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroupMsgId*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(group_id_, msg_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupMsgId::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.GroupMsgId)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_msg_id;
        break;
      }

      // required uint32 msg_id = 2;
      case 2: {
        if (tag == 16) {
         parse_msg_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_id_)));
          set_has_msg_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.GroupMsgId)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.GroupMsgId)
  return false;
#undef DO_
}

void GroupMsgId::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.GroupMsgId)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // required uint32 msg_id = 2;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->msg_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.GroupMsgId)
}

int GroupMsgId::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required uint32 msg_id = 2;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupMsgId::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupMsgId*>(&from));
}

void GroupMsgId::MergeFrom(const GroupMsgId& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupMsgId::CopyFrom(const GroupMsgId& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupMsgId::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupMsgId::Swap(GroupMsgId* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    std::swap(msg_id_, other->msg_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupMsgId::GetTypeName() const {
  return "IM.RPC.GroupMsgId";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupMsgRes::kGroupIdFieldNumber;
const int GroupMsgRes::kMsgIdFieldNumber;
const int GroupMsgRes::kResultFieldNumber;
#endif  // !_MSC_VER

GroupMsgRes::GroupMsgRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.GroupMsgRes)
}

void GroupMsgRes::InitAsDefaultInstance() {
}

GroupMsgRes::GroupMsgRes(const GroupMsgRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.GroupMsgRes)
}

void GroupMsgRes::SharedCtor() {
  _cached_size_ = 0;
  group_id_ = 0u;
  msg_id_ = 0u;
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupMsgRes::~GroupMsgRes() {
  // @@protoc_insertion_point(destructor:IM.RPC.GroupMsgRes)
  SharedDtor();
}

void GroupMsgRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupMsgRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupMsgRes& GroupMsgRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

GroupMsgRes* GroupMsgRes::default_instance_ = NULL;

GroupMsgRes* GroupMsgRes::New() const {
  return new GroupMsgRes;
}

void GroupMsgRes::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroupMsgRes*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(group_id_, result_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupMsgRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.GroupMsgRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_msg_id;
        break;
      }

      // required uint32 msg_id = 2;
      case 2: {
        if (tag == 16) {
         parse_msg_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_id_)));
          set_has_msg_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_result;
        break;
      }

      // required uint32 result = 3;
      case 3: {
        if (tag == 24) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.GroupMsgRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.GroupMsgRes)
  return false;
#undef DO_
}

void GroupMsgRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.GroupMsgRes)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // required uint32 msg_id = 2;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->msg_id(), output);
  }

  // required uint32 result = 3;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.GroupMsgRes)
}

int GroupMsgRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required uint32 msg_id = 2;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_id());
    }

    // required uint32 result = 3;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupMsgRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupMsgRes*>(&from));
}

void GroupMsgRes::MergeFrom(const GroupMsgRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupMsgRes::CopyFrom(const GroupMsgRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupMsgRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GroupMsgRes::Swap(GroupMsgRes* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    std::swap(msg_id_, other->msg_id_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupMsgRes::GetTypeName() const {
  return "IM.RPC.GroupMsgRes";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCGetCourseGroupInfoReq::kUserImIdFieldNumber;
const int IMRPCGetCourseGroupInfoReq::kTarsInfoFieldNumber;
const int IMRPCGetCourseGroupInfoReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCGetCourseGroupInfoReq::IMRPCGetCourseGroupInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCGetCourseGroupInfoReq)
}

void IMRPCGetCourseGroupInfoReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCGetCourseGroupInfoReq::IMRPCGetCourseGroupInfoReq(const IMRPCGetCourseGroupInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCGetCourseGroupInfoReq)
}

void IMRPCGetCourseGroupInfoReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  tars_info_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCGetCourseGroupInfoReq::~IMRPCGetCourseGroupInfoReq() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCGetCourseGroupInfoReq)
  SharedDtor();
}

void IMRPCGetCourseGroupInfoReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCGetCourseGroupInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCGetCourseGroupInfoReq& IMRPCGetCourseGroupInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCGetCourseGroupInfoReq* IMRPCGetCourseGroupInfoReq::default_instance_ = NULL;

IMRPCGetCourseGroupInfoReq* IMRPCGetCourseGroupInfoReq::New() const {
  return new IMRPCGetCourseGroupInfoReq;
}

void IMRPCGetCourseGroupInfoReq::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    user_im_id_ = 0u;
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCGetCourseGroupInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCGetCourseGroupInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 2;
      case 2: {
        if (tag == 18) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCGetCourseGroupInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCGetCourseGroupInfoReq)
  return false;
#undef DO_
}

void IMRPCGetCourseGroupInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCGetCourseGroupInfoReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 2;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->tars_info(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCGetCourseGroupInfoReq)
}

int IMRPCGetCourseGroupInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required .IM.RPC.TarsInfo tars_info = 2;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCGetCourseGroupInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCGetCourseGroupInfoReq*>(&from));
}

void IMRPCGetCourseGroupInfoReq::MergeFrom(const IMRPCGetCourseGroupInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCGetCourseGroupInfoReq::CopyFrom(const IMRPCGetCourseGroupInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCGetCourseGroupInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCGetCourseGroupInfoReq::Swap(IMRPCGetCourseGroupInfoReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCGetCourseGroupInfoReq::GetTypeName() const {
  return "IM.RPC.IMRPCGetCourseGroupInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCGetCourseGroupInfoRsp::kUserImIdFieldNumber;
const int IMRPCGetCourseGroupInfoRsp::kGroupInfoListFieldNumber;
const int IMRPCGetCourseGroupInfoRsp::kTarsInfoFieldNumber;
const int IMRPCGetCourseGroupInfoRsp::kResultFieldNumber;
const int IMRPCGetCourseGroupInfoRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCGetCourseGroupInfoRsp::IMRPCGetCourseGroupInfoRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCGetCourseGroupInfoRsp)
}

void IMRPCGetCourseGroupInfoRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCGetCourseGroupInfoRsp::IMRPCGetCourseGroupInfoRsp(const IMRPCGetCourseGroupInfoRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCGetCourseGroupInfoRsp)
}

void IMRPCGetCourseGroupInfoRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  tars_info_ = NULL;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCGetCourseGroupInfoRsp::~IMRPCGetCourseGroupInfoRsp() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCGetCourseGroupInfoRsp)
  SharedDtor();
}

void IMRPCGetCourseGroupInfoRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCGetCourseGroupInfoRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCGetCourseGroupInfoRsp& IMRPCGetCourseGroupInfoRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCGetCourseGroupInfoRsp* IMRPCGetCourseGroupInfoRsp::default_instance_ = NULL;

IMRPCGetCourseGroupInfoRsp* IMRPCGetCourseGroupInfoRsp::New() const {
  return new IMRPCGetCourseGroupInfoRsp;
}

void IMRPCGetCourseGroupInfoRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRPCGetCourseGroupInfoRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 29) {
    ZR_(user_im_id_, result_);
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  group_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCGetCourseGroupInfoRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCGetCourseGroupInfoRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_info_list;
        break;
      }

      // repeated .IM.RPC.CourseGroupInfo group_info_list = 2;
      case 2: {
        if (tag == 18) {
         parse_group_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_group_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_info_list;
        if (input->ExpectTag(26)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 3;
      case 3: {
        if (tag == 26) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_result;
        break;
      }

      // required uint32 result = 4;
      case 4: {
        if (tag == 32) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCGetCourseGroupInfoRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCGetCourseGroupInfoRsp)
  return false;
#undef DO_
}

void IMRPCGetCourseGroupInfoRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCGetCourseGroupInfoRsp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // repeated .IM.RPC.CourseGroupInfo group_info_list = 2;
  for (int i = 0; i < this->group_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->group_info_list(i), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 3;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->tars_info(), output);
  }

  // required uint32 result = 4;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->result(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCGetCourseGroupInfoRsp)
}

int IMRPCGetCourseGroupInfoRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required .IM.RPC.TarsInfo tars_info = 3;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // required uint32 result = 4;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.RPC.CourseGroupInfo group_info_list = 2;
  total_size += 1 * this->group_info_list_size();
  for (int i = 0; i < this->group_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->group_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCGetCourseGroupInfoRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCGetCourseGroupInfoRsp*>(&from));
}

void IMRPCGetCourseGroupInfoRsp::MergeFrom(const IMRPCGetCourseGroupInfoRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_info_list_.MergeFrom(from.group_info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCGetCourseGroupInfoRsp::CopyFrom(const IMRPCGetCourseGroupInfoRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCGetCourseGroupInfoRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->group_info_list())) return false;
  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCGetCourseGroupInfoRsp::Swap(IMRPCGetCourseGroupInfoRsp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    group_info_list_.Swap(&other->group_info_list_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(result_, other->result_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCGetCourseGroupInfoRsp::GetTypeName() const {
  return "IM.RPC.IMRPCGetCourseGroupInfoRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCSendGroupMsgReq::kUserImIdFieldNumber;
const int IMRPCSendGroupMsgReq::kUserIdFieldNumber;
const int IMRPCSendGroupMsgReq::kUserNameFieldNumber;
const int IMRPCSendGroupMsgReq::kUserPortraitFieldNumber;
const int IMRPCSendGroupMsgReq::kMsgTypeFieldNumber;
const int IMRPCSendGroupMsgReq::kMsgDataFieldNumber;
const int IMRPCSendGroupMsgReq::kGroupIdListFieldNumber;
const int IMRPCSendGroupMsgReq::kTarsInfoFieldNumber;
const int IMRPCSendGroupMsgReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCSendGroupMsgReq::IMRPCSendGroupMsgReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCSendGroupMsgReq)
}

void IMRPCSendGroupMsgReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCSendGroupMsgReq::IMRPCSendGroupMsgReq(const IMRPCSendGroupMsgReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCSendGroupMsgReq)
}

void IMRPCSendGroupMsgReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  user_id_ = 0u;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_type_ = 0u;
  msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tars_info_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCSendGroupMsgReq::~IMRPCSendGroupMsgReq() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCSendGroupMsgReq)
  SharedDtor();
}

void IMRPCSendGroupMsgReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_portrait_;
  }
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCSendGroupMsgReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCSendGroupMsgReq& IMRPCSendGroupMsgReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCSendGroupMsgReq* IMRPCSendGroupMsgReq::default_instance_ = NULL;

IMRPCSendGroupMsgReq* IMRPCSendGroupMsgReq::New() const {
  return new IMRPCSendGroupMsgReq;
}

void IMRPCSendGroupMsgReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRPCSendGroupMsgReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 191) {
    ZR_(user_im_id_, user_id_);
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_name_->clear();
      }
    }
    if (has_user_portrait()) {
      if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_portrait_->clear();
      }
    }
    msg_type_ = 0u;
    if (has_msg_data()) {
      if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_data_->clear();
      }
    }
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
  }
  if (has_attach_data()) {
    if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      attach_data_->clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  group_id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCSendGroupMsgReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCSendGroupMsgReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_user_name;
        break;
      }

      // required string user_name = 3;
      case 3: {
        if (tag == 26) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_user_portrait;
        break;
      }

      // required string user_portrait = 4;
      case 4: {
        if (tag == 34) {
         parse_user_portrait:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_portrait()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_msg_type;
        break;
      }

      // required uint32 msg_type = 5;
      case 5: {
        if (tag == 40) {
         parse_msg_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_type_)));
          set_has_msg_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_msg_data;
        break;
      }

      // required bytes msg_data = 6;
      case 6: {
        if (tag == 50) {
         parse_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_group_id_list;
        break;
      }

      // repeated uint32 group_id_list = 7;
      case 7: {
        if (tag == 56) {
         parse_group_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 56, input, this->mutable_group_id_list())));
        } else if (tag == 58) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_group_id_list())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_group_id_list;
        if (input->ExpectTag(66)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 8;
      case 8: {
        if (tag == 66) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCSendGroupMsgReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCSendGroupMsgReq)
  return false;
#undef DO_
}

void IMRPCSendGroupMsgReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCSendGroupMsgReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required string user_name = 3;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->user_name(), output);
  }

  // required string user_portrait = 4;
  if (has_user_portrait()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->user_portrait(), output);
  }

  // required uint32 msg_type = 5;
  if (has_msg_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->msg_type(), output);
  }

  // required bytes msg_data = 6;
  if (has_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->msg_data(), output);
  }

  // repeated uint32 group_id_list = 7;
  for (int i = 0; i < this->group_id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      7, this->group_id_list(i), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 8;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->tars_info(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCSendGroupMsgReq)
}

int IMRPCSendGroupMsgReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required string user_name = 3;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required string user_portrait = 4;
    if (has_user_portrait()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_portrait());
    }

    // required uint32 msg_type = 5;
    if (has_msg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_type());
    }

    // required bytes msg_data = 6;
    if (has_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg_data());
    }

    // required .IM.RPC.TarsInfo tars_info = 8;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 group_id_list = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->group_id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->group_id_list(i));
    }
    total_size += 1 * this->group_id_list_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCSendGroupMsgReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCSendGroupMsgReq*>(&from));
}

void IMRPCSendGroupMsgReq::MergeFrom(const IMRPCSendGroupMsgReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_id_list_.MergeFrom(from.group_id_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_user_portrait()) {
      set_user_portrait(from.user_portrait());
    }
    if (from.has_msg_type()) {
      set_msg_type(from.msg_type());
    }
    if (from.has_msg_data()) {
      set_msg_data(from.msg_data());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCSendGroupMsgReq::CopyFrom(const IMRPCSendGroupMsgReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCSendGroupMsgReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000bf) != 0x000000bf) return false;

  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCSendGroupMsgReq::Swap(IMRPCSendGroupMsgReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(user_name_, other->user_name_);
    std::swap(user_portrait_, other->user_portrait_);
    std::swap(msg_type_, other->msg_type_);
    std::swap(msg_data_, other->msg_data_);
    group_id_list_.Swap(&other->group_id_list_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCSendGroupMsgReq::GetTypeName() const {
  return "IM.RPC.IMRPCSendGroupMsgReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCSendGroupMsgRsp::kUserImIdFieldNumber;
const int IMRPCSendGroupMsgRsp::kGroupMsgResListFieldNumber;
const int IMRPCSendGroupMsgRsp::kTarsInfoFieldNumber;
const int IMRPCSendGroupMsgRsp::kResultFieldNumber;
const int IMRPCSendGroupMsgRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCSendGroupMsgRsp::IMRPCSendGroupMsgRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCSendGroupMsgRsp)
}

void IMRPCSendGroupMsgRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCSendGroupMsgRsp::IMRPCSendGroupMsgRsp(const IMRPCSendGroupMsgRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCSendGroupMsgRsp)
}

void IMRPCSendGroupMsgRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  tars_info_ = NULL;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCSendGroupMsgRsp::~IMRPCSendGroupMsgRsp() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCSendGroupMsgRsp)
  SharedDtor();
}

void IMRPCSendGroupMsgRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCSendGroupMsgRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCSendGroupMsgRsp& IMRPCSendGroupMsgRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCSendGroupMsgRsp* IMRPCSendGroupMsgRsp::default_instance_ = NULL;

IMRPCSendGroupMsgRsp* IMRPCSendGroupMsgRsp::New() const {
  return new IMRPCSendGroupMsgRsp;
}

void IMRPCSendGroupMsgRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRPCSendGroupMsgRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 29) {
    ZR_(user_im_id_, result_);
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  group_msg_res_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCSendGroupMsgRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCSendGroupMsgRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_msg_res_list;
        break;
      }

      // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
      case 2: {
        if (tag == 18) {
         parse_group_msg_res_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_group_msg_res_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_msg_res_list;
        if (input->ExpectTag(26)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 3;
      case 3: {
        if (tag == 26) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_result;
        break;
      }

      // required uint32 result = 4;
      case 4: {
        if (tag == 32) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCSendGroupMsgRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCSendGroupMsgRsp)
  return false;
#undef DO_
}

void IMRPCSendGroupMsgRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCSendGroupMsgRsp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
  for (int i = 0; i < this->group_msg_res_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->group_msg_res_list(i), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 3;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->tars_info(), output);
  }

  // required uint32 result = 4;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->result(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCSendGroupMsgRsp)
}

int IMRPCSendGroupMsgRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required .IM.RPC.TarsInfo tars_info = 3;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // required uint32 result = 4;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
  total_size += 1 * this->group_msg_res_list_size();
  for (int i = 0; i < this->group_msg_res_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->group_msg_res_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCSendGroupMsgRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCSendGroupMsgRsp*>(&from));
}

void IMRPCSendGroupMsgRsp::MergeFrom(const IMRPCSendGroupMsgRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_msg_res_list_.MergeFrom(from.group_msg_res_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCSendGroupMsgRsp::CopyFrom(const IMRPCSendGroupMsgRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCSendGroupMsgRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->group_msg_res_list())) return false;
  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCSendGroupMsgRsp::Swap(IMRPCSendGroupMsgRsp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    group_msg_res_list_.Swap(&other->group_msg_res_list_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(result_, other->result_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCSendGroupMsgRsp::GetTypeName() const {
  return "IM.RPC.IMRPCSendGroupMsgRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCDeleteGroupMsgReq::kUserImIdFieldNumber;
const int IMRPCDeleteGroupMsgReq::kGroupMsgIdListFieldNumber;
const int IMRPCDeleteGroupMsgReq::kTarsInfoFieldNumber;
const int IMRPCDeleteGroupMsgReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCDeleteGroupMsgReq::IMRPCDeleteGroupMsgReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCDeleteGroupMsgReq)
}

void IMRPCDeleteGroupMsgReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCDeleteGroupMsgReq::IMRPCDeleteGroupMsgReq(const IMRPCDeleteGroupMsgReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCDeleteGroupMsgReq)
}

void IMRPCDeleteGroupMsgReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  tars_info_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCDeleteGroupMsgReq::~IMRPCDeleteGroupMsgReq() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCDeleteGroupMsgReq)
  SharedDtor();
}

void IMRPCDeleteGroupMsgReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCDeleteGroupMsgReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCDeleteGroupMsgReq& IMRPCDeleteGroupMsgReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCDeleteGroupMsgReq* IMRPCDeleteGroupMsgReq::default_instance_ = NULL;

IMRPCDeleteGroupMsgReq* IMRPCDeleteGroupMsgReq::New() const {
  return new IMRPCDeleteGroupMsgReq;
}

void IMRPCDeleteGroupMsgReq::Clear() {
  if (_has_bits_[0 / 32] & 13) {
    user_im_id_ = 0u;
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  group_msg_id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCDeleteGroupMsgReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCDeleteGroupMsgReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_msg_id_list;
        break;
      }

      // repeated .IM.RPC.GroupMsgId group_msg_id_list = 2;
      case 2: {
        if (tag == 18) {
         parse_group_msg_id_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_group_msg_id_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_msg_id_list;
        if (input->ExpectTag(26)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 3;
      case 3: {
        if (tag == 26) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCDeleteGroupMsgReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCDeleteGroupMsgReq)
  return false;
#undef DO_
}

void IMRPCDeleteGroupMsgReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCDeleteGroupMsgReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // repeated .IM.RPC.GroupMsgId group_msg_id_list = 2;
  for (int i = 0; i < this->group_msg_id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->group_msg_id_list(i), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 3;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->tars_info(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCDeleteGroupMsgReq)
}

int IMRPCDeleteGroupMsgReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required .IM.RPC.TarsInfo tars_info = 3;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.RPC.GroupMsgId group_msg_id_list = 2;
  total_size += 1 * this->group_msg_id_list_size();
  for (int i = 0; i < this->group_msg_id_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->group_msg_id_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCDeleteGroupMsgReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCDeleteGroupMsgReq*>(&from));
}

void IMRPCDeleteGroupMsgReq::MergeFrom(const IMRPCDeleteGroupMsgReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_msg_id_list_.MergeFrom(from.group_msg_id_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCDeleteGroupMsgReq::CopyFrom(const IMRPCDeleteGroupMsgReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCDeleteGroupMsgReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->group_msg_id_list())) return false;
  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCDeleteGroupMsgReq::Swap(IMRPCDeleteGroupMsgReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    group_msg_id_list_.Swap(&other->group_msg_id_list_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCDeleteGroupMsgReq::GetTypeName() const {
  return "IM.RPC.IMRPCDeleteGroupMsgReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCDeleteGroupMsgRsp::kUserImIdFieldNumber;
const int IMRPCDeleteGroupMsgRsp::kGroupMsgResListFieldNumber;
const int IMRPCDeleteGroupMsgRsp::kTarsInfoFieldNumber;
const int IMRPCDeleteGroupMsgRsp::kResultFieldNumber;
const int IMRPCDeleteGroupMsgRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCDeleteGroupMsgRsp::IMRPCDeleteGroupMsgRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCDeleteGroupMsgRsp)
}

void IMRPCDeleteGroupMsgRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCDeleteGroupMsgRsp::IMRPCDeleteGroupMsgRsp(const IMRPCDeleteGroupMsgRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCDeleteGroupMsgRsp)
}

void IMRPCDeleteGroupMsgRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  tars_info_ = NULL;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCDeleteGroupMsgRsp::~IMRPCDeleteGroupMsgRsp() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCDeleteGroupMsgRsp)
  SharedDtor();
}

void IMRPCDeleteGroupMsgRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCDeleteGroupMsgRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCDeleteGroupMsgRsp& IMRPCDeleteGroupMsgRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCDeleteGroupMsgRsp* IMRPCDeleteGroupMsgRsp::default_instance_ = NULL;

IMRPCDeleteGroupMsgRsp* IMRPCDeleteGroupMsgRsp::New() const {
  return new IMRPCDeleteGroupMsgRsp;
}

void IMRPCDeleteGroupMsgRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRPCDeleteGroupMsgRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 29) {
    ZR_(user_im_id_, result_);
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  group_msg_res_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCDeleteGroupMsgRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCDeleteGroupMsgRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_msg_res_list;
        break;
      }

      // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
      case 2: {
        if (tag == 18) {
         parse_group_msg_res_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_group_msg_res_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_group_msg_res_list;
        if (input->ExpectTag(26)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 3;
      case 3: {
        if (tag == 26) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_result;
        break;
      }

      // required uint32 result = 4;
      case 4: {
        if (tag == 32) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCDeleteGroupMsgRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCDeleteGroupMsgRsp)
  return false;
#undef DO_
}

void IMRPCDeleteGroupMsgRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCDeleteGroupMsgRsp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
  for (int i = 0; i < this->group_msg_res_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->group_msg_res_list(i), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 3;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->tars_info(), output);
  }

  // required uint32 result = 4;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->result(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCDeleteGroupMsgRsp)
}

int IMRPCDeleteGroupMsgRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required .IM.RPC.TarsInfo tars_info = 3;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // required uint32 result = 4;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 2;
  total_size += 1 * this->group_msg_res_list_size();
  for (int i = 0; i < this->group_msg_res_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->group_msg_res_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCDeleteGroupMsgRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCDeleteGroupMsgRsp*>(&from));
}

void IMRPCDeleteGroupMsgRsp::MergeFrom(const IMRPCDeleteGroupMsgRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_msg_res_list_.MergeFrom(from.group_msg_res_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCDeleteGroupMsgRsp::CopyFrom(const IMRPCDeleteGroupMsgRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCDeleteGroupMsgRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->group_msg_res_list())) return false;
  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCDeleteGroupMsgRsp::Swap(IMRPCDeleteGroupMsgRsp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    group_msg_res_list_.Swap(&other->group_msg_res_list_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(result_, other->result_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCDeleteGroupMsgRsp::GetTypeName() const {
  return "IM.RPC.IMRPCDeleteGroupMsgRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCCreateLiveChatRoomReq::kUserImIdFieldNumber;
const int IMRPCCreateLiveChatRoomReq::kLiveIdFieldNumber;
const int IMRPCCreateLiveChatRoomReq::kLiveCapacityFieldNumber;
const int IMRPCCreateLiveChatRoomReq::kTarsInfoFieldNumber;
const int IMRPCCreateLiveChatRoomReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCCreateLiveChatRoomReq::IMRPCCreateLiveChatRoomReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCCreateLiveChatRoomReq)
}

void IMRPCCreateLiveChatRoomReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCCreateLiveChatRoomReq::IMRPCCreateLiveChatRoomReq(const IMRPCCreateLiveChatRoomReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCCreateLiveChatRoomReq)
}

void IMRPCCreateLiveChatRoomReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  live_capacity_ = 0u;
  tars_info_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCCreateLiveChatRoomReq::~IMRPCCreateLiveChatRoomReq() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCCreateLiveChatRoomReq)
  SharedDtor();
}

void IMRPCCreateLiveChatRoomReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCCreateLiveChatRoomReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCCreateLiveChatRoomReq& IMRPCCreateLiveChatRoomReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCCreateLiveChatRoomReq* IMRPCCreateLiveChatRoomReq::default_instance_ = NULL;

IMRPCCreateLiveChatRoomReq* IMRPCCreateLiveChatRoomReq::New() const {
  return new IMRPCCreateLiveChatRoomReq;
}

void IMRPCCreateLiveChatRoomReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRPCCreateLiveChatRoomReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(user_im_id_, live_id_);
    live_capacity_ = 0u;
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCCreateLiveChatRoomReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCCreateLiveChatRoomReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_live_capacity;
        break;
      }

      // required uint32 live_capacity = 3;
      case 3: {
        if (tag == 24) {
         parse_live_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_capacity_)));
          set_has_live_capacity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 6;
      case 6: {
        if (tag == 50) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCCreateLiveChatRoomReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCCreateLiveChatRoomReq)
  return false;
#undef DO_
}

void IMRPCCreateLiveChatRoomReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCCreateLiveChatRoomReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required uint32 live_capacity = 3;
  if (has_live_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->live_capacity(), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 6;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->tars_info(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCCreateLiveChatRoomReq)
}

int IMRPCCreateLiveChatRoomReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required uint32 live_capacity = 3;
    if (has_live_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_capacity());
    }

    // required .IM.RPC.TarsInfo tars_info = 6;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCCreateLiveChatRoomReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCCreateLiveChatRoomReq*>(&from));
}

void IMRPCCreateLiveChatRoomReq::MergeFrom(const IMRPCCreateLiveChatRoomReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_live_capacity()) {
      set_live_capacity(from.live_capacity());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCCreateLiveChatRoomReq::CopyFrom(const IMRPCCreateLiveChatRoomReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCCreateLiveChatRoomReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCCreateLiveChatRoomReq::Swap(IMRPCCreateLiveChatRoomReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(live_capacity_, other->live_capacity_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCCreateLiveChatRoomReq::GetTypeName() const {
  return "IM.RPC.IMRPCCreateLiveChatRoomReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCCreateLiveChatRoomRsp::kUserImIdFieldNumber;
const int IMRPCCreateLiveChatRoomRsp::kLiveIdFieldNumber;
const int IMRPCCreateLiveChatRoomRsp::kResultFieldNumber;
const int IMRPCCreateLiveChatRoomRsp::kTarsInfoFieldNumber;
const int IMRPCCreateLiveChatRoomRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCCreateLiveChatRoomRsp::IMRPCCreateLiveChatRoomRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCCreateLiveChatRoomRsp)
}

void IMRPCCreateLiveChatRoomRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCCreateLiveChatRoomRsp::IMRPCCreateLiveChatRoomRsp(const IMRPCCreateLiveChatRoomRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCCreateLiveChatRoomRsp)
}

void IMRPCCreateLiveChatRoomRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  result_ = 0u;
  tars_info_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCCreateLiveChatRoomRsp::~IMRPCCreateLiveChatRoomRsp() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCCreateLiveChatRoomRsp)
  SharedDtor();
}

void IMRPCCreateLiveChatRoomRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCCreateLiveChatRoomRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCCreateLiveChatRoomRsp& IMRPCCreateLiveChatRoomRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCCreateLiveChatRoomRsp* IMRPCCreateLiveChatRoomRsp::default_instance_ = NULL;

IMRPCCreateLiveChatRoomRsp* IMRPCCreateLiveChatRoomRsp::New() const {
  return new IMRPCCreateLiveChatRoomRsp;
}

void IMRPCCreateLiveChatRoomRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRPCCreateLiveChatRoomRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(user_im_id_, live_id_);
    result_ = 0u;
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCCreateLiveChatRoomRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCCreateLiveChatRoomRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_result;
        break;
      }

      // required uint32 result = 5;
      case 5: {
        if (tag == 40) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 6;
      case 6: {
        if (tag == 50) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCCreateLiveChatRoomRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCCreateLiveChatRoomRsp)
  return false;
#undef DO_
}

void IMRPCCreateLiveChatRoomRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCCreateLiveChatRoomRsp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required uint32 result = 5;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->result(), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 6;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->tars_info(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCCreateLiveChatRoomRsp)
}

int IMRPCCreateLiveChatRoomRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required uint32 result = 5;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // required .IM.RPC.TarsInfo tars_info = 6;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCCreateLiveChatRoomRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCCreateLiveChatRoomRsp*>(&from));
}

void IMRPCCreateLiveChatRoomRsp::MergeFrom(const IMRPCCreateLiveChatRoomRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCCreateLiveChatRoomRsp::CopyFrom(const IMRPCCreateLiveChatRoomRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCCreateLiveChatRoomRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCCreateLiveChatRoomRsp::Swap(IMRPCCreateLiveChatRoomRsp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(result_, other->result_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCCreateLiveChatRoomRsp::GetTypeName() const {
  return "IM.RPC.IMRPCCreateLiveChatRoomRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCCloseLiveChatRoomReq::kUserImIdFieldNumber;
const int IMRPCCloseLiveChatRoomReq::kLiveIdFieldNumber;
const int IMRPCCloseLiveChatRoomReq::kTarsInfoFieldNumber;
const int IMRPCCloseLiveChatRoomReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCCloseLiveChatRoomReq::IMRPCCloseLiveChatRoomReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCCloseLiveChatRoomReq)
}

void IMRPCCloseLiveChatRoomReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCCloseLiveChatRoomReq::IMRPCCloseLiveChatRoomReq(const IMRPCCloseLiveChatRoomReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCCloseLiveChatRoomReq)
}

void IMRPCCloseLiveChatRoomReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  tars_info_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCCloseLiveChatRoomReq::~IMRPCCloseLiveChatRoomReq() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCCloseLiveChatRoomReq)
  SharedDtor();
}

void IMRPCCloseLiveChatRoomReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCCloseLiveChatRoomReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCCloseLiveChatRoomReq& IMRPCCloseLiveChatRoomReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCCloseLiveChatRoomReq* IMRPCCloseLiveChatRoomReq::default_instance_ = NULL;

IMRPCCloseLiveChatRoomReq* IMRPCCloseLiveChatRoomReq::New() const {
  return new IMRPCCloseLiveChatRoomReq;
}

void IMRPCCloseLiveChatRoomReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRPCCloseLiveChatRoomReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(user_im_id_, live_id_);
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCCloseLiveChatRoomReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCCloseLiveChatRoomReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 3;
      case 3: {
        if (tag == 26) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCCloseLiveChatRoomReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCCloseLiveChatRoomReq)
  return false;
#undef DO_
}

void IMRPCCloseLiveChatRoomReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCCloseLiveChatRoomReq)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 3;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->tars_info(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCCloseLiveChatRoomReq)
}

int IMRPCCloseLiveChatRoomReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required .IM.RPC.TarsInfo tars_info = 3;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCCloseLiveChatRoomReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCCloseLiveChatRoomReq*>(&from));
}

void IMRPCCloseLiveChatRoomReq::MergeFrom(const IMRPCCloseLiveChatRoomReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCCloseLiveChatRoomReq::CopyFrom(const IMRPCCloseLiveChatRoomReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCCloseLiveChatRoomReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCCloseLiveChatRoomReq::Swap(IMRPCCloseLiveChatRoomReq* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCCloseLiveChatRoomReq::GetTypeName() const {
  return "IM.RPC.IMRPCCloseLiveChatRoomReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCCloseLiveChatRoomRsp::kUserImIdFieldNumber;
const int IMRPCCloseLiveChatRoomRsp::kLiveIdFieldNumber;
const int IMRPCCloseLiveChatRoomRsp::kResultFieldNumber;
const int IMRPCCloseLiveChatRoomRsp::kTarsInfoFieldNumber;
const int IMRPCCloseLiveChatRoomRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCCloseLiveChatRoomRsp::IMRPCCloseLiveChatRoomRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.RPC.IMRPCCloseLiveChatRoomRsp)
}

void IMRPCCloseLiveChatRoomRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCCloseLiveChatRoomRsp::IMRPCCloseLiveChatRoomRsp(const IMRPCCloseLiveChatRoomRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.RPC.IMRPCCloseLiveChatRoomRsp)
}

void IMRPCCloseLiveChatRoomRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_im_id_ = 0u;
  live_id_ = 0u;
  result_ = 0u;
  tars_info_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCCloseLiveChatRoomRsp::~IMRPCCloseLiveChatRoomRsp() {
  // @@protoc_insertion_point(destructor:IM.RPC.IMRPCCloseLiveChatRoomRsp)
  SharedDtor();
}

void IMRPCCloseLiveChatRoomRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCCloseLiveChatRoomRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCCloseLiveChatRoomRsp& IMRPCCloseLiveChatRoomRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRPC_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRPC_2eproto();
#endif
  return *default_instance_;
}

IMRPCCloseLiveChatRoomRsp* IMRPCCloseLiveChatRoomRsp::default_instance_ = NULL;

IMRPCCloseLiveChatRoomRsp* IMRPCCloseLiveChatRoomRsp::New() const {
  return new IMRPCCloseLiveChatRoomRsp;
}

void IMRPCCloseLiveChatRoomRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRPCCloseLiveChatRoomRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(user_im_id_, live_id_);
    result_ = 0u;
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCCloseLiveChatRoomRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.RPC.IMRPCCloseLiveChatRoomRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_im_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_live_id;
        break;
      }

      // required uint32 live_id = 2;
      case 2: {
        if (tag == 16) {
         parse_live_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &live_id_)));
          set_has_live_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_result;
        break;
      }

      // required uint32 result = 3;
      case 3: {
        if (tag == 24) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 4;
      case 4: {
        if (tag == 34) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.RPC.IMRPCCloseLiveChatRoomRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.RPC.IMRPCCloseLiveChatRoomRsp)
  return false;
#undef DO_
}

void IMRPCCloseLiveChatRoomRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.RPC.IMRPCCloseLiveChatRoomRsp)
  // required uint32 user_im_id = 1;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_im_id(), output);
  }

  // required uint32 live_id = 2;
  if (has_live_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->live_id(), output);
  }

  // required uint32 result = 3;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->result(), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 4;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->tars_info(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.RPC.IMRPCCloseLiveChatRoomRsp)
}

int IMRPCCloseLiveChatRoomRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_im_id = 1;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 live_id = 2;
    if (has_live_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->live_id());
    }

    // required uint32 result = 3;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // required .IM.RPC.TarsInfo tars_info = 4;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCCloseLiveChatRoomRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCCloseLiveChatRoomRsp*>(&from));
}

void IMRPCCloseLiveChatRoomRsp::MergeFrom(const IMRPCCloseLiveChatRoomRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_live_id()) {
      set_live_id(from.live_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCCloseLiveChatRoomRsp::CopyFrom(const IMRPCCloseLiveChatRoomRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCCloseLiveChatRoomRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  return true;
}

void IMRPCCloseLiveChatRoomRsp::Swap(IMRPCCloseLiveChatRoomRsp* other) {
  if (other != this) {
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(live_id_, other->live_id_);
    std::swap(result_, other->result_);
    std::swap(tars_info_, other->tars_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCCloseLiveChatRoomRsp::GetTypeName() const {
  return "IM.RPC.IMRPCCloseLiveChatRoomRsp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace RPC
}  // namespace IM

// @@protoc_insertion_point(global_scope)
