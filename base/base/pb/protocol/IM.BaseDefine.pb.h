// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

#ifndef PROTOBUF_IM_2eBaseDefine_2eproto__INCLUDED
#define PROTOBUF_IM_2eBaseDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace BaseDefine {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

class IpAddr;
class UserInfo;
class ContactSessionInfo;
class UserStat;
class ServerUserStat;
class UnreadInfo;
class MsgInfo;
class GroupVersionInfo;
class GroupInfo;
class GroupMsgInfo;
class UserTokenInfo;
class PushResult;
class ShieldStatus;
class OfflineFileInfo;
class DepartInfo;
class PushShieldStatus;
class StudentStat;
class ManagerStat;
class DutyStat;
class ComplaintRefundTeacherStat;
class TeacherStat;
class ConsultMsg;
class ConsultTimeout;
class GroupMemberInfo;

enum ServiceID {
  SID_LOGIN = 1,
  SID_BUDDY_LIST = 2,
  SID_MSG = 3,
  SID_GROUP = 4,
  SID_FILE = 5,
  SID_SWITCH_SERVICE = 6,
  SID_OTHER = 7,
  SID_INTERNAL = 8,
  SID_CONSULT = 9,
  SID_RPC = 10,
  SID_LIVE = 11
};
bool ServiceID_IsValid(int value);
const ServiceID ServiceID_MIN = SID_LOGIN;
const ServiceID ServiceID_MAX = SID_LIVE;
const int ServiceID_ARRAYSIZE = ServiceID_MAX + 1;

enum LoginCmdID {
  CID_LOGIN_REQ_MSGSERVER = 257,
  CID_LOGIN_RES_MSGSERVER = 258,
  CID_LOGIN_REQ_USERLOGIN = 259,
  CID_LOGIN_RES_USERLOGIN = 260,
  CID_LOGIN_REQ_LOGINOUT = 261,
  CID_LOGIN_RES_LOGINOUT = 262,
  CID_LOGIN_KICK_USER = 263,
  CID_LOGIN_REQ_DEVICETOKEN = 264,
  CID_LOGIN_RES_DEVICETOKEN = 265,
  CID_LOGIN_REQ_KICKPCCLIENT = 266,
  CID_LOGIN_RES_KICKPCCLIENT = 267,
  CID_LOGIN_REQ_PUSH_SHIELD = 268,
  CID_LOGIN_RES_PUSH_SHIELD = 269,
  CID_LOGIN_REQ_QUERY_PUSH_SHIELD = 270,
  CID_LOGIN_RES_QUERY_PUSH_SHIELD = 271,
  CID_LOGIN_REQ_SYSTEMLOGIN = 272,
  CID_LOGIN_RES_SYSTEMLOGIN = 273,
  CID_LOGIN_REQ_WSSERVER = 513,
  CID_LOGIN_RES_WSSERVER = 514
};
bool LoginCmdID_IsValid(int value);
const LoginCmdID LoginCmdID_MIN = CID_LOGIN_REQ_MSGSERVER;
const LoginCmdID LoginCmdID_MAX = CID_LOGIN_RES_WSSERVER;
const int LoginCmdID_ARRAYSIZE = LoginCmdID_MAX + 1;

enum BuddyListCmdID {
  CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST = 513,
  CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE = 514,
  CID_BUDDY_LIST_STATUS_NOTIFY = 515,
  CID_BUDDY_LIST_USER_INFO_REQUEST = 516,
  CID_BUDDY_LIST_USER_INFO_RESPONSE = 517,
  CID_BUDDY_LIST_REMOVE_SESSION_REQ = 518,
  CID_BUDDY_LIST_REMOVE_SESSION_RES = 519,
  CID_BUDDY_LIST_ALL_USER_REQUEST = 520,
  CID_BUDDY_LIST_ALL_USER_RESPONSE = 521,
  CID_BUDDY_LIST_USERS_STATUS_REQUEST = 522,
  CID_BUDDY_LIST_USERS_STATUS_RESPONSE = 523,
  CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST = 524,
  CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE = 525,
  CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY = 526,
  CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY = 527,
  CID_BUDDY_LIST_DEPARTMENT_REQUEST = 528,
  CID_BUDDY_LIST_DEPARTMENT_RESPONSE = 529,
  CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY = 530,
  CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST = 531,
  CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE = 532,
  CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY = 533,
  CID_BUDDY_LIST_TOBE_FRIEND_REQUEST = 534,
  CID_BUDDY_LIST_TOBE_FRIEND_RESPONSE = 535,
  CID_BUDDY_LIST_REVIEW_FRIEND_REQUEST = 536,
  CID_BUDDY_LIST_REVIEW_FRIEND_RESPONSE = 537,
  CID_BUDDY_LIST_DELETE_FRIEND_REQUEST = 544,
  CID_BUDDY_LIST_DELETE_FRIEND_RESPONSE = 545,
  CID_BUDDY_LIST_SHIELD_FRIEND_REQUEST = 546,
  CID_BUDDY_LIST_SHIELD_FRIEND_RESPONSE = 547
};
bool BuddyListCmdID_IsValid(int value);
const BuddyListCmdID BuddyListCmdID_MIN = CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST;
const BuddyListCmdID BuddyListCmdID_MAX = CID_BUDDY_LIST_SHIELD_FRIEND_RESPONSE;
const int BuddyListCmdID_ARRAYSIZE = BuddyListCmdID_MAX + 1;

enum MessageCmdID {
  CID_MSG_DATA = 769,
  CID_MSG_DATA_ACK = 770,
  CID_MSG_READ_ACK = 771,
  CID_MSG_READ_NOTIFY = 772,
  CID_MSG_TIME_REQUEST = 773,
  CID_MSG_TIME_RESPONSE = 774,
  CID_MSG_UNREAD_CNT_REQUEST = 775,
  CID_MSG_UNREAD_CNT_RESPONSE = 776,
  CID_MSG_LIST_REQUEST = 777,
  CID_MSG_LIST_RESPONSE = 778,
  CID_MSG_GET_LATEST_MSG_ID_REQ = 779,
  CID_MSG_GET_LATEST_MSG_ID_RSP = 780,
  CID_MSG_GET_BY_MSG_ID_REQ = 781,
  CID_MSG_GET_BY_MSG_ID_RES = 782,
  CID_MSG_SYSTEM_OFFLINE = 784,
  CID_MSG_SAVE_GROUP_BASE_INFO_ALTER_NOTIFY = 785,
  CID_MSG_SAVE_GROUP_MEMBER_LIST_ALTER_NOTIFY = 786,
  CID_MSG_SAVE_GROUP_MEMBER_BASE_INFO_NOTIFY = 787,
  CID_MSG_SAVE_GROUP_MEMBER_IDENTITY_ALTER_NOTIFY = 788,
  CID_MSG_SAVE_GROUP_SET_ANNOUNCE_ALTER_NOTIFY = 789,
  CID_MSG_SAVE_GROUP_MANAGEMENT_ALTER_NOTIFY = 790,
  CID_MSG_SAVE_GROUP_AT_NOTIFY = 791,
  CID_MSG_SAVE_GROUP_REMOVE_ANNOUNCE_ALTER_NOTIFY = 792,
  CID_MSG_SINGLE_DATA = 848,
  CID_MSG_SINGLE_DATA_ACK = 849,
  CID_MQMSG_DATA_PRODUCE = 864
};
bool MessageCmdID_IsValid(int value);
const MessageCmdID MessageCmdID_MIN = CID_MSG_DATA;
const MessageCmdID MessageCmdID_MAX = CID_MQMSG_DATA_PRODUCE;
const int MessageCmdID_ARRAYSIZE = MessageCmdID_MAX + 1;

enum GroupCmdID {
  CID_GROUP_NORMAL_LIST_REQUEST = 1025,
  CID_GROUP_NORMAL_LIST_RESPONSE = 1026,
  CID_GROUP_INFO_REQUEST = 1027,
  CID_GROUP_INFO_RESPONSE = 1028,
  CID_GROUP_CREATE_REQUEST = 1029,
  CID_GROUP_CREATE_RESPONSE = 1030,
  CID_GROUP_CHANGE_MEMBER_REQUEST = 1031,
  CID_GROUP_CHANGE_MEMBER_RESPONSE = 1032,
  CID_GROUP_SHIELD_GROUP_REQUEST = 1033,
  CID_GROUP_SHIELD_GROUP_RESPONSE = 1034,
  CID_GROUP_CHANGE_MEMBER_NOTIFY = 1035,
  CID_GROUP_MEMBER_INVITE_REQUEST = 1040,
  CID_GROUP_MEMBER_INVITE_RESPONSE = 1041,
  CID_GROUP_MEMBER_KICK_REQUEST = 1042,
  CID_GROUP_MEMBER_KICK_RESPONSE = 1043,
  CID_GROUP_MEMBER_APPLY_REQUEST = 1044,
  CID_GROUP_MEMBER_APPLY_RESPONSE = 1045,
  CID_GROUP_MEMBER_REVIEW_REQUEST = 1046,
  CID_GROUP_MEMBER_REVIEW_RESPONSE = 1047,
  CID_GROUP_MEMBER_QUIT_REQUEST = 1048,
  CID_GROUP_MEMBER_QUIT_RESPONSE = 1049,
  CID_GROUP_MEMBER_DISMISS_REQUEST = 1056,
  CID_GROUP_MEMBER_DISMISS_RESPONSE = 1057,
  CID_GROUP_INFO_MODIFY_REQUEST = 1058,
  CID_GROUP_INFO_MODIFY_RESPONSE = 1059,
  CID_GROUP_INFO_ALTER_NOTIFY = 1060,
  CID_GROUP_MEMBER_LIST_REQUEST = 1061,
  CID_GROUP_MEMBER_LIST_RESPONSE = 1062,
  CID_GROUP_FORBIDDEN_REQUEST = 1063,
  CID_GROUP_FORBIDDEN_RESPONSE = 1064,
  CID_GROUP_SET_MEMBER_IDENTITY_REQUEST = 1065,
  CID_GROUP_SET_MEMBER_IDENTITY_RESPONSE = 1066,
  CID_GROUP_MEMBER_INFO_UPDATE_REQUEST = 1067,
  CID_GROUP_MEMBER_INFO_UPDATE_RESPONSE = 1068,
  CID_GROUP_MEMBER_FORBIDDEN_REQUEST = 1069,
  CID_GROUP_MEMBER_FORBIDDEN_RESPONSE = 1070,
  CID_GROUP_BASE_INFO_ALTER_NOTIFY = 1072,
  CID_GROUP_MEMBER_LIST_ALTER_NOTIFY = 1073,
  CID_GROUP_MEMBER_BASE_INFO_NOTIFY = 1074,
  CID_GROUP_MEMBER_IDENTITY_ALTER_NOTIFY = 1075,
  CID_GROUP_SET_ANNOUNCE_ALTER_NOTIFY = 1076,
  CID_GROUP_MANAGEMENT_ALTER_NOTIFY = 1077,
  CID_GROUP_AT_NOTIFY = 1078,
  CID_GROUP_REMOVE_ANNOUNCE_ALTER_NOTIFY = 1079,
  CID_GROUP_SET_ANNOUNCE_REQUEST = 1088,
  CID_GROUP_SET_ANNOUNCE_RESPONSE = 1089,
  CID_GROUP_GET_ANNOUNCE_REQUEST = 1090,
  CID_GROUP_GET_ANNOUNCE_RESPONSE = 1091,
  CID_GROUP_MANAGEMENT_MODIFY_REQUEST = 1092,
  CID_GROUP_MANAGEMENT_MODIFY_RESPONSE = 1093,
  CID_GROUP_AT_REQUEST = 1094,
  CID_GROUP_AT_RESPONSE = 1095,
  CID_GROUP_REMOVE_ANNOUNCE_REQUEST = 1096,
  CID_GROUP_REMOVE_ANNOUNCE_RESPONSE = 1097,
  CID_GROUP_MEMBER_INFO_REQUEST = 1098,
  CID_GROUP_MEMBER_INFO_RESPONSE = 1099,
  CID_GROUP_DESCP_REQUEST = 1100,
  CID_GROUP_DESCP_RESPONSE = 1101,
  CID_GROUP_MEMBER_MODIFY_TOP_REQUEST = 1102,
  CID_GROUP_MEMBER_MODIFY_TOP_RESPONSE = 1103
};
bool GroupCmdID_IsValid(int value);
const GroupCmdID GroupCmdID_MIN = CID_GROUP_NORMAL_LIST_REQUEST;
const GroupCmdID GroupCmdID_MAX = CID_GROUP_MEMBER_MODIFY_TOP_RESPONSE;
const int GroupCmdID_ARRAYSIZE = GroupCmdID_MAX + 1;

enum FileCmdID {
  CID_FILE_LOGIN_REQ = 1281,
  CID_FILE_LOGIN_RES = 1282,
  CID_FILE_STATE = 1283,
  CID_FILE_PULL_DATA_REQ = 1284,
  CID_FILE_PULL_DATA_RSP = 1285,
  CID_FILE_REQUEST = 1286,
  CID_FILE_RESPONSE = 1287,
  CID_FILE_NOTIFY = 1288,
  CID_FILE_HAS_OFFLINE_REQ = 1289,
  CID_FILE_HAS_OFFLINE_RES = 1290,
  CID_FILE_ADD_OFFLINE_REQ = 1291,
  CID_FILE_DEL_OFFLINE_REQ = 1292
};
bool FileCmdID_IsValid(int value);
const FileCmdID FileCmdID_MIN = CID_FILE_LOGIN_REQ;
const FileCmdID FileCmdID_MAX = CID_FILE_DEL_OFFLINE_REQ;
const int FileCmdID_ARRAYSIZE = FileCmdID_MAX + 1;

enum SwitchServiceCmdID {
  CID_SWITCH_P2P_CMD = 1537
};
bool SwitchServiceCmdID_IsValid(int value);
const SwitchServiceCmdID SwitchServiceCmdID_MIN = CID_SWITCH_P2P_CMD;
const SwitchServiceCmdID SwitchServiceCmdID_MAX = CID_SWITCH_P2P_CMD;
const int SwitchServiceCmdID_ARRAYSIZE = SwitchServiceCmdID_MAX + 1;

enum OtherCmdID {
  CID_OTHER_HEARTBEAT = 1793,
  CID_OTHER_STOP_RECV_PACKET = 1794,
  CID_OTHER_VALIDATE_REQ = 1795,
  CID_OTHER_VALIDATE_RSP = 1796,
  CID_OTHER_GET_DEVICE_TOKEN_REQ = 1797,
  CID_OTHER_GET_DEVICE_TOKEN_RSP = 1798,
  CID_OTHER_ROLE_SET = 1799,
  CID_OTHER_ONLINE_USER_INFO = 1800,
  CID_OTHER_MSG_SERV_INFO = 1801,
  CID_OTHER_USER_STATUS_UPDATE = 1802,
  CID_OTHER_USER_CNT_UPDATE = 1803,
  CID_OTHER_SERVER_KICK_USER = 1805,
  CID_OTHER_LOGIN_STATUS_NOTIFY = 1806,
  CID_OTHER_PUSH_TO_USER_REQ = 1807,
  CID_OTHER_PUSH_TO_USER_RSP = 1808,
  CID_OTHER_GET_SHIELD_REQ = 1809,
  CID_OTHER_GET_SHIELD_RSP = 1810,
  CID_OTHER_FILE_TRANSFER_REQ = 1841,
  CID_OTHER_FILE_TRANSFER_RSP = 1842,
  CID_OTHER_FILE_SERVER_IP_REQ = 1843,
  CID_OTHER_FILE_SERVER_IP_RSP = 1844,
  CID_OTHER_SINGLE_FORBID_INNER_REQ = 1856,
  CID_OTHER_SINGLE_FORBID_INNER_RSP = 1857,
  CID_OTHER_SINGLE_FORBID_NOTIFY = 1858,
  CID_OTHER_SINGLE_GET_FORBIDDEN_REQ = 1859,
  CID_OTHER_SINGLE_GET_FORBIDDEN_RSP = 1860,
  CID_OTHER_SINGLE_SHIELD_REQ = 1866,
  CID_OTHER_SINGLE_SHIELD_RSP = 1867,
  CID_OTHER_SINGLE_GET_SHIELD_REQ = 1868,
  CID_OTHER_SINGLE_GET_SHIELD_RSP = 1869,
  CID_OTHER_GET_DELIVER_MSG_REQ = 1870,
  CID_OTHER_GET_DELIVER_MSG_RSP = 1871,
  CID_OTHER_CONSULT_TIMEOUT_CHECK = 1872,
  CID_OTHER_CONSULT_TIMEOUT_CHECK_ACK = 1873,
  CID_OTHER_GET_CONSULT_QUEUE_REQ = 1874,
  CID_OTHER_GET_CONSULT_QUEUE_RSP = 1875,
  CID_OTHER_GET_DB_SERVER_CNT_REQ = 1876,
  CID_OTHER_GET_DB_SERVER_CNT_RSP = 1877,
  CID_OTHER_SET_DB_SERVER_CNT_REQ = 1878,
  CID_OTHER_SET_DB_SERVER_CNT_RSP = 1879,
  CID_OTHER_MANAGER_PLATFORM_GET_TEACHER_INFO_REQ = 1880,
  CID_OTHER_MANAGER_PLATFORM_GET_TEACHER_INFO_RSP = 1881,
  CID_OTHER_RPC_MSG_GROUP_DATA = 1888,
  CID_OTHER_WS_SERV_INFO = 2048
};
bool OtherCmdID_IsValid(int value);
const OtherCmdID OtherCmdID_MIN = CID_OTHER_HEARTBEAT;
const OtherCmdID OtherCmdID_MAX = CID_OTHER_WS_SERV_INFO;
const int OtherCmdID_ARRAYSIZE = OtherCmdID_MAX + 1;

enum ConsultCmdID {
  CID_CONSULT_DATA = 2049,
  CID_CONSULT_DATA_ACK = 2050,
  CID_CONSULT_GET_TEACHER_INFO_REQUEST = 2051,
  CID_CONSULT_GET_TEACHER_INFO_RESPONSE = 2052,
  CID_CONSULT_GET_STUDENT_STATE_REQUEST = 2053,
  CID_CONSULT_GET_STUDENT_STATE_RESPONSE = 2054,
  CID_CONSULT_CREAT_REQUEST = 2055,
  CID_CONSULT_CREAT_RESPONSE = 2056,
  CID_CONSULT_CLOSE_REQUEST = 2057,
  CID_CONSULT_CLOSE_RESPONSE = 2058,
  CID_CONSULT_CREATE_ANNOUNCE = 2059,
  CID_CONSULT_CLOSE_ANNOUNCE = 2060,
  CID_CONSULT_STUDENT_IN_QUEUE_REQUEST = 2061,
  CID_CONSULT_STUDENT_IN_QUEUE_RESPONSE = 2062,
  CID_CONSULT_TEACHER_OFFILNE_INFORM = 2063,
  CID_CONSULT_STUDENT_OUT_QUEUE_REQUEST = 2065,
  CID_CONSULT_STUDENT_OUT_QUEUE_RESPONSE = 2066,
  CID_CONSULT_TEACHER_MODIFY_STATE_REQUEST = 2067,
  CID_CONSULT_TEACHER_MODIFY_STATE_RESPONSE = 2068,
  CID_CONSULT_GET_TEACHER_ONLINE_STATE_REQUEST = 2069,
  CID_CONSULT_GET_TEACHER_ONLINE_STATE_RESPONSE = 2070,
  CID_CONSULT_TEACHER_MODIFY_TOP_REQUEST = 2071,
  CID_CONSULT_TEACHER_MODIFY_TOP_RESPONSE = 2072,
  CID_CONSULT_STUDENT_GET_STATE_REQUEST = 2073,
  CID_CONSULT_STUDENT_GET_STATE_RESPONSE = 2074,
  CID_CONSULT_GET_STUDENT_CONSULT_TEACHER_LIST_REQUEST = 2075,
  CID_CONSULT_GET_STUDENT_CONSULT_TEACHER_LIST_RESPONSE = 2076,
  CID_CONSULT_DELIVER_REQUEST = 2077,
  CID_CONSULT_DELIVER_RESPONSE = 2078,
  CID_CONSULT_DELIVER_ANNOUNCE = 2079,
  CID_CONSULT_COMPLAINT_REFUND_GET_TEACHER_INFO_REQUEST = 2080,
  CID_CONSULT_COMPLAINT_REFUND_GET_TEACHER_INFO_RESPONSE = 2081
};
bool ConsultCmdID_IsValid(int value);
const ConsultCmdID ConsultCmdID_MIN = CID_CONSULT_DATA;
const ConsultCmdID ConsultCmdID_MAX = CID_CONSULT_COMPLAINT_REFUND_GET_TEACHER_INFO_RESPONSE;
const int ConsultCmdID_ARRAYSIZE = ConsultCmdID_MAX + 1;

enum RPCCmdID {
  CID_RPC_GET_COURSE_GROUP_INFO_REQUEST = 2305,
  CID_RPC_GET_COURSE_GROUP_INFO_RESPONSE = 2306,
  CID_RPC_SEND_GROUP_MSG_REQUEST = 2307,
  CID_RPC_SEND_GROUP_MSG_RESPONSE = 2308,
  CID_RPC_DELETE_GROUP_MSG_REQUEST = 2309,
  CID_RPC_DELETE_GROUP_MSG_RESPONSE = 2310,
  CID_RPC_CREATE_LIVEROOM_MSG_REQUEST = 2311,
  CID_RPC_CREATE_LIVEROOM_MSG_RESPONSE = 2312,
  CID_RPC_CLOSE_LIVEROOM_MSG_REQUEST = 2313,
  CID_RPC_CLOSE_LIVEROOM_MSG_RESPONSE = 2320
};
bool RPCCmdID_IsValid(int value);
const RPCCmdID RPCCmdID_MIN = CID_RPC_GET_COURSE_GROUP_INFO_REQUEST;
const RPCCmdID RPCCmdID_MAX = CID_RPC_CLOSE_LIVEROOM_MSG_RESPONSE;
const int RPCCmdID_ARRAYSIZE = RPCCmdID_MAX + 1;

enum LiveCmdID {
  CID_LIVE_LOGIN_ROOM_REQUEST = 2561,
  CID_LIVE_LOGIN_ROOM_RESPONSE = 2562,
  CID_LIVE_LOGOUT_ROOM_REQUEST = 2563,
  CID_LIVE_LOGOUT_ROOM_RESPONSE = 2564,
  CID_LIVE_DATA = 2565,
  CID_LIVE_SET_ROOM_FORBIDDEN_STATUS_REQUEST = 2566,
  CID_LIVE_SET_ROOM_FORBIDDEN_STATUS_RESPONSE = 2567,
  CID_LIVE_GET_ROOM_FORBIDDEN_STATUS_REQUEST = 2568,
  CID_LIVE_GET_ROOM_FORBIDDEN_STATUS_RESPONSE = 2569,
  CID_LIVE_GET_ROOM_INFO_REQUEST = 2570,
  CID_LIVE_GET_ROOM_INFO_RESPONSE = 2571,
  CID_LIVE_NOTIFY_NEW_MSG = 2572,
  CID_LIVE_NOTIFY_ROOM_CLOSE_MSG = 2573,
  CID_LIVE_NOTIFY_ROOM_FORBIDDEN_STATUS = 2574,
  CID_LIVE_NOTIFY_MEMBER_LOGIN = 2575,
  CID_LIVE_NOTIFY_MEMBER_LOGOUT = 2576,
  CID_LIVE_KICK_USER = 2577,
  CID_LIVE_USER_OFFLINE_EXCEPTION = 2578
};
bool LiveCmdID_IsValid(int value);
const LiveCmdID LiveCmdID_MIN = CID_LIVE_LOGIN_ROOM_REQUEST;
const LiveCmdID LiveCmdID_MAX = CID_LIVE_USER_OFFLINE_EXCEPTION;
const int LiveCmdID_ARRAYSIZE = LiveCmdID_MAX + 1;

enum ServerRespState {
  RESP_OK = 0,
  RESP_ERROR = 1,
  RESP_FRIEND_REQ_EXPIRE_TIME = 2,
  RESP_FRIEND_HAS_BEEN_FRIEND = 3,
  RESP_FRIEND_REQ_NOT_RECEIVED = 4,
  RESP_MESSAGE_SENSITIVE = 5,
  RESP_MEMBER_FORBIDDEN = 6,
  RESP_GROUP_MEMBER_NO_PERMISSION = 7,
  RESP_GROUP_MEMBER_REACH_LIMIT = 8,
  RESP_GROUP_ALREADY_BE_MEMBER = 9,
  RESP_GROUP_NOT_EXIST = 10,
  RESP_GROUP_NOT_MEMBER = 11,
  RESP_GROUP_SOME_ALREADY_BE_MEMBER = 12,
  RESP_GROUP_USER_GROUP_NUMBER_REACH_LIMIT = 13,
  RESP_GROUP_SOME_USER_GROUP_NUMBER_REACH_LIMIT = 14,
  RESP_GROUP_REPETITIVE_OPERATION = 15,
  RESP_GROUP_KICK_ADMIN = 16,
  RESP_GROUP_INPUT_PARAMETER_ERR = 17,
  RESP_PEER_CLIENT_VERSION_TOO_OLD = 20,
  RESP_SINGLE_FORBIDDEN = 21,
  RESP_SINGLE_SHIELD_BY_PEER = 22,
  RESP_TIMEOUT_ERROR = 23,
  RESP_CONSULT_IS_CLOSED = 40,
  RESP_CONSULT_INPUT_PARAMETER_ERR = 41,
  RESP_CONSULT_STUDENT_IS_IN_QUEUE = 42,
  RESP_CONSULT_STUDENT_IS_IN_CONSULT = 43,
  RESP_CONSULT_TEACHER_IS_NOT_ONLINE = 44
};
bool ServerRespState_IsValid(int value);
const ServerRespState ServerRespState_MIN = RESP_OK;
const ServerRespState ServerRespState_MAX = RESP_CONSULT_TEACHER_IS_NOT_ONLINE;
const int ServerRespState_ARRAYSIZE = ServerRespState_MAX + 1;

enum GroupAlterType {
  GROUP_INVITE_USER = 0,
  GROUP_KICK_USER = 1,
  GROUP_APPLY_MEMBER = 2,
  GROUP_APPLY_ACCEPT = 3,
  GROUP_USER_QUIT = 4,
  GROUP_DISMISS_NOTIFY = 5,
  GROUP_INFO_CHANGE = 6,
  GROUP_MEMBER_FORBIDDEN = 7,
  GROUP_MEMBER_IDENTITY_CHANGE = 8,
  GROUP_MEMBER_INFO_CHANGE = 9,
  GROUP_FORBIDDEN_ALL = 10,
  GROUP_INVITE_USER_V2 = 11,
  GROUP_KICK_USER_V2 = 12,
  GROUP_USER_QUIT_V2 = 13,
  GROUP_SET_ANNOUNCE = 14,
  GROUP_MANAGEMENT_MODIFY = 15,
  GROUP_AT = 16,
  GROUP_REMOVE_ANNOUNCE = 17,
  GROUP_MANAGEMENT_MODIFY_TO_NEW_OWNER_FOR_PUSH = 18
};
bool GroupAlterType_IsValid(int value);
const GroupAlterType GroupAlterType_MIN = GROUP_INVITE_USER;
const GroupAlterType GroupAlterType_MAX = GROUP_MANAGEMENT_MODIFY_TO_NEW_OWNER_FOR_PUSH;
const int GroupAlterType_ARRAYSIZE = GroupAlterType_MAX + 1;

enum GroupAtType {
  GROUP_AT_TYPE_NONE = 0,
  GROUP_AT_TYPE_NORMAL = 1,
  GROUP_AT_TYPE_ALL = 2
};
bool GroupAtType_IsValid(int value);
const GroupAtType GroupAtType_MIN = GROUP_AT_TYPE_NONE;
const GroupAtType GroupAtType_MAX = GROUP_AT_TYPE_ALL;
const int GroupAtType_ARRAYSIZE = GroupAtType_MAX + 1;

enum SystemMessageType {
  SYS_PEER_CLIENT_VERSION_TOO_OLD = 1
};
bool SystemMessageType_IsValid(int value);
const SystemMessageType SystemMessageType_MIN = SYS_PEER_CLIENT_VERSION_TOO_OLD;
const SystemMessageType SystemMessageType_MAX = SYS_PEER_CLIENT_VERSION_TOO_OLD;
const int SystemMessageType_ARRAYSIZE = SystemMessageType_MAX + 1;

enum ReviewGroupMemberRequestAction {
  GROUP_MEMBER_REVIEW_ACCEPT = 0,
  GROUP_MEMBER_REVIEW_REFUSE = 1
};
bool ReviewGroupMemberRequestAction_IsValid(int value);
const ReviewGroupMemberRequestAction ReviewGroupMemberRequestAction_MIN = GROUP_MEMBER_REVIEW_ACCEPT;
const ReviewGroupMemberRequestAction ReviewGroupMemberRequestAction_MAX = GROUP_MEMBER_REVIEW_REFUSE;
const int ReviewGroupMemberRequestAction_ARRAYSIZE = ReviewGroupMemberRequestAction_MAX + 1;

enum GroupMessageType {
  GROUP_CHAT_MESSAGE = 0,
  GROUP_NOTIFY_MESSAGE = 1
};
bool GroupMessageType_IsValid(int value);
const GroupMessageType GroupMessageType_MIN = GROUP_CHAT_MESSAGE;
const GroupMessageType GroupMessageType_MAX = GROUP_NOTIFY_MESSAGE;
const int GroupMessageType_ARRAYSIZE = GroupMessageType_MAX + 1;

enum SingleForbiddenType {
  SINGLE_NO_FORBIDDEN = 1,
  SINGLE_FORBIDDEN = 2
};
bool SingleForbiddenType_IsValid(int value);
const SingleForbiddenType SingleForbiddenType_MIN = SINGLE_NO_FORBIDDEN;
const SingleForbiddenType SingleForbiddenType_MAX = SINGLE_FORBIDDEN;
const int SingleForbiddenType_ARRAYSIZE = SingleForbiddenType_MAX + 1;

enum SingleShieldType {
  SINGLE_NO_SHIELD = 1,
  SINGLE_SHIELD = 2
};
bool SingleShieldType_IsValid(int value);
const SingleShieldType SingleShieldType_MIN = SINGLE_NO_SHIELD;
const SingleShieldType SingleShieldType_MAX = SINGLE_SHIELD;
const int SingleShieldType_ARRAYSIZE = SingleShieldType_MAX + 1;

enum ResultType {
  REFUSE_REASON_NONE = 0,
  REFUSE_REASON_NO_MSG_SERVER = 1,
  REFUSE_REASON_MSG_SERVER_FULL = 2,
  REFUSE_REASON_NO_DB_SERVER = 3,
  REFUSE_REASON_NO_LOGIN_SERVER = 4,
  REFUSE_REASON_NO_ROUTE_SERVER = 5,
  REFUSE_REASON_DB_VALIDATE_FAILED = 6,
  REFUSE_REASON_VERSION_TOO_OLD = 7,
  REFUSE_REASON_NO_WS_SERVER = 8,
  REFUSE_REASON_WS_SERVER_FULL = 9
};
bool ResultType_IsValid(int value);
const ResultType ResultType_MIN = REFUSE_REASON_NONE;
const ResultType ResultType_MAX = REFUSE_REASON_WS_SERVER_FULL;
const int ResultType_ARRAYSIZE = ResultType_MAX + 1;

enum KickReasonType {
  KICK_REASON_DUPLICATE_USER = 1,
  KICK_REASON_MOBILE_KICK = 2
};
bool KickReasonType_IsValid(int value);
const KickReasonType KickReasonType_MIN = KICK_REASON_DUPLICATE_USER;
const KickReasonType KickReasonType_MAX = KICK_REASON_MOBILE_KICK;
const int KickReasonType_ARRAYSIZE = KickReasonType_MAX + 1;

enum OnlineListType {
  ONLINE_LIST_TYPE_FRIEND_LIST = 1
};
bool OnlineListType_IsValid(int value);
const OnlineListType OnlineListType_MIN = ONLINE_LIST_TYPE_FRIEND_LIST;
const OnlineListType OnlineListType_MAX = ONLINE_LIST_TYPE_FRIEND_LIST;
const int OnlineListType_ARRAYSIZE = OnlineListType_MAX + 1;

enum UserStatType {
  USER_STATUS_ONLINE = 1,
  USER_STATUS_OFFLINE = 2,
  USER_STATUS_LEAVE = 3
};
bool UserStatType_IsValid(int value);
const UserStatType UserStatType_MIN = USER_STATUS_ONLINE;
const UserStatType UserStatType_MAX = USER_STATUS_LEAVE;
const int UserStatType_ARRAYSIZE = UserStatType_MAX + 1;

enum SessionType {
  SESSION_TYPE_SINGLE = 1,
  SESSION_TYPE_GROUP = 2
};
bool SessionType_IsValid(int value);
const SessionType SessionType_MIN = SESSION_TYPE_SINGLE;
const SessionType SessionType_MAX = SESSION_TYPE_GROUP;
const int SessionType_ARRAYSIZE = SessionType_MAX + 1;

enum MsgType {
  MSG_TYPE_SINGLE_TEXT = 1,
  MSG_TYPE_SINGLE_AUDIO = 2,
  MSG_TYPE_SINGLE_PICTURE = 3,
  MSG_TYPE_SINGLE_FILE = 4,
  MSG_TYPE_SINGLE_VIDEO = 5,
  MSG_TYPE_SINGLE_SHARE = 6,
  MSG_TYPE_GROUP_TEXT = 17,
  MSG_TYPE_GROUP_AUDIO = 18,
  MSG_TYPE_GROUP_PICTURE = 19,
  MSG_TYPE_GROUP_FILE = 20,
  MSG_TYPE_GROUP_VIDEO = 21,
  MSG_TYPE_GROUP_SHARE = 22,
  MSG_TYPE_GROUP_QRCODE = 23,
  MSG_TYPE_GROUP_MSG_REVOKE = 32,
  MSG_TYPE_GROUP_MSG_SHIELD = 33,
  MSG_TYPE_GROUP_MSG_HOMEWORK = 64
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = MSG_TYPE_SINGLE_TEXT;
const MsgType MsgType_MAX = MSG_TYPE_GROUP_MSG_HOMEWORK;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

enum SingleChatType {
  SINGLE_CHAT_BETWEEN_STUDENTS = 1,
  SINGLE_CHAT_BETWEEN_STUDENTS_AND_TEACHERS = 2
};
bool SingleChatType_IsValid(int value);
const SingleChatType SingleChatType_MIN = SINGLE_CHAT_BETWEEN_STUDENTS;
const SingleChatType SingleChatType_MAX = SINGLE_CHAT_BETWEEN_STUDENTS_AND_TEACHERS;
const int SingleChatType_ARRAYSIZE = SingleChatType_MAX + 1;

enum ClientType {
  CLIENT_TYPE_WINDOWS = 1,
  CLIENT_TYPE_MAC = 2,
  CLIENT_TYPE_IOS = 17,
  CLIENT_TYPE_ANDROID = 18
};
bool ClientType_IsValid(int value);
const ClientType ClientType_MIN = CLIENT_TYPE_WINDOWS;
const ClientType ClientType_MAX = CLIENT_TYPE_ANDROID;
const int ClientType_ARRAYSIZE = ClientType_MAX + 1;

enum GroupType {
  GROUP_TYPE_NONE = 0,
  GROUP_TYPE_FRESHMAN = 1,
  GROUP_TYPE_FRESHMAN_CLASS = 2,
  GROUP_TYPE_SENIOR_CLASS = 3,
  GROUP_TYPE_ACTIVITY = 4,
  GROUP_TYPE_COURSE = 5,
  GROUP_TYPE_CLUB = 6,
  GROUP_TYPE_OTHER = 7
};
bool GroupType_IsValid(int value);
const GroupType GroupType_MIN = GROUP_TYPE_NONE;
const GroupType GroupType_MAX = GROUP_TYPE_OTHER;
const int GroupType_ARRAYSIZE = GroupType_MAX + 1;

enum GroupModifyType {
  GROUP_MODIFY_TYPE_ADD = 1,
  GROUP_MODIFY_TYPE_DEL = 2
};
bool GroupModifyType_IsValid(int value);
const GroupModifyType GroupModifyType_MIN = GROUP_MODIFY_TYPE_ADD;
const GroupModifyType GroupModifyType_MAX = GROUP_MODIFY_TYPE_DEL;
const int GroupModifyType_ARRAYSIZE = GroupModifyType_MAX + 1;

enum ClientIdentity {
  CLIENT_IDENTITY_STUDENT = 1,
  CLIENT_IDENTITY_MANAGER = 2,
  CLIENT_IDENTITY_DUTY = 3,
  CLIENT_IDENTITY_SYSTEM = 4,
  CLIENT_IDENTITY_COMPLAINT_REFUND = 5
};
bool ClientIdentity_IsValid(int value);
const ClientIdentity ClientIdentity_MIN = CLIENT_IDENTITY_STUDENT;
const ClientIdentity ClientIdentity_MAX = CLIENT_IDENTITY_COMPLAINT_REFUND;
const int ClientIdentity_ARRAYSIZE = ClientIdentity_MAX + 1;

enum GroupMemberDegree {
  GROUP_MEMBER_DEGREE_CREATOR = 1,
  GROUP_MEMBER_DEGREE_CLASS_LEADER = 2,
  GROUP_MEMBER_DEGREE_STUDENT = 3,
  GROUP_MEMBER_DEGREE_TEACHER = 4,
  GROUP_MEMBER_DEGREE_MONITOR = 5,
  GROUP_MEMBER_DEGREE_STUDY_LEADER = 6,
  GROUP_MEMBER_DEGREE_LAW_LEADER = 7,
  GROUP_MEMBER_DEGREE_GROUP_LEADER = 8,
  GROUP_MEMBER_DEGREE_SPEAK_TALENT = 9,
  GROUP_MEMBER_DEGREE_SUPER_ADMIN = 14
};
bool GroupMemberDegree_IsValid(int value);
const GroupMemberDegree GroupMemberDegree_MIN = GROUP_MEMBER_DEGREE_CREATOR;
const GroupMemberDegree GroupMemberDegree_MAX = GROUP_MEMBER_DEGREE_SUPER_ADMIN;
const int GroupMemberDegree_ARRAYSIZE = GroupMemberDegree_MAX + 1;

enum ConsultServiceType {
  CONSULT_SERVICE_TYPE_NORMAL = 0,
  CONSULT_SERVICE_TYPE_COMPLAINT_REFUND = 1
};
bool ConsultServiceType_IsValid(int value);
const ConsultServiceType ConsultServiceType_MIN = CONSULT_SERVICE_TYPE_NORMAL;
const ConsultServiceType ConsultServiceType_MAX = CONSULT_SERVICE_TYPE_COMPLAINT_REFUND;
const int ConsultServiceType_ARRAYSIZE = ConsultServiceType_MAX + 1;

enum ConsultHistoryType {
  CONSULT_HISTORY_NONE = 1,
  CONSULT_HISTORY_YES = 2
};
bool ConsultHistoryType_IsValid(int value);
const ConsultHistoryType ConsultHistoryType_MIN = CONSULT_HISTORY_NONE;
const ConsultHistoryType ConsultHistoryType_MAX = CONSULT_HISTORY_YES;
const int ConsultHistoryType_ARRAYSIZE = ConsultHistoryType_MAX + 1;

enum StudentConsultStatus {
  STUDENT_STATUS_IDLE = 1,
  STUDENT_STATUS_IN_CONSULT = 2,
  STUDENT_STATUS_IN_QUEUE = 3
};
bool StudentConsultStatus_IsValid(int value);
const StudentConsultStatus StudentConsultStatus_MIN = STUDENT_STATUS_IDLE;
const StudentConsultStatus StudentConsultStatus_MAX = STUDENT_STATUS_IN_QUEUE;
const int StudentConsultStatus_ARRAYSIZE = StudentConsultStatus_MAX + 1;

enum ConsultStatus {
  CONSULT_STATUS_NORMAL = 1,
  CONSULT_STATUS_CLOSE = 2
};
bool ConsultStatus_IsValid(int value);
const ConsultStatus ConsultStatus_MIN = CONSULT_STATUS_NORMAL;
const ConsultStatus ConsultStatus_MAX = CONSULT_STATUS_CLOSE;
const int ConsultStatus_ARRAYSIZE = ConsultStatus_MAX + 1;

enum ConsultCreateType {
  CONSULT_CREATE_TYPE_STUDENT_TO_DUTY = 1,
  CONSULT_CREATE_TYPE_STUDENT_TO_MANAGER = 2,
  CONSULT_CREATE_TYPE_STUDENT_LEAVE_MSG_TO_MANAGER = 3,
  CONSULT_CREATE_TYPE_STUDENT_TO_DUTY_OUT_QUEUE = 4,
  CONSULT_CREATE_TYPE_STUDENT_TO_MANAGER_OUT_QUEUE = 5,
  CONSULT_CREATE_TYPE_MANAGER_TO_STUDENT = 6,
  CONSULT_CREATE_TYPE_DUTY_DELIVER_TO_ONLINE_MANAGER = 7,
  CONSULT_CREATE_TYPE_DUTY_DELIVER_TO_OFFLINE_MANAGER = 8,
  CONSULT_CREATE_TYPE_DUTY_TO_STUDENT = 9,
  CONSULT_CREATE_TYPE_STUDENT_LEAVE_MSG_TO_DUTY = 10,
  CONSULT_CREATE_TYPE_STUDENT_CONTINUE_CONSULT_TO_ONLINE_MANAGER = 32,
  CONSULT_CREATE_TYPE_STUDENT_CONTINUE_CONSULT_TO_OFFLINE_MANAGER = 33,
  CONSULT_CREATE_TYPE_DUTY_OFFLINE_STUDENT_TO_ONLINE_MANAGER = 34,
  CONSULT_CREATE_TYPE_DUTY_BUSY_STUDENT_TO_ONLINE_MANAGER = 35,
  CONSULT_COMPLAINT_REFUND_CREATE_TYPE_STUDENT_TO_TEACHER = 64,
  CONSULT_COMPLAINT_REFUND_CREATE_TYPE_STUDENT_TO_TEACHER_OUT_QUEUE = 65,
  CONSULT_COMPLAINT_REFUND_CREATE_TYPE_STUDENT_LEAVE_MSG_TO_TEACHER = 66,
  CONSULT_COMPLAINT_REFUND_CREATE_TYPE_TEACHER_TO_STUDENT = 67
};
bool ConsultCreateType_IsValid(int value);
const ConsultCreateType ConsultCreateType_MIN = CONSULT_CREATE_TYPE_STUDENT_TO_DUTY;
const ConsultCreateType ConsultCreateType_MAX = CONSULT_COMPLAINT_REFUND_CREATE_TYPE_TEACHER_TO_STUDENT;
const int ConsultCreateType_ARRAYSIZE = ConsultCreateType_MAX + 1;

enum ConsultCloseType {
  CONSULT_CLOSE_TYPE_STUDENT_CLOSE = 1,
  CONSULT_CLOSE_TYPE_DUTY_CLOSE = 2,
  CONSULT_CLOSE_TYPE_MANAGER_CLOSE = 3,
  CONSULT_CLOSE_TYPE_STUDENT_OVERTIME_CLOSE = 4,
  CONSULT_CLOSE_TYPE_DUTY_OVERTIME_CLOSE = 5,
  CONSULT_CLOSE_TYPE_MANAGER_OVERTIME_CLOSE = 6,
  CONSULT_CLOSE_TYPE_ABNORMAL_CLOSE = 7,
  CONSULT_CLOSE_TYPE_STUDENT_CLOSE_INNER = 32,
  CONSULT_COMPLAINT_REFUND_CLOSE_TYPE_STUDENT_SWITCH_ORDER = 64,
  CONSULT_COMPLAINT_REFUND_CLOSE_TYPE_TEACHER_CLOSE = 65,
  CONSULT_COMPLAINT_REFUND_CLOSE_TYPE_STUDENT_OVERTIME_CLOSE = 66,
  CONSULT_COMPLAINT_REFUND_CLOSE_TYPE_TEACHER_OVERTIME_CLOSE = 67,
  CONSULT_COMPLAINT_REFUND_CLOSE_TYPE_ABNORMAL_CLOSE = 68
};
bool ConsultCloseType_IsValid(int value);
const ConsultCloseType ConsultCloseType_MIN = CONSULT_CLOSE_TYPE_STUDENT_CLOSE;
const ConsultCloseType ConsultCloseType_MAX = CONSULT_COMPLAINT_REFUND_CLOSE_TYPE_ABNORMAL_CLOSE;
const int ConsultCloseType_ARRAYSIZE = ConsultCloseType_MAX + 1;

enum ConsultType2APP {
  CONSULT_CREATE_TYPE_ONLINE = 1,
  CONSULT_CREATE_TYPE_LEAVE_MSG = 2
};
bool ConsultType2APP_IsValid(int value);
const ConsultType2APP ConsultType2APP_MIN = CONSULT_CREATE_TYPE_ONLINE;
const ConsultType2APP ConsultType2APP_MAX = CONSULT_CREATE_TYPE_LEAVE_MSG;
const int ConsultType2APP_ARRAYSIZE = ConsultType2APP_MAX + 1;

enum ConsultTopType {
  CONSULT_NO_TOP = 1,
  CONSULT_TOP = 2
};
bool ConsultTopType_IsValid(int value);
const ConsultTopType ConsultTopType_MIN = CONSULT_NO_TOP;
const ConsultTopType ConsultTopType_MAX = CONSULT_TOP;
const int ConsultTopType_ARRAYSIZE = ConsultTopType_MAX + 1;

enum GroupTopType {
  GROUP_NO_TOP = 1,
  GROUP_TOP = 2
};
bool GroupTopType_IsValid(int value);
const GroupTopType GroupTopType_MIN = GROUP_NO_TOP;
const GroupTopType GroupTopType_MAX = GROUP_TOP;
const int GroupTopType_ARRAYSIZE = GroupTopType_MAX + 1;

enum ConsultMsgSourceType {
  CONSULT_MSG_SOURCE_TYPE_APP = 1,
  CONSULT_MSG_SOURCE_TYPE_WEB = 2,
  CONSULT_MSG_SOURCE_TYPE_WECHAT = 3,
  CONSULT_MSG_SOURCE_TYPE_SYSTEM = 4
};
bool ConsultMsgSourceType_IsValid(int value);
const ConsultMsgSourceType ConsultMsgSourceType_MIN = CONSULT_MSG_SOURCE_TYPE_APP;
const ConsultMsgSourceType ConsultMsgSourceType_MAX = CONSULT_MSG_SOURCE_TYPE_SYSTEM;
const int ConsultMsgSourceType_ARRAYSIZE = ConsultMsgSourceType_MAX + 1;

enum ConlustMsgType {
  CONSULT_MSG_TYPE_TEXT = 1,
  CONSULT_MSG_TYPE_AUDIO = 2,
  CONSULT_MSG_TYPE_PICTURE = 3,
  CONSULT_MSG_TYPE_FILE = 4,
  CONSULT_MSG_TYPE_VIDEO = 5,
  CONSULT_MSG_TYPE_SYSTEM_TEXT = 17
};
bool ConlustMsgType_IsValid(int value);
const ConlustMsgType ConlustMsgType_MIN = CONSULT_MSG_TYPE_TEXT;
const ConlustMsgType ConlustMsgType_MAX = CONSULT_MSG_TYPE_SYSTEM_TEXT;
const int ConlustMsgType_ARRAYSIZE = ConlustMsgType_MAX + 1;

enum ConsultScriptType {
  CONSULT_SCRIPT_TYPE_DUTY_CONNECTED_TO_APP = 1,
  CONSULT_SCRIPT_TYPE_MANAGER_ONLINE_CONNECTED_TO_APP = 2,
  CONSULT_SCRIPT_TYPE_MANAGER_OFFLINE_CONNECTED_TO_APP = 3,
  CONSULT_SCRIPT_TYPE_STUDENT_CLOSE_TO_TEACHER = 4,
  CONSULT_SCRIPT_TYPE_TEACHER_CLOSE_TO_APP = 5,
  CONSULT_SCRIPT_TYPE_TEACHER_CLOSE_TO_TEACHER = 6,
  CONSULT_SCRIPT_TYPE_STUDENT_OVERTIME_CLOSE_TO_TEACHER = 7,
  CONSULT_SCRIPT_TYPE_STUDENT_OVERTIME_CLOSE_TO_APP = 8,
  CONSULT_SCRIPT_TYPE_TEACHER_OVERTIME_CLOSE_TO_TEACHER = 9,
  CONSULT_SCRIPT_TYPE_TEACHER_OVERTIME_CLOSE_TO_APP = 10,
  CONSULT_SCRIPT_TYPE_DUTY_DELIVER_CLOSE_TO_DUTY = 11,
  CONSULT_SCRIPT_TYPE_DUTY_DELIVER_ONLINE_MANAGER_TO_APP = 12,
  CONSULT_SCRIPT_TYPE_DUTY_DELIVER_OFFLINE_MANAGER_TO_APP = 13,
  CONSULT_SCRIPT_TYPE_TEACHER_TO_APP = 14,
  CONSULT_SCRIPT_TYPE_ABNORMAL_CLOSE_TO_APP = 15,
  CONSULT_SCRIPT_TYPE_DUTY_OFFLINE_CONNECTED_TO_APP = 16
};
bool ConsultScriptType_IsValid(int value);
const ConsultScriptType ConsultScriptType_MIN = CONSULT_SCRIPT_TYPE_DUTY_CONNECTED_TO_APP;
const ConsultScriptType ConsultScriptType_MAX = CONSULT_SCRIPT_TYPE_DUTY_OFFLINE_CONNECTED_TO_APP;
const int ConsultScriptType_ARRAYSIZE = ConsultScriptType_MAX + 1;

enum ComplaintRefundScriptType {
  COMPLAINT_REFUND_SCRIPT_TYPE_TEACHER_ONLINE_CONNECTED_TO_APP = 1,
  COMPLAINT_REFUND_SCRIPT_TYPE_TEACHER_OFFLINE_CONNECTED_TO_APP = 2,
  COMPLAINT_REFUND_SCRIPT_TYPE_STUDENT_CLOSE_TO_TEACHER = 3,
  COMPLAINT_REFUND_SCRIPT_TYPE_TEACHER_CLOSE_TO_TEACHER = 4,
  COMPLAINT_REFUND_SCRIPT_TYPE_STUDENT_OVERTIME_CLOSE_TO_TEACHER = 5,
  COMPLAINT_REFUND_SCRIPT_TYPE_STUDENT_OVERTIME_CLOSE_TO_APP = 6,
  COMPLAINT_REFUND_SCRIPT_TYPE_TEACHER_OVERTIME_CLOSE_TO_TEACHER = 7,
  COMPLAINT_REFUND_SCRIPT_TYPE_TEACHER_TO_APP = 8,
  COMPLAINT_REFUND_SCRIPT_TYPE_ABNORMAL_CLOSE_TO_APP = 9
};
bool ComplaintRefundScriptType_IsValid(int value);
const ComplaintRefundScriptType ComplaintRefundScriptType_MIN = COMPLAINT_REFUND_SCRIPT_TYPE_TEACHER_ONLINE_CONNECTED_TO_APP;
const ComplaintRefundScriptType ComplaintRefundScriptType_MAX = COMPLAINT_REFUND_SCRIPT_TYPE_ABNORMAL_CLOSE_TO_APP;
const int ComplaintRefundScriptType_ARRAYSIZE = ComplaintRefundScriptType_MAX + 1;

enum TransferFileType {
  FILE_TYPE_ONLINE = 1,
  FILE_TYPE_OFFLINE = 2
};
bool TransferFileType_IsValid(int value);
const TransferFileType TransferFileType_MIN = FILE_TYPE_ONLINE;
const TransferFileType TransferFileType_MAX = FILE_TYPE_OFFLINE;
const int TransferFileType_ARRAYSIZE = TransferFileType_MAX + 1;

enum ClientFileState {
  CLIENT_FILE_PEER_READY = 0,
  CLIENT_FILE_CANCEL = 1,
  CLIENT_FILE_REFUSE = 2,
  CLIENT_FILE_DONE = 3
};
bool ClientFileState_IsValid(int value);
const ClientFileState ClientFileState_MIN = CLIENT_FILE_PEER_READY;
const ClientFileState ClientFileState_MAX = CLIENT_FILE_DONE;
const int ClientFileState_ARRAYSIZE = ClientFileState_MAX + 1;

enum ClientFileRole {
  CLIENT_REALTIME_SENDER = 1,
  CLIENT_REALTIME_RECVER = 2,
  CLIENT_OFFLINE_UPLOAD = 3,
  CLIENT_OFFLINE_DOWNLOAD = 4
};
bool ClientFileRole_IsValid(int value);
const ClientFileRole ClientFileRole_MIN = CLIENT_REALTIME_SENDER;
const ClientFileRole ClientFileRole_MAX = CLIENT_OFFLINE_DOWNLOAD;
const int ClientFileRole_ARRAYSIZE = ClientFileRole_MAX + 1;

enum FileServerError {
  FILE_SERVER_ERRNO_OK = 0,
  FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR = 1,
  FILE_SERVER_ERRNO_CREATE_TASK_ERROR = 2,
  FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN = 3,
  FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK = 4,
  FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID = 5,
  FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER = 6,
  FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR = 7,
  FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR = 8,
  FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR = 9,
  FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR = 10,
  FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR = 11,
  FILE_SERVER_ERRNO_PULL_DATA_FINISHED = 12
};
bool FileServerError_IsValid(int value);
const FileServerError FileServerError_MIN = FILE_SERVER_ERRNO_OK;
const FileServerError FileServerError_MAX = FILE_SERVER_ERRNO_PULL_DATA_FINISHED;
const int FileServerError_ARRAYSIZE = FileServerError_MAX + 1;

enum SenderType {
  SENDER_USER = 1,
  SENDER_USER_VIP = 2,
  SENDER_TEACHER = 3
};
bool SenderType_IsValid(int value);
const SenderType SenderType_MIN = SENDER_USER;
const SenderType SenderType_MAX = SENDER_TEACHER;
const int SenderType_ARRAYSIZE = SenderType_MAX + 1;

enum SessionStatusType {
  SESSION_STATUS_OK = 0,
  SESSION_STATUS_DELETE = 1
};
bool SessionStatusType_IsValid(int value);
const SessionStatusType SessionStatusType_MIN = SESSION_STATUS_OK;
const SessionStatusType SessionStatusType_MAX = SESSION_STATUS_DELETE;
const int SessionStatusType_ARRAYSIZE = SessionStatusType_MAX + 1;

enum DepartmentStatusType {
  DEPT_STATUS_OK = 0,
  DEPT_STATUS_DELETE = 1
};
bool DepartmentStatusType_IsValid(int value);
const DepartmentStatusType DepartmentStatusType_MIN = DEPT_STATUS_OK;
const DepartmentStatusType DepartmentStatusType_MAX = DEPT_STATUS_DELETE;
const int DepartmentStatusType_ARRAYSIZE = DepartmentStatusType_MAX + 1;

enum ReviewFriendRequestAction {
  REVIEW_ACCEPT = 0,
  REVIEW_REFUSE = 1
};
bool ReviewFriendRequestAction_IsValid(int value);
const ReviewFriendRequestAction ReviewFriendRequestAction_MIN = REVIEW_ACCEPT;
const ReviewFriendRequestAction ReviewFriendRequestAction_MAX = REVIEW_REFUSE;
const int ReviewFriendRequestAction_ARRAYSIZE = ReviewFriendRequestAction_MAX + 1;

enum ShieldFriendAction {
  SHIELD_FRIEND = 0,
  NOT_SHIELD = 1
};
bool ShieldFriendAction_IsValid(int value);
const ShieldFriendAction ShieldFriendAction_MIN = SHIELD_FRIEND;
const ShieldFriendAction ShieldFriendAction_MAX = NOT_SHIELD;
const int ShieldFriendAction_ARRAYSIZE = ShieldFriendAction_MAX + 1;

enum MQTopicType {
  TEACHER_ONLINE_OR_OFFLINE = 1
};
bool MQTopicType_IsValid(int value);
const MQTopicType MQTopicType_MIN = TEACHER_ONLINE_OR_OFFLINE;
const MQTopicType MQTopicType_MAX = TEACHER_ONLINE_OR_OFFLINE;
const int MQTopicType_ARRAYSIZE = MQTopicType_MAX + 1;

enum LiveMsgProcessType {
  SEND_TO_SINGLE = 1,
  SEND_TO_GROUP = 2
};
bool LiveMsgProcessType_IsValid(int value);
const LiveMsgProcessType LiveMsgProcessType_MIN = SEND_TO_SINGLE;
const LiveMsgProcessType LiveMsgProcessType_MAX = SEND_TO_GROUP;
const int LiveMsgProcessType_ARRAYSIZE = LiveMsgProcessType_MAX + 1;

enum LiveForbidenStatus {
  NOT_FORBIDDEN = 0,
  FORBIDDEN = 1
};
bool LiveForbidenStatus_IsValid(int value);
const LiveForbidenStatus LiveForbidenStatus_MIN = NOT_FORBIDDEN;
const LiveForbidenStatus LiveForbidenStatus_MAX = FORBIDDEN;
const int LiveForbidenStatus_ARRAYSIZE = LiveForbidenStatus_MAX + 1;

enum LiveUserLoginStatus {
  LOGIN_CHAT_ROOM = 1,
  LOGOUT_CHAT_ROOM = 2
};
bool LiveUserLoginStatus_IsValid(int value);
const LiveUserLoginStatus LiveUserLoginStatus_MIN = LOGIN_CHAT_ROOM;
const LiveUserLoginStatus LiveUserLoginStatus_MAX = LOGOUT_CHAT_ROOM;
const int LiveUserLoginStatus_ARRAYSIZE = LiveUserLoginStatus_MAX + 1;

enum LiveRespType {
  LIVE_RESP_OK = 0,
  LIVE_RESP_DB_ERROR = 1,
  LIVE_RESP_INPUT_PARAMETER_ERR = 2,
  LIVE_RESP_ROOM_INVALID = 3,
  LIVE_RESP_REPEAT_LOGIN = 4,
  LIVE_RESP_ROOM_NO_MEMBER = 5,
  LIVE_RESP_ROOM_FORBIDDEN = 6,
  LIVE_RESP_MESSAGE_SENSITIVE = 7,
  LIVE_RESP_USER_INVALID = 8,
  LIVE_RESP_USER_NO_PRIVILEGE = 9,
  LIVE_RESP_ROOM_FULL = 10
};
bool LiveRespType_IsValid(int value);
const LiveRespType LiveRespType_MIN = LIVE_RESP_OK;
const LiveRespType LiveRespType_MAX = LIVE_RESP_ROOM_FULL;
const int LiveRespType_ARRAYSIZE = LiveRespType_MAX + 1;

enum LiveWebCmd {
  LIVE_HEARTBEAT = 1,
  LIVE_LOGIN_CHAT_ROOM = 2,
  LIVE_LOGOUT_CHAT_ROOM = 3,
  LIVE_SEND_MSG_TO_CHAT_ROOM = 4,
  LIVE_NOTIFY_NEW_MSG = 5,
  LIVE_SET_ROOM_FORBIDDEN_STATUS = 6,
  LIVE_GET_ROOM_FORBIDDEN_STATUS = 7,
  LIVE_NOTIFY_ROOM_FORBIDDEN_STATUS = 8,
  LIVE_KICK_ROOM_MEMBER = 9,
  LIVE_NOTIFY_MEMBER_LOGIN_STATUS = 10,
  LIVE_NOTIFY_ROOM_CLOSE = 11
};
bool LiveWebCmd_IsValid(int value);
const LiveWebCmd LiveWebCmd_MIN = LIVE_HEARTBEAT;
const LiveWebCmd LiveWebCmd_MAX = LIVE_NOTIFY_ROOM_CLOSE;
const int LiveWebCmd_ARRAYSIZE = LiveWebCmd_MAX + 1;

enum RpcRespType {
  RPC_RESP_OK = 0,
  RPC_RESP_ERROR = 1,
  RPC_RESP_INPUT_PARAMETER_ERR = 2,
  RPC_RESP_GROUP_MEMBER_INVALID = 3,
  RPC_RESP_GROUP_INVALID = 4,
  RPC_RESP_GROUP_NO_MSG = 5,
  RPC_RESP_REPEATEDLY_DELETE_MSG = 6
};
bool RpcRespType_IsValid(int value);
const RpcRespType RpcRespType_MIN = RPC_RESP_OK;
const RpcRespType RpcRespType_MAX = RPC_RESP_REPEATEDLY_DELETE_MSG;
const int RpcRespType_ARRAYSIZE = RpcRespType_MAX + 1;

// ===================================================================

class IpAddr : public ::google::protobuf::MessageLite {
 public:
  IpAddr();
  virtual ~IpAddr();

  IpAddr(const IpAddr& from);

  inline IpAddr& operator=(const IpAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IpAddr& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IpAddr* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IpAddr* other);

  // implements Message ----------------------------------------------

  IpAddr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IpAddr& from);
  void MergeFrom(const IpAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.IpAddr)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static IpAddr* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::MessageLite {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 user_gender = 2;
  inline bool has_user_gender() const;
  inline void clear_user_gender();
  static const int kUserGenderFieldNumber = 2;
  inline ::google::protobuf::uint32 user_gender() const;
  inline void set_user_gender(::google::protobuf::uint32 value);

  // required string user_nick_name = 3;
  inline bool has_user_nick_name() const;
  inline void clear_user_nick_name();
  static const int kUserNickNameFieldNumber = 3;
  inline const ::std::string& user_nick_name() const;
  inline void set_user_nick_name(const ::std::string& value);
  inline void set_user_nick_name(const char* value);
  inline void set_user_nick_name(const char* value, size_t size);
  inline ::std::string* mutable_user_nick_name();
  inline ::std::string* release_user_nick_name();
  inline void set_allocated_user_nick_name(::std::string* user_nick_name);

  // required string avatar_url = 4;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 4;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // required uint32 department_id = 5;
  inline bool has_department_id() const;
  inline void clear_department_id();
  static const int kDepartmentIdFieldNumber = 5;
  inline ::google::protobuf::uint32 department_id() const;
  inline void set_department_id(::google::protobuf::uint32 value);

  // required string email = 6;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 6;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required string user_real_name = 7;
  inline bool has_user_real_name() const;
  inline void clear_user_real_name();
  static const int kUserRealNameFieldNumber = 7;
  inline const ::std::string& user_real_name() const;
  inline void set_user_real_name(const ::std::string& value);
  inline void set_user_real_name(const char* value);
  inline void set_user_real_name(const char* value, size_t size);
  inline ::std::string* mutable_user_real_name();
  inline ::std::string* release_user_real_name();
  inline void set_allocated_user_real_name(::std::string* user_real_name);

  // required string user_tel = 8;
  inline bool has_user_tel() const;
  inline void clear_user_tel();
  static const int kUserTelFieldNumber = 8;
  inline const ::std::string& user_tel() const;
  inline void set_user_tel(const ::std::string& value);
  inline void set_user_tel(const char* value);
  inline void set_user_tel(const char* value, size_t size);
  inline ::std::string* mutable_user_tel();
  inline ::std::string* release_user_tel();
  inline void set_allocated_user_tel(::std::string* user_tel);

  // required string user_domain = 9;
  inline bool has_user_domain() const;
  inline void clear_user_domain();
  static const int kUserDomainFieldNumber = 9;
  inline const ::std::string& user_domain() const;
  inline void set_user_domain(const ::std::string& value);
  inline void set_user_domain(const char* value);
  inline void set_user_domain(const char* value, size_t size);
  inline ::std::string* mutable_user_domain();
  inline ::std::string* release_user_domain();
  inline void set_allocated_user_domain(::std::string* user_domain);

  // required uint32 status = 10;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 10;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional string sign_info = 11;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 11;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_gender();
  inline void clear_has_user_gender();
  inline void set_has_user_nick_name();
  inline void clear_has_user_nick_name();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();
  inline void set_has_department_id();
  inline void clear_has_department_id();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_user_real_name();
  inline void clear_has_user_real_name();
  inline void set_has_user_tel();
  inline void clear_has_user_tel();
  inline void set_has_user_domain();
  inline void clear_has_user_domain();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 user_gender_;
  ::std::string* user_nick_name_;
  ::std::string* avatar_url_;
  ::std::string* email_;
  ::std::string* user_real_name_;
  ::google::protobuf::uint32 department_id_;
  ::google::protobuf::uint32 status_;
  ::std::string* user_tel_;
  ::std::string* user_domain_;
  ::std::string* sign_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContactSessionInfo : public ::google::protobuf::MessageLite {
 public:
  ContactSessionInfo();
  virtual ~ContactSessionInfo();

  ContactSessionInfo(const ContactSessionInfo& from);

  inline ContactSessionInfo& operator=(const ContactSessionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ContactSessionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ContactSessionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ContactSessionInfo* other);

  // implements Message ----------------------------------------------

  ContactSessionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ContactSessionInfo& from);
  void MergeFrom(const ContactSessionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required .IM.BaseDefine.SessionStatusType session_status = 3;
  inline bool has_session_status() const;
  inline void clear_session_status();
  static const int kSessionStatusFieldNumber = 3;
  inline ::IM::BaseDefine::SessionStatusType session_status() const;
  inline void set_session_status(::IM::BaseDefine::SessionStatusType value);

  // required uint32 updated_time = 4;
  inline bool has_updated_time() const;
  inline void clear_updated_time();
  static const int kUpdatedTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 updated_time() const;
  inline void set_updated_time(::google::protobuf::uint32 value);

  // required uint32 latest_msg_id = 5;
  inline bool has_latest_msg_id() const;
  inline void clear_latest_msg_id();
  static const int kLatestMsgIdFieldNumber = 5;
  inline ::google::protobuf::uint32 latest_msg_id() const;
  inline void set_latest_msg_id(::google::protobuf::uint32 value);

  // required bytes latest_msg_data = 6;
  inline bool has_latest_msg_data() const;
  inline void clear_latest_msg_data();
  static const int kLatestMsgDataFieldNumber = 6;
  inline const ::std::string& latest_msg_data() const;
  inline void set_latest_msg_data(const ::std::string& value);
  inline void set_latest_msg_data(const char* value);
  inline void set_latest_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_latest_msg_data();
  inline ::std::string* release_latest_msg_data();
  inline void set_allocated_latest_msg_data(::std::string* latest_msg_data);

  // required .IM.BaseDefine.MsgType latest_msg_type = 7;
  inline bool has_latest_msg_type() const;
  inline void clear_latest_msg_type();
  static const int kLatestMsgTypeFieldNumber = 7;
  inline ::IM::BaseDefine::MsgType latest_msg_type() const;
  inline void set_latest_msg_type(::IM::BaseDefine::MsgType value);

  // required uint32 latest_msg_from_user_id = 8;
  inline bool has_latest_msg_from_user_id() const;
  inline void clear_latest_msg_from_user_id();
  static const int kLatestMsgFromUserIdFieldNumber = 8;
  inline ::google::protobuf::uint32 latest_msg_from_user_id() const;
  inline void set_latest_msg_from_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ContactSessionInfo)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_status();
  inline void clear_has_session_status();
  inline void set_has_updated_time();
  inline void clear_has_updated_time();
  inline void set_has_latest_msg_id();
  inline void clear_has_latest_msg_id();
  inline void set_has_latest_msg_data();
  inline void clear_has_latest_msg_data();
  inline void set_has_latest_msg_type();
  inline void clear_has_latest_msg_type();
  inline void set_has_latest_msg_from_user_id();
  inline void clear_has_latest_msg_from_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_id_;
  int session_type_;
  int session_status_;
  ::google::protobuf::uint32 updated_time_;
  ::std::string* latest_msg_data_;
  ::google::protobuf::uint32 latest_msg_id_;
  int latest_msg_type_;
  ::google::protobuf::uint32 latest_msg_from_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ContactSessionInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserStat : public ::google::protobuf::MessageLite {
 public:
  UserStat();
  virtual ~UserStat();

  UserStat(const UserStat& from);

  inline UserStat& operator=(const UserStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserStat* other);

  // implements Message ----------------------------------------------

  UserStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserStat& from);
  void MergeFrom(const UserStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserStat)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserStat* default_instance_;
};
// -------------------------------------------------------------------

class ServerUserStat : public ::google::protobuf::MessageLite {
 public:
  ServerUserStat();
  virtual ~ServerUserStat();

  ServerUserStat(const ServerUserStat& from);

  inline ServerUserStat& operator=(const ServerUserStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerUserStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerUserStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerUserStat* other);

  // implements Message ----------------------------------------------

  ServerUserStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerUserStat& from);
  void MergeFrom(const ServerUserStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.ClientType client_type = 3;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 3;
  inline ::IM::BaseDefine::ClientType client_type() const;
  inline void set_client_type(::IM::BaseDefine::ClientType value);

  // required uint32 identity = 4;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 4;
  inline ::google::protobuf::uint32 identity() const;
  inline void set_identity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ServerUserStat)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_client_type();
  inline void clear_has_client_type();
  inline void set_has_identity();
  inline void clear_has_identity();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 status_;
  int client_type_;
  ::google::protobuf::uint32 identity_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ServerUserStat* default_instance_;
};
// -------------------------------------------------------------------

class UnreadInfo : public ::google::protobuf::MessageLite {
 public:
  UnreadInfo();
  virtual ~UnreadInfo();

  UnreadInfo(const UnreadInfo& from);

  inline UnreadInfo& operator=(const UnreadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UnreadInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnreadInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnreadInfo* other);

  // implements Message ----------------------------------------------

  UnreadInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnreadInfo& from);
  void MergeFrom(const UnreadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 unread_cnt = 3;
  inline bool has_unread_cnt() const;
  inline void clear_unread_cnt();
  static const int kUnreadCntFieldNumber = 3;
  inline ::google::protobuf::uint32 unread_cnt() const;
  inline void set_unread_cnt(::google::protobuf::uint32 value);

  // required uint32 latest_msg_id = 4;
  inline bool has_latest_msg_id() const;
  inline void clear_latest_msg_id();
  static const int kLatestMsgIdFieldNumber = 4;
  inline ::google::protobuf::uint32 latest_msg_id() const;
  inline void set_latest_msg_id(::google::protobuf::uint32 value);

  // required bytes latest_msg_data = 5;
  inline bool has_latest_msg_data() const;
  inline void clear_latest_msg_data();
  static const int kLatestMsgDataFieldNumber = 5;
  inline const ::std::string& latest_msg_data() const;
  inline void set_latest_msg_data(const ::std::string& value);
  inline void set_latest_msg_data(const char* value);
  inline void set_latest_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_latest_msg_data();
  inline ::std::string* release_latest_msg_data();
  inline void set_allocated_latest_msg_data(::std::string* latest_msg_data);

  // required .IM.BaseDefine.MsgType latest_msg_type = 6;
  inline bool has_latest_msg_type() const;
  inline void clear_latest_msg_type();
  static const int kLatestMsgTypeFieldNumber = 6;
  inline ::IM::BaseDefine::MsgType latest_msg_type() const;
  inline void set_latest_msg_type(::IM::BaseDefine::MsgType value);

  // required uint32 latest_msg_from_user_id = 7;
  inline bool has_latest_msg_from_user_id() const;
  inline void clear_latest_msg_from_user_id();
  static const int kLatestMsgFromUserIdFieldNumber = 7;
  inline ::google::protobuf::uint32 latest_msg_from_user_id() const;
  inline void set_latest_msg_from_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UnreadInfo)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_unread_cnt();
  inline void clear_has_unread_cnt();
  inline void set_has_latest_msg_id();
  inline void clear_has_latest_msg_id();
  inline void set_has_latest_msg_data();
  inline void clear_has_latest_msg_data();
  inline void set_has_latest_msg_type();
  inline void clear_has_latest_msg_type();
  inline void set_has_latest_msg_from_user_id();
  inline void clear_has_latest_msg_from_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_id_;
  int session_type_;
  ::google::protobuf::uint32 unread_cnt_;
  ::google::protobuf::uint32 latest_msg_id_;
  ::std::string* latest_msg_data_;
  int latest_msg_type_;
  ::google::protobuf::uint32 latest_msg_from_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UnreadInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgInfo : public ::google::protobuf::MessageLite {
 public:
  MsgInfo();
  virtual ~MsgInfo();

  MsgInfo(const MsgInfo& from);

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgInfo* other);

  // implements Message ----------------------------------------------

  MsgInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgInfo& from);
  void MergeFrom(const MsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required uint32 from_session_id = 2;
  inline bool has_from_session_id() const;
  inline void clear_from_session_id();
  static const int kFromSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_session_id() const;
  inline void set_from_session_id(::google::protobuf::uint32 value);

  // required uint32 create_time = 3;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // required uint32 msg_type = 4;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 msg_type() const;
  inline void set_msg_type(::google::protobuf::uint32 value);

  // required bytes msg_data = 5;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 5;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.MsgInfo)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_from_session_id();
  inline void clear_has_from_session_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 msg_id_;
  ::google::protobuf::uint32 from_session_id_;
  ::google::protobuf::uint32 create_time_;
  ::google::protobuf::uint32 msg_type_;
  ::std::string* msg_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static MsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupVersionInfo : public ::google::protobuf::MessageLite {
 public:
  GroupVersionInfo();
  virtual ~GroupVersionInfo();

  GroupVersionInfo(const GroupVersionInfo& from);

  inline GroupVersionInfo& operator=(const GroupVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupVersionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupVersionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupVersionInfo* other);

  // implements Message ----------------------------------------------

  GroupVersionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupVersionInfo& from);
  void MergeFrom(const GroupVersionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupVersionInfo)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static GroupVersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfo : public ::google::protobuf::MessageLite {
 public:
  GroupInfo();
  virtual ~GroupInfo();

  GroupInfo(const GroupInfo& from);

  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupInfo* other);

  // implements Message ----------------------------------------------

  GroupInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupInfo& from);
  void MergeFrom(const GroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required string group_name = 3;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 3;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required string group_avatar = 4;
  inline bool has_group_avatar() const;
  inline void clear_group_avatar();
  static const int kGroupAvatarFieldNumber = 4;
  inline const ::std::string& group_avatar() const;
  inline void set_group_avatar(const ::std::string& value);
  inline void set_group_avatar(const char* value);
  inline void set_group_avatar(const char* value, size_t size);
  inline ::std::string* mutable_group_avatar();
  inline ::std::string* release_group_avatar();
  inline void set_allocated_group_avatar(::std::string* group_avatar);

  // required uint32 group_creator_id = 5;
  inline bool has_group_creator_id() const;
  inline void clear_group_creator_id();
  static const int kGroupCreatorIdFieldNumber = 5;
  inline ::google::protobuf::uint32 group_creator_id() const;
  inline void set_group_creator_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.GroupType group_type = 6;
  inline bool has_group_type() const;
  inline void clear_group_type();
  static const int kGroupTypeFieldNumber = 6;
  inline ::IM::BaseDefine::GroupType group_type() const;
  inline void set_group_type(::IM::BaseDefine::GroupType value);

  // required uint32 shield_status = 7;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // repeated uint32 group_member_list = 8;
  inline int group_member_list_size() const;
  inline void clear_group_member_list();
  static const int kGroupMemberListFieldNumber = 8;
  inline ::google::protobuf::uint32 group_member_list(int index) const;
  inline void set_group_member_list(int index, ::google::protobuf::uint32 value);
  inline void add_group_member_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      group_member_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_group_member_list();

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupInfo)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_group_avatar();
  inline void clear_has_group_avatar();
  inline void set_has_group_creator_id();
  inline void clear_has_group_creator_id();
  inline void set_has_group_type();
  inline void clear_has_group_type();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 version_;
  ::std::string* group_name_;
  ::std::string* group_avatar_;
  ::google::protobuf::uint32 group_creator_id_;
  int group_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > group_member_list_;
  ::google::protobuf::uint32 shield_status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static GroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgInfo : public ::google::protobuf::MessageLite {
 public:
  GroupMsgInfo();
  virtual ~GroupMsgInfo();

  GroupMsgInfo(const GroupMsgInfo& from);

  inline GroupMsgInfo& operator=(const GroupMsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupMsgInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupMsgInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupMsgInfo* other);

  // implements Message ----------------------------------------------

  GroupMsgInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupMsgInfo& from);
  void MergeFrom(const GroupMsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required string user_im_name = 2;
  inline bool has_user_im_name() const;
  inline void clear_user_im_name();
  static const int kUserImNameFieldNumber = 2;
  inline const ::std::string& user_im_name() const;
  inline void set_user_im_name(const ::std::string& value);
  inline void set_user_im_name(const char* value);
  inline void set_user_im_name(const char* value, size_t size);
  inline ::std::string* mutable_user_im_name();
  inline ::std::string* release_user_im_name();
  inline void set_allocated_user_im_name(::std::string* user_im_name);

  // required uint32 user_im_identity = 3;
  inline bool has_user_im_identity() const;
  inline void clear_user_im_identity();
  static const int kUserImIdentityFieldNumber = 3;
  inline ::google::protobuf::uint32 user_im_identity() const;
  inline void set_user_im_identity(::google::protobuf::uint32 value);

  // required string group_name = 4;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 4;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required uint32 group_id = 5;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 5;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated uint32 member_list = 6;
  inline int member_list_size() const;
  inline void clear_member_list();
  static const int kMemberListFieldNumber = 6;
  inline ::google::protobuf::uint32 member_list(int index) const;
  inline void set_member_list(int index, ::google::protobuf::uint32 value);
  inline void add_member_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      member_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_member_list();

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupMsgInfo)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_user_im_name();
  inline void clear_has_user_im_name();
  inline void set_has_user_im_identity();
  inline void clear_has_user_im_identity();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_im_name_;
  ::google::protobuf::uint32 msg_id_;
  ::google::protobuf::uint32 user_im_identity_;
  ::std::string* group_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > member_list_;
  ::google::protobuf::uint32 group_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserTokenInfo : public ::google::protobuf::MessageLite {
 public:
  UserTokenInfo();
  virtual ~UserTokenInfo();

  UserTokenInfo(const UserTokenInfo& from);

  inline UserTokenInfo& operator=(const UserTokenInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserTokenInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserTokenInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserTokenInfo* other);

  // implements Message ----------------------------------------------

  UserTokenInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserTokenInfo& from);
  void MergeFrom(const UserTokenInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 user_type = 2;
  inline bool has_user_type() const;
  inline void clear_user_type();
  static const int kUserTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 user_type() const;
  inline void set_user_type(::google::protobuf::uint32 value);

  // required string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required uint32 push_count = 4;
  inline bool has_push_count() const;
  inline void clear_push_count();
  static const int kPushCountFieldNumber = 4;
  inline ::google::protobuf::uint32 push_count() const;
  inline void set_push_count(::google::protobuf::uint32 value);

  // required uint32 push_type = 5;
  inline bool has_push_type() const;
  inline void clear_push_type();
  static const int kPushTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 push_type() const;
  inline void set_push_type(::google::protobuf::uint32 value);

  // optional uint32 allow_disturb = 6;
  inline bool has_allow_disturb() const;
  inline void clear_allow_disturb();
  static const int kAllowDisturbFieldNumber = 6;
  inline ::google::protobuf::uint32 allow_disturb() const;
  inline void set_allow_disturb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserTokenInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_type();
  inline void clear_has_user_type();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_push_count();
  inline void clear_has_push_count();
  inline void set_has_push_type();
  inline void clear_has_push_type();
  inline void set_has_allow_disturb();
  inline void clear_has_allow_disturb();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 user_type_;
  ::std::string* token_;
  ::google::protobuf::uint32 push_count_;
  ::google::protobuf::uint32 push_type_;
  ::google::protobuf::uint32 allow_disturb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserTokenInfo* default_instance_;
};
// -------------------------------------------------------------------

class PushResult : public ::google::protobuf::MessageLite {
 public:
  PushResult();
  virtual ~PushResult();

  PushResult(const PushResult& from);

  inline PushResult& operator=(const PushResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushResult* other);

  // implements Message ----------------------------------------------

  PushResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushResult& from);
  void MergeFrom(const PushResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_token = 1;
  inline bool has_user_token() const;
  inline void clear_user_token();
  static const int kUserTokenFieldNumber = 1;
  inline const ::std::string& user_token() const;
  inline void set_user_token(const ::std::string& value);
  inline void set_user_token(const char* value);
  inline void set_user_token(const char* value, size_t size);
  inline ::std::string* mutable_user_token();
  inline ::std::string* release_user_token();
  inline void set_allocated_user_token(::std::string* user_token);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.PushResult)
 private:
  inline void set_has_user_token();
  inline void clear_has_user_token();
  inline void set_has_result_code();
  inline void clear_has_result_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_token_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static PushResult* default_instance_;
};
// -------------------------------------------------------------------

class ShieldStatus : public ::google::protobuf::MessageLite {
 public:
  ShieldStatus();
  virtual ~ShieldStatus();

  ShieldStatus(const ShieldStatus& from);

  inline ShieldStatus& operator=(const ShieldStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ShieldStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShieldStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShieldStatus* other);

  // implements Message ----------------------------------------------

  ShieldStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShieldStatus& from);
  void MergeFrom(const ShieldStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 shield_status = 3;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ShieldStatus)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 shield_status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ShieldStatus* default_instance_;
};
// -------------------------------------------------------------------

class OfflineFileInfo : public ::google::protobuf::MessageLite {
 public:
  OfflineFileInfo();
  virtual ~OfflineFileInfo();

  OfflineFileInfo(const OfflineFileInfo& from);

  inline OfflineFileInfo& operator=(const OfflineFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OfflineFileInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OfflineFileInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OfflineFileInfo* other);

  // implements Message ----------------------------------------------

  OfflineFileInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OfflineFileInfo& from);
  void MergeFrom(const OfflineFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_user_id = 1;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);

  // required string task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  inline void set_allocated_task_id(::std::string* task_id);

  // required string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // required uint32 file_size = 4;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.OfflineFileInfo)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* task_id_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 file_size_;
  ::std::string* file_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static OfflineFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class DepartInfo : public ::google::protobuf::MessageLite {
 public:
  DepartInfo();
  virtual ~DepartInfo();

  DepartInfo(const DepartInfo& from);

  inline DepartInfo& operator=(const DepartInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DepartInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DepartInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DepartInfo* other);

  // implements Message ----------------------------------------------

  DepartInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DepartInfo& from);
  void MergeFrom(const DepartInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 dept_id = 1;
  inline bool has_dept_id() const;
  inline void clear_dept_id();
  static const int kDeptIdFieldNumber = 1;
  inline ::google::protobuf::uint32 dept_id() const;
  inline void set_dept_id(::google::protobuf::uint32 value);

  // required uint32 priority = 2;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 2;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // required string dept_name = 3;
  inline bool has_dept_name() const;
  inline void clear_dept_name();
  static const int kDeptNameFieldNumber = 3;
  inline const ::std::string& dept_name() const;
  inline void set_dept_name(const ::std::string& value);
  inline void set_dept_name(const char* value);
  inline void set_dept_name(const char* value, size_t size);
  inline ::std::string* mutable_dept_name();
  inline ::std::string* release_dept_name();
  inline void set_allocated_dept_name(::std::string* dept_name);

  // required uint32 parent_dept_id = 4;
  inline bool has_parent_dept_id() const;
  inline void clear_parent_dept_id();
  static const int kParentDeptIdFieldNumber = 4;
  inline ::google::protobuf::uint32 parent_dept_id() const;
  inline void set_parent_dept_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
  inline bool has_dept_status() const;
  inline void clear_dept_status();
  static const int kDeptStatusFieldNumber = 5;
  inline ::IM::BaseDefine::DepartmentStatusType dept_status() const;
  inline void set_dept_status(::IM::BaseDefine::DepartmentStatusType value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.DepartInfo)
 private:
  inline void set_has_dept_id();
  inline void clear_has_dept_id();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_dept_name();
  inline void clear_has_dept_name();
  inline void set_has_parent_dept_id();
  inline void clear_has_parent_dept_id();
  inline void set_has_dept_status();
  inline void clear_has_dept_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 dept_id_;
  ::google::protobuf::uint32 priority_;
  ::std::string* dept_name_;
  ::google::protobuf::uint32 parent_dept_id_;
  int dept_status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static DepartInfo* default_instance_;
};
// -------------------------------------------------------------------

class PushShieldStatus : public ::google::protobuf::MessageLite {
 public:
  PushShieldStatus();
  virtual ~PushShieldStatus();

  PushShieldStatus(const PushShieldStatus& from);

  inline PushShieldStatus& operator=(const PushShieldStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushShieldStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushShieldStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushShieldStatus* other);

  // implements Message ----------------------------------------------

  PushShieldStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushShieldStatus& from);
  void MergeFrom(const PushShieldStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 shield_status = 2;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.PushShieldStatus)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 shield_status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static PushShieldStatus* default_instance_;
};
// -------------------------------------------------------------------

class StudentStat : public ::google::protobuf::MessageLite {
 public:
  StudentStat();
  virtual ~StudentStat();

  StudentStat(const StudentStat& from);

  inline StudentStat& operator=(const StudentStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StudentStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StudentStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StudentStat* other);

  // implements Message ----------------------------------------------

  StudentStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StudentStat& from);
  void MergeFrom(const StudentStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 student_id = 1;
  inline bool has_student_id() const;
  inline void clear_student_id();
  static const int kStudentIdFieldNumber = 1;
  inline ::google::protobuf::uint32 student_id() const;
  inline void set_student_id(::google::protobuf::uint32 value);

  // required uint32 online_status = 2;
  inline bool has_online_status() const;
  inline void clear_online_status();
  static const int kOnlineStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 online_status() const;
  inline void set_online_status(::google::protobuf::uint32 value);

  // required uint32 consult_status = 3;
  inline bool has_consult_status() const;
  inline void clear_consult_status();
  static const int kConsultStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 consult_status() const;
  inline void set_consult_status(::google::protobuf::uint32 value);

  // required uint32 teacher_id = 4;
  inline bool has_teacher_id() const;
  inline void clear_teacher_id();
  static const int kTeacherIdFieldNumber = 4;
  inline ::google::protobuf::uint32 teacher_id() const;
  inline void set_teacher_id(::google::protobuf::uint32 value);

  // required uint32 order_id = 5;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 5;
  inline ::google::protobuf::uint32 order_id() const;
  inline void set_order_id(::google::protobuf::uint32 value);

  // required uint32 consult_id = 6;
  inline bool has_consult_id() const;
  inline void clear_consult_id();
  static const int kConsultIdFieldNumber = 6;
  inline ::google::protobuf::uint32 consult_id() const;
  inline void set_consult_id(::google::protobuf::uint32 value);

  // optional uint32 service = 7;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 7;
  inline ::google::protobuf::uint32 service() const;
  inline void set_service(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.StudentStat)
 private:
  inline void set_has_student_id();
  inline void clear_has_student_id();
  inline void set_has_online_status();
  inline void clear_has_online_status();
  inline void set_has_consult_status();
  inline void clear_has_consult_status();
  inline void set_has_teacher_id();
  inline void clear_has_teacher_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_consult_id();
  inline void clear_has_consult_id();
  inline void set_has_service();
  inline void clear_has_service();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 student_id_;
  ::google::protobuf::uint32 online_status_;
  ::google::protobuf::uint32 consult_status_;
  ::google::protobuf::uint32 teacher_id_;
  ::google::protobuf::uint32 order_id_;
  ::google::protobuf::uint32 consult_id_;
  ::google::protobuf::uint32 service_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static StudentStat* default_instance_;
};
// -------------------------------------------------------------------

class ManagerStat : public ::google::protobuf::MessageLite {
 public:
  ManagerStat();
  virtual ~ManagerStat();

  ManagerStat(const ManagerStat& from);

  inline ManagerStat& operator=(const ManagerStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ManagerStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ManagerStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ManagerStat* other);

  // implements Message ----------------------------------------------

  ManagerStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ManagerStat& from);
  void MergeFrom(const ManagerStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 manager_id = 1;
  inline bool has_manager_id() const;
  inline void clear_manager_id();
  static const int kManagerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 manager_id() const;
  inline void set_manager_id(::google::protobuf::uint32 value);

  // required uint32 online_status = 2;
  inline bool has_online_status() const;
  inline void clear_online_status();
  static const int kOnlineStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 online_status() const;
  inline void set_online_status(::google::protobuf::uint32 value);

  // required uint32 consult_cnt = 3;
  inline bool has_consult_cnt() const;
  inline void clear_consult_cnt();
  static const int kConsultCntFieldNumber = 3;
  inline ::google::protobuf::uint32 consult_cnt() const;
  inline void set_consult_cnt(::google::protobuf::uint32 value);

  // required uint32 queue_cnt = 4;
  inline bool has_queue_cnt() const;
  inline void clear_queue_cnt();
  static const int kQueueCntFieldNumber = 4;
  inline ::google::protobuf::uint32 queue_cnt() const;
  inline void set_queue_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ManagerStat)
 private:
  inline void set_has_manager_id();
  inline void clear_has_manager_id();
  inline void set_has_online_status();
  inline void clear_has_online_status();
  inline void set_has_consult_cnt();
  inline void clear_has_consult_cnt();
  inline void set_has_queue_cnt();
  inline void clear_has_queue_cnt();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 manager_id_;
  ::google::protobuf::uint32 online_status_;
  ::google::protobuf::uint32 consult_cnt_;
  ::google::protobuf::uint32 queue_cnt_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ManagerStat* default_instance_;
};
// -------------------------------------------------------------------

class DutyStat : public ::google::protobuf::MessageLite {
 public:
  DutyStat();
  virtual ~DutyStat();

  DutyStat(const DutyStat& from);

  inline DutyStat& operator=(const DutyStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DutyStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DutyStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DutyStat* other);

  // implements Message ----------------------------------------------

  DutyStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DutyStat& from);
  void MergeFrom(const DutyStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 duty_id = 1;
  inline bool has_duty_id() const;
  inline void clear_duty_id();
  static const int kDutyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 duty_id() const;
  inline void set_duty_id(::google::protobuf::uint32 value);

  // required uint32 online_status = 2;
  inline bool has_online_status() const;
  inline void clear_online_status();
  static const int kOnlineStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 online_status() const;
  inline void set_online_status(::google::protobuf::uint32 value);

  // required uint32 consult_cnt = 3;
  inline bool has_consult_cnt() const;
  inline void clear_consult_cnt();
  static const int kConsultCntFieldNumber = 3;
  inline ::google::protobuf::uint32 consult_cnt() const;
  inline void set_consult_cnt(::google::protobuf::uint32 value);

  // required uint32 queue_cnt = 4;
  inline bool has_queue_cnt() const;
  inline void clear_queue_cnt();
  static const int kQueueCntFieldNumber = 4;
  inline ::google::protobuf::uint32 queue_cnt() const;
  inline void set_queue_cnt(::google::protobuf::uint32 value);

  // required uint32 consult_history = 5;
  inline bool has_consult_history() const;
  inline void clear_consult_history();
  static const int kConsultHistoryFieldNumber = 5;
  inline ::google::protobuf::uint32 consult_history() const;
  inline void set_consult_history(::google::protobuf::uint32 value);

  // required uint32 last_msg_time = 6;
  inline bool has_last_msg_time() const;
  inline void clear_last_msg_time();
  static const int kLastMsgTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 last_msg_time() const;
  inline void set_last_msg_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.DutyStat)
 private:
  inline void set_has_duty_id();
  inline void clear_has_duty_id();
  inline void set_has_online_status();
  inline void clear_has_online_status();
  inline void set_has_consult_cnt();
  inline void clear_has_consult_cnt();
  inline void set_has_queue_cnt();
  inline void clear_has_queue_cnt();
  inline void set_has_consult_history();
  inline void clear_has_consult_history();
  inline void set_has_last_msg_time();
  inline void clear_has_last_msg_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 duty_id_;
  ::google::protobuf::uint32 online_status_;
  ::google::protobuf::uint32 consult_cnt_;
  ::google::protobuf::uint32 queue_cnt_;
  ::google::protobuf::uint32 consult_history_;
  ::google::protobuf::uint32 last_msg_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static DutyStat* default_instance_;
};
// -------------------------------------------------------------------

class ComplaintRefundTeacherStat : public ::google::protobuf::MessageLite {
 public:
  ComplaintRefundTeacherStat();
  virtual ~ComplaintRefundTeacherStat();

  ComplaintRefundTeacherStat(const ComplaintRefundTeacherStat& from);

  inline ComplaintRefundTeacherStat& operator=(const ComplaintRefundTeacherStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ComplaintRefundTeacherStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ComplaintRefundTeacherStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ComplaintRefundTeacherStat* other);

  // implements Message ----------------------------------------------

  ComplaintRefundTeacherStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ComplaintRefundTeacherStat& from);
  void MergeFrom(const ComplaintRefundTeacherStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 teacher_id = 1;
  inline bool has_teacher_id() const;
  inline void clear_teacher_id();
  static const int kTeacherIdFieldNumber = 1;
  inline ::google::protobuf::uint32 teacher_id() const;
  inline void set_teacher_id(::google::protobuf::uint32 value);

  // required uint32 online_status = 2;
  inline bool has_online_status() const;
  inline void clear_online_status();
  static const int kOnlineStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 online_status() const;
  inline void set_online_status(::google::protobuf::uint32 value);

  // required uint32 consult_cnt = 3;
  inline bool has_consult_cnt() const;
  inline void clear_consult_cnt();
  static const int kConsultCntFieldNumber = 3;
  inline ::google::protobuf::uint32 consult_cnt() const;
  inline void set_consult_cnt(::google::protobuf::uint32 value);

  // required uint32 queue_cnt = 4;
  inline bool has_queue_cnt() const;
  inline void clear_queue_cnt();
  static const int kQueueCntFieldNumber = 4;
  inline ::google::protobuf::uint32 queue_cnt() const;
  inline void set_queue_cnt(::google::protobuf::uint32 value);

  // required uint32 consult_history = 5;
  inline bool has_consult_history() const;
  inline void clear_consult_history();
  static const int kConsultHistoryFieldNumber = 5;
  inline ::google::protobuf::uint32 consult_history() const;
  inline void set_consult_history(::google::protobuf::uint32 value);

  // required uint32 last_msg_time = 6;
  inline bool has_last_msg_time() const;
  inline void clear_last_msg_time();
  static const int kLastMsgTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 last_msg_time() const;
  inline void set_last_msg_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ComplaintRefundTeacherStat)
 private:
  inline void set_has_teacher_id();
  inline void clear_has_teacher_id();
  inline void set_has_online_status();
  inline void clear_has_online_status();
  inline void set_has_consult_cnt();
  inline void clear_has_consult_cnt();
  inline void set_has_queue_cnt();
  inline void clear_has_queue_cnt();
  inline void set_has_consult_history();
  inline void clear_has_consult_history();
  inline void set_has_last_msg_time();
  inline void clear_has_last_msg_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 teacher_id_;
  ::google::protobuf::uint32 online_status_;
  ::google::protobuf::uint32 consult_cnt_;
  ::google::protobuf::uint32 queue_cnt_;
  ::google::protobuf::uint32 consult_history_;
  ::google::protobuf::uint32 last_msg_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ComplaintRefundTeacherStat* default_instance_;
};
// -------------------------------------------------------------------

class TeacherStat : public ::google::protobuf::MessageLite {
 public:
  TeacherStat();
  virtual ~TeacherStat();

  TeacherStat(const TeacherStat& from);

  inline TeacherStat& operator=(const TeacherStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TeacherStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TeacherStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TeacherStat* other);

  // implements Message ----------------------------------------------

  TeacherStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TeacherStat& from);
  void MergeFrom(const TeacherStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 teacher_id = 1;
  inline bool has_teacher_id() const;
  inline void clear_teacher_id();
  static const int kTeacherIdFieldNumber = 1;
  inline ::google::protobuf::uint32 teacher_id() const;
  inline void set_teacher_id(::google::protobuf::uint32 value);

  // required uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.TeacherStat)
 private:
  inline void set_has_teacher_id();
  inline void clear_has_teacher_id();
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 teacher_id_;
  ::google::protobuf::uint32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static TeacherStat* default_instance_;
};
// -------------------------------------------------------------------

class ConsultMsg : public ::google::protobuf::MessageLite {
 public:
  ConsultMsg();
  virtual ~ConsultMsg();

  ConsultMsg(const ConsultMsg& from);

  inline ConsultMsg& operator=(const ConsultMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConsultMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConsultMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConsultMsg* other);

  // implements Message ----------------------------------------------

  ConsultMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConsultMsg& from);
  void MergeFrom(const ConsultMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_id = 1;
  inline bool has_from_id() const;
  inline void clear_from_id();
  static const int kFromIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_id() const;
  inline void set_from_id(::google::protobuf::uint32 value);

  // required uint32 to_id = 2;
  inline bool has_to_id() const;
  inline void clear_to_id();
  static const int kToIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_id() const;
  inline void set_to_id(::google::protobuf::uint32 value);

  // required uint32 msg_id = 3;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required uint32 msg_type = 4;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 msg_type() const;
  inline void set_msg_type(::google::protobuf::uint32 value);

  // required uint32 create_time = 5;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // required uint32 from_identity = 6;
  inline bool has_from_identity() const;
  inline void clear_from_identity();
  static const int kFromIdentityFieldNumber = 6;
  inline ::google::protobuf::uint32 from_identity() const;
  inline void set_from_identity(::google::protobuf::uint32 value);

  // required uint32 to_identity = 7;
  inline bool has_to_identity() const;
  inline void clear_to_identity();
  static const int kToIdentityFieldNumber = 7;
  inline ::google::protobuf::uint32 to_identity() const;
  inline void set_to_identity(::google::protobuf::uint32 value);

  // required bytes msg_data = 8;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 8;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ConsultMsg)
 private:
  inline void set_has_from_id();
  inline void clear_has_from_id();
  inline void set_has_to_id();
  inline void clear_has_to_id();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_from_identity();
  inline void clear_has_from_identity();
  inline void set_has_to_identity();
  inline void clear_has_to_identity();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 from_id_;
  ::google::protobuf::uint32 to_id_;
  ::google::protobuf::uint32 msg_id_;
  ::google::protobuf::uint32 msg_type_;
  ::google::protobuf::uint32 create_time_;
  ::google::protobuf::uint32 from_identity_;
  ::std::string* msg_data_;
  ::google::protobuf::uint32 to_identity_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ConsultMsg* default_instance_;
};
// -------------------------------------------------------------------

class ConsultTimeout : public ::google::protobuf::MessageLite {
 public:
  ConsultTimeout();
  virtual ~ConsultTimeout();

  ConsultTimeout(const ConsultTimeout& from);

  inline ConsultTimeout& operator=(const ConsultTimeout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConsultTimeout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConsultTimeout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConsultTimeout* other);

  // implements Message ----------------------------------------------

  ConsultTimeout* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConsultTimeout& from);
  void MergeFrom(const ConsultTimeout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 consult_id = 1;
  inline bool has_consult_id() const;
  inline void clear_consult_id();
  static const int kConsultIdFieldNumber = 1;
  inline ::google::protobuf::uint32 consult_id() const;
  inline void set_consult_id(::google::protobuf::uint32 value);

  // required uint32 student_id = 2;
  inline bool has_student_id() const;
  inline void clear_student_id();
  static const int kStudentIdFieldNumber = 2;
  inline ::google::protobuf::uint32 student_id() const;
  inline void set_student_id(::google::protobuf::uint32 value);

  // required uint32 teacher_id = 3;
  inline bool has_teacher_id() const;
  inline void clear_teacher_id();
  static const int kTeacherIdFieldNumber = 3;
  inline ::google::protobuf::uint32 teacher_id() const;
  inline void set_teacher_id(::google::protobuf::uint32 value);

  // required uint32 order_id = 4;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 4;
  inline ::google::protobuf::uint32 order_id() const;
  inline void set_order_id(::google::protobuf::uint32 value);

  // required uint32 close_type = 5;
  inline bool has_close_type() const;
  inline void clear_close_type();
  static const int kCloseTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 close_type() const;
  inline void set_close_type(::google::protobuf::uint32 value);

  // optional bytes script = 6;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 6;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const void* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  inline void set_allocated_script(::std::string* script);

  // optional uint32 service = 7;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 7;
  inline ::google::protobuf::uint32 service() const;
  inline void set_service(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ConsultTimeout)
 private:
  inline void set_has_consult_id();
  inline void clear_has_consult_id();
  inline void set_has_student_id();
  inline void clear_has_student_id();
  inline void set_has_teacher_id();
  inline void clear_has_teacher_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_close_type();
  inline void clear_has_close_type();
  inline void set_has_script();
  inline void clear_has_script();
  inline void set_has_service();
  inline void clear_has_service();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 consult_id_;
  ::google::protobuf::uint32 student_id_;
  ::google::protobuf::uint32 teacher_id_;
  ::google::protobuf::uint32 order_id_;
  ::std::string* script_;
  ::google::protobuf::uint32 close_type_;
  ::google::protobuf::uint32 service_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ConsultTimeout* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberInfo : public ::google::protobuf::MessageLite {
 public:
  GroupMemberInfo();
  virtual ~GroupMemberInfo();

  GroupMemberInfo(const GroupMemberInfo& from);

  inline GroupMemberInfo& operator=(const GroupMemberInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupMemberInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupMemberInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupMemberInfo* other);

  // implements Message ----------------------------------------------

  GroupMemberInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupMemberInfo& from);
  void MergeFrom(const GroupMemberInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 forbidden = 2;
  inline bool has_forbidden() const;
  inline void clear_forbidden();
  static const int kForbiddenFieldNumber = 2;
  inline ::google::protobuf::uint32 forbidden() const;
  inline void set_forbidden(::google::protobuf::uint32 value);

  // required uint32 member_degree = 3;
  inline bool has_member_degree() const;
  inline void clear_member_degree();
  static const int kMemberDegreeFieldNumber = 3;
  inline ::google::protobuf::uint32 member_degree() const;
  inline void set_member_degree(::google::protobuf::uint32 value);

  // required uint32 member_type = 4;
  inline bool has_member_type() const;
  inline void clear_member_type();
  static const int kMemberTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 member_type() const;
  inline void set_member_type(::google::protobuf::uint32 value);

  // required uint32 message_cnt = 5;
  inline bool has_message_cnt() const;
  inline void clear_message_cnt();
  static const int kMessageCntFieldNumber = 5;
  inline ::google::protobuf::uint32 message_cnt() const;
  inline void set_message_cnt(::google::protobuf::uint32 value);

  // required string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupMemberInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_forbidden();
  inline void clear_has_forbidden();
  inline void set_has_member_degree();
  inline void clear_has_member_degree();
  inline void set_has_member_type();
  inline void clear_has_member_type();
  inline void set_has_message_cnt();
  inline void clear_has_message_cnt();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 forbidden_;
  ::google::protobuf::uint32 member_degree_;
  ::google::protobuf::uint32 member_type_;
  ::std::string* name_;
  ::google::protobuf::uint32 message_cnt_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// IpAddr

// required string ip = 1;
inline bool IpAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpAddr::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& IpAddr::ip() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IpAddr.ip)
  return *ip_;
}
inline void IpAddr::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IpAddr.ip)
}
inline void IpAddr::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IpAddr.ip)
}
inline void IpAddr::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IpAddr.ip)
}
inline ::std::string* IpAddr::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IpAddr.ip)
  return ip_;
}
inline ::std::string* IpAddr::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpAddr::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IpAddr.ip)
}

// required uint32 port = 2;
inline bool IpAddr::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpAddr::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 IpAddr::port() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IpAddr.port)
  return port_;
}
inline void IpAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IpAddr.port)
}

// -------------------------------------------------------------------

// UserInfo

// required uint32 user_id = 1;
inline bool UserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_id)
  return user_id_;
}
inline void UserInfo::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_id)
}

// required uint32 user_gender = 2;
inline bool UserInfo::has_user_gender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_user_gender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_user_gender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_user_gender() {
  user_gender_ = 0u;
  clear_has_user_gender();
}
inline ::google::protobuf::uint32 UserInfo::user_gender() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_gender)
  return user_gender_;
}
inline void UserInfo::set_user_gender(::google::protobuf::uint32 value) {
  set_has_user_gender();
  user_gender_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_gender)
}

// required string user_nick_name = 3;
inline bool UserInfo::has_user_nick_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_user_nick_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_user_nick_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_user_nick_name() {
  if (user_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_->clear();
  }
  clear_has_user_nick_name();
}
inline const ::std::string& UserInfo::user_nick_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_nick_name)
  return *user_nick_name_;
}
inline void UserInfo::set_user_nick_name(const ::std::string& value) {
  set_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_ = new ::std::string;
  }
  user_nick_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_nick_name)
}
inline void UserInfo::set_user_nick_name(const char* value) {
  set_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_ = new ::std::string;
  }
  user_nick_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_nick_name)
}
inline void UserInfo::set_user_nick_name(const char* value, size_t size) {
  set_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_ = new ::std::string;
  }
  user_nick_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_nick_name)
}
inline ::std::string* UserInfo::mutable_user_nick_name() {
  set_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_nick_name)
  return user_nick_name_;
}
inline ::std::string* UserInfo::release_user_nick_name() {
  clear_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_nick_name_;
    user_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_nick_name(::std::string* user_nick_name) {
  if (user_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_nick_name_;
  }
  if (user_nick_name) {
    set_has_user_nick_name();
    user_nick_name_ = user_nick_name;
  } else {
    clear_has_user_nick_name();
    user_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_nick_name)
}

// required string avatar_url = 4;
inline bool UserInfo::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& UserInfo::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.avatar_url)
  return *avatar_url_;
}
inline void UserInfo::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.avatar_url)
}
inline void UserInfo::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.avatar_url)
}
inline void UserInfo::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.avatar_url)
}
inline ::std::string* UserInfo::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.avatar_url)
  return avatar_url_;
}
inline ::std::string* UserInfo::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.avatar_url)
}

// required uint32 department_id = 5;
inline bool UserInfo::has_department_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_department_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_department_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_department_id() {
  department_id_ = 0u;
  clear_has_department_id();
}
inline ::google::protobuf::uint32 UserInfo::department_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.department_id)
  return department_id_;
}
inline void UserInfo::set_department_id(::google::protobuf::uint32 value) {
  set_has_department_id();
  department_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.department_id)
}

// required string email = 6;
inline bool UserInfo::has_email() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_email() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserInfo::email() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.email)
  return *email_;
}
inline void UserInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.email)
}
inline void UserInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.email)
}
inline void UserInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.email)
}
inline ::std::string* UserInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.email)
  return email_;
}
inline ::std::string* UserInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.email)
}

// required string user_real_name = 7;
inline bool UserInfo::has_user_real_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_user_real_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_user_real_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_user_real_name() {
  if (user_real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_->clear();
  }
  clear_has_user_real_name();
}
inline const ::std::string& UserInfo::user_real_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_real_name)
  return *user_real_name_;
}
inline void UserInfo::set_user_real_name(const ::std::string& value) {
  set_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_ = new ::std::string;
  }
  user_real_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_real_name)
}
inline void UserInfo::set_user_real_name(const char* value) {
  set_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_ = new ::std::string;
  }
  user_real_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_real_name)
}
inline void UserInfo::set_user_real_name(const char* value, size_t size) {
  set_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_ = new ::std::string;
  }
  user_real_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_real_name)
}
inline ::std::string* UserInfo::mutable_user_real_name() {
  set_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_real_name)
  return user_real_name_;
}
inline ::std::string* UserInfo::release_user_real_name() {
  clear_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_real_name_;
    user_real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_real_name(::std::string* user_real_name) {
  if (user_real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_real_name_;
  }
  if (user_real_name) {
    set_has_user_real_name();
    user_real_name_ = user_real_name;
  } else {
    clear_has_user_real_name();
    user_real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_real_name)
}

// required string user_tel = 8;
inline bool UserInfo::has_user_tel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_user_tel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_user_tel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_user_tel() {
  if (user_tel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_->clear();
  }
  clear_has_user_tel();
}
inline const ::std::string& UserInfo::user_tel() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_tel)
  return *user_tel_;
}
inline void UserInfo::set_user_tel(const ::std::string& value) {
  set_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_ = new ::std::string;
  }
  user_tel_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_tel)
}
inline void UserInfo::set_user_tel(const char* value) {
  set_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_ = new ::std::string;
  }
  user_tel_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_tel)
}
inline void UserInfo::set_user_tel(const char* value, size_t size) {
  set_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_ = new ::std::string;
  }
  user_tel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_tel)
}
inline ::std::string* UserInfo::mutable_user_tel() {
  set_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_tel)
  return user_tel_;
}
inline ::std::string* UserInfo::release_user_tel() {
  clear_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_tel_;
    user_tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_tel(::std::string* user_tel) {
  if (user_tel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_tel_;
  }
  if (user_tel) {
    set_has_user_tel();
    user_tel_ = user_tel;
  } else {
    clear_has_user_tel();
    user_tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_tel)
}

// required string user_domain = 9;
inline bool UserInfo::has_user_domain() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_user_domain() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_user_domain() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_user_domain() {
  if (user_domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_domain_->clear();
  }
  clear_has_user_domain();
}
inline const ::std::string& UserInfo::user_domain() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_domain)
  return *user_domain_;
}
inline void UserInfo::set_user_domain(const ::std::string& value) {
  set_has_user_domain();
  if (user_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_domain_ = new ::std::string;
  }
  user_domain_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_domain)
}
inline void UserInfo::set_user_domain(const char* value) {
  set_has_user_domain();
  if (user_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_domain_ = new ::std::string;
  }
  user_domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_domain)
}
inline void UserInfo::set_user_domain(const char* value, size_t size) {
  set_has_user_domain();
  if (user_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_domain_ = new ::std::string;
  }
  user_domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_domain)
}
inline ::std::string* UserInfo::mutable_user_domain() {
  set_has_user_domain();
  if (user_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_domain)
  return user_domain_;
}
inline ::std::string* UserInfo::release_user_domain() {
  clear_has_user_domain();
  if (user_domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_domain_;
    user_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_domain(::std::string* user_domain) {
  if (user_domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_domain_;
  }
  if (user_domain) {
    set_has_user_domain();
    user_domain_ = user_domain;
  } else {
    clear_has_user_domain();
    user_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_domain)
}

// required uint32 status = 10;
inline bool UserInfo::has_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 UserInfo::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.status)
  return status_;
}
inline void UserInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.status)
}

// optional string sign_info = 11;
inline bool UserInfo::has_sign_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfo::set_has_sign_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfo::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfo::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& UserInfo::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.sign_info)
  return *sign_info_;
}
inline void UserInfo::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.sign_info)
}
inline void UserInfo::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.sign_info)
}
inline void UserInfo::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.sign_info)
}
inline ::std::string* UserInfo::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.sign_info)
  return sign_info_;
}
inline ::std::string* UserInfo::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.sign_info)
}

// -------------------------------------------------------------------

// ContactSessionInfo

// required uint32 session_id = 1;
inline bool ContactSessionInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactSessionInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactSessionInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactSessionInfo::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 ContactSessionInfo::session_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.session_id)
  return session_id_;
}
inline void ContactSessionInfo::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.session_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool ContactSessionInfo::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactSessionInfo::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactSessionInfo::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactSessionInfo::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType ContactSessionInfo::session_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void ContactSessionInfo::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.session_type)
}

// required .IM.BaseDefine.SessionStatusType session_status = 3;
inline bool ContactSessionInfo::has_session_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactSessionInfo::set_has_session_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactSessionInfo::clear_has_session_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactSessionInfo::clear_session_status() {
  session_status_ = 0;
  clear_has_session_status();
}
inline ::IM::BaseDefine::SessionStatusType ContactSessionInfo::session_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.session_status)
  return static_cast< ::IM::BaseDefine::SessionStatusType >(session_status_);
}
inline void ContactSessionInfo::set_session_status(::IM::BaseDefine::SessionStatusType value) {
  assert(::IM::BaseDefine::SessionStatusType_IsValid(value));
  set_has_session_status();
  session_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.session_status)
}

// required uint32 updated_time = 4;
inline bool ContactSessionInfo::has_updated_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactSessionInfo::set_has_updated_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactSessionInfo::clear_has_updated_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactSessionInfo::clear_updated_time() {
  updated_time_ = 0u;
  clear_has_updated_time();
}
inline ::google::protobuf::uint32 ContactSessionInfo::updated_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.updated_time)
  return updated_time_;
}
inline void ContactSessionInfo::set_updated_time(::google::protobuf::uint32 value) {
  set_has_updated_time();
  updated_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.updated_time)
}

// required uint32 latest_msg_id = 5;
inline bool ContactSessionInfo::has_latest_msg_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContactSessionInfo::clear_has_latest_msg_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContactSessionInfo::clear_latest_msg_id() {
  latest_msg_id_ = 0u;
  clear_has_latest_msg_id();
}
inline ::google::protobuf::uint32 ContactSessionInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_id)
  return latest_msg_id_;
}
inline void ContactSessionInfo::set_latest_msg_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_id();
  latest_msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_id)
}

// required bytes latest_msg_data = 6;
inline bool ContactSessionInfo::has_latest_msg_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContactSessionInfo::clear_has_latest_msg_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContactSessionInfo::clear_latest_msg_data() {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_->clear();
  }
  clear_has_latest_msg_data();
}
inline const ::std::string& ContactSessionInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
  return *latest_msg_data_;
}
inline void ContactSessionInfo::set_latest_msg_data(const ::std::string& value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}
inline void ContactSessionInfo::set_latest_msg_data(const char* value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}
inline void ContactSessionInfo::set_latest_msg_data(const void* value, size_t size) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}
inline ::std::string* ContactSessionInfo::mutable_latest_msg_data() {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
  return latest_msg_data_;
}
inline ::std::string* ContactSessionInfo::release_latest_msg_data() {
  clear_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = latest_msg_data_;
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContactSessionInfo::set_allocated_latest_msg_data(::std::string* latest_msg_data) {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latest_msg_data_;
  }
  if (latest_msg_data) {
    set_has_latest_msg_data();
    latest_msg_data_ = latest_msg_data;
  } else {
    clear_has_latest_msg_data();
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}

// required .IM.BaseDefine.MsgType latest_msg_type = 7;
inline bool ContactSessionInfo::has_latest_msg_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContactSessionInfo::clear_has_latest_msg_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContactSessionInfo::clear_latest_msg_type() {
  latest_msg_type_ = 1;
  clear_has_latest_msg_type();
}
inline ::IM::BaseDefine::MsgType ContactSessionInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_type)
  return static_cast< ::IM::BaseDefine::MsgType >(latest_msg_type_);
}
inline void ContactSessionInfo::set_latest_msg_type(::IM::BaseDefine::MsgType value) {
  assert(::IM::BaseDefine::MsgType_IsValid(value));
  set_has_latest_msg_type();
  latest_msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_type)
}

// required uint32 latest_msg_from_user_id = 8;
inline bool ContactSessionInfo::has_latest_msg_from_user_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_from_user_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContactSessionInfo::clear_has_latest_msg_from_user_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContactSessionInfo::clear_latest_msg_from_user_id() {
  latest_msg_from_user_id_ = 0u;
  clear_has_latest_msg_from_user_id();
}
inline ::google::protobuf::uint32 ContactSessionInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_from_user_id)
  return latest_msg_from_user_id_;
}
inline void ContactSessionInfo::set_latest_msg_from_user_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_from_user_id();
  latest_msg_from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_from_user_id)
}

// -------------------------------------------------------------------

// UserStat

// required uint32 user_id = 1;
inline bool UserStat::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStat::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStat::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStat::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserStat::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.user_id)
  return user_id_;
}
inline void UserStat::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.user_id)
}

// required uint32 status = 2;
inline bool UserStat::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStat::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStat::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStat::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 UserStat::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.status)
  return status_;
}
inline void UserStat::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.status)
}

// -------------------------------------------------------------------

// ServerUserStat

// required uint32 user_id = 1;
inline bool ServerUserStat::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerUserStat::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerUserStat::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerUserStat::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ServerUserStat::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.user_id)
  return user_id_;
}
inline void ServerUserStat::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.user_id)
}

// required uint32 status = 2;
inline bool ServerUserStat::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerUserStat::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerUserStat::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerUserStat::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 ServerUserStat::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.status)
  return status_;
}
inline void ServerUserStat::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.status)
}

// required .IM.BaseDefine.ClientType client_type = 3;
inline bool ServerUserStat::has_client_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerUserStat::set_has_client_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerUserStat::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerUserStat::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::IM::BaseDefine::ClientType ServerUserStat::client_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.client_type)
  return static_cast< ::IM::BaseDefine::ClientType >(client_type_);
}
inline void ServerUserStat::set_client_type(::IM::BaseDefine::ClientType value) {
  assert(::IM::BaseDefine::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.client_type)
}

// required uint32 identity = 4;
inline bool ServerUserStat::has_identity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerUserStat::set_has_identity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerUserStat::clear_has_identity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerUserStat::clear_identity() {
  identity_ = 0u;
  clear_has_identity();
}
inline ::google::protobuf::uint32 ServerUserStat::identity() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.identity)
  return identity_;
}
inline void ServerUserStat::set_identity(::google::protobuf::uint32 value) {
  set_has_identity();
  identity_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.identity)
}

// -------------------------------------------------------------------

// UnreadInfo

// required uint32 session_id = 1;
inline bool UnreadInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnreadInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnreadInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnreadInfo::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 UnreadInfo::session_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.session_id)
  return session_id_;
}
inline void UnreadInfo::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.session_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool UnreadInfo::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnreadInfo::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnreadInfo::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnreadInfo::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType UnreadInfo::session_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void UnreadInfo::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.session_type)
}

// required uint32 unread_cnt = 3;
inline bool UnreadInfo::has_unread_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnreadInfo::set_has_unread_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnreadInfo::clear_has_unread_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnreadInfo::clear_unread_cnt() {
  unread_cnt_ = 0u;
  clear_has_unread_cnt();
}
inline ::google::protobuf::uint32 UnreadInfo::unread_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.unread_cnt)
  return unread_cnt_;
}
inline void UnreadInfo::set_unread_cnt(::google::protobuf::uint32 value) {
  set_has_unread_cnt();
  unread_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.unread_cnt)
}

// required uint32 latest_msg_id = 4;
inline bool UnreadInfo::has_latest_msg_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnreadInfo::clear_has_latest_msg_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnreadInfo::clear_latest_msg_id() {
  latest_msg_id_ = 0u;
  clear_has_latest_msg_id();
}
inline ::google::protobuf::uint32 UnreadInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_id)
  return latest_msg_id_;
}
inline void UnreadInfo::set_latest_msg_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_id();
  latest_msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_id)
}

// required bytes latest_msg_data = 5;
inline bool UnreadInfo::has_latest_msg_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UnreadInfo::clear_has_latest_msg_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UnreadInfo::clear_latest_msg_data() {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_->clear();
  }
  clear_has_latest_msg_data();
}
inline const ::std::string& UnreadInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_data)
  return *latest_msg_data_;
}
inline void UnreadInfo::set_latest_msg_data(const ::std::string& value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_data)
}
inline void UnreadInfo::set_latest_msg_data(const char* value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UnreadInfo.latest_msg_data)
}
inline void UnreadInfo::set_latest_msg_data(const void* value, size_t size) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UnreadInfo.latest_msg_data)
}
inline ::std::string* UnreadInfo::mutable_latest_msg_data() {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UnreadInfo.latest_msg_data)
  return latest_msg_data_;
}
inline ::std::string* UnreadInfo::release_latest_msg_data() {
  clear_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = latest_msg_data_;
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UnreadInfo::set_allocated_latest_msg_data(::std::string* latest_msg_data) {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latest_msg_data_;
  }
  if (latest_msg_data) {
    set_has_latest_msg_data();
    latest_msg_data_ = latest_msg_data;
  } else {
    clear_has_latest_msg_data();
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UnreadInfo.latest_msg_data)
}

// required .IM.BaseDefine.MsgType latest_msg_type = 6;
inline bool UnreadInfo::has_latest_msg_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UnreadInfo::clear_has_latest_msg_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UnreadInfo::clear_latest_msg_type() {
  latest_msg_type_ = 1;
  clear_has_latest_msg_type();
}
inline ::IM::BaseDefine::MsgType UnreadInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_type)
  return static_cast< ::IM::BaseDefine::MsgType >(latest_msg_type_);
}
inline void UnreadInfo::set_latest_msg_type(::IM::BaseDefine::MsgType value) {
  assert(::IM::BaseDefine::MsgType_IsValid(value));
  set_has_latest_msg_type();
  latest_msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_type)
}

// required uint32 latest_msg_from_user_id = 7;
inline bool UnreadInfo::has_latest_msg_from_user_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_from_user_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UnreadInfo::clear_has_latest_msg_from_user_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UnreadInfo::clear_latest_msg_from_user_id() {
  latest_msg_from_user_id_ = 0u;
  clear_has_latest_msg_from_user_id();
}
inline ::google::protobuf::uint32 UnreadInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_from_user_id)
  return latest_msg_from_user_id_;
}
inline void UnreadInfo::set_latest_msg_from_user_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_from_user_id();
  latest_msg_from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_from_user_id)
}

// -------------------------------------------------------------------

// MsgInfo

// required uint32 msg_id = 1;
inline bool MsgInfo::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfo::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfo::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfo::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 MsgInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.msg_id)
  return msg_id_;
}
inline void MsgInfo::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.msg_id)
}

// required uint32 from_session_id = 2;
inline bool MsgInfo::has_from_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfo::set_has_from_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfo::clear_has_from_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfo::clear_from_session_id() {
  from_session_id_ = 0u;
  clear_has_from_session_id();
}
inline ::google::protobuf::uint32 MsgInfo::from_session_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.from_session_id)
  return from_session_id_;
}
inline void MsgInfo::set_from_session_id(::google::protobuf::uint32 value) {
  set_has_from_session_id();
  from_session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.from_session_id)
}

// required uint32 create_time = 3;
inline bool MsgInfo::has_create_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgInfo::set_has_create_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgInfo::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgInfo::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 MsgInfo::create_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.create_time)
  return create_time_;
}
inline void MsgInfo::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.create_time)
}

// required uint32 msg_type = 4;
inline bool MsgInfo::has_msg_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgInfo::set_has_msg_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgInfo::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgInfo::clear_msg_type() {
  msg_type_ = 0u;
  clear_has_msg_type();
}
inline ::google::protobuf::uint32 MsgInfo::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.msg_type)
  return msg_type_;
}
inline void MsgInfo::set_msg_type(::google::protobuf::uint32 value) {
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.msg_type)
}

// required bytes msg_data = 5;
inline bool MsgInfo::has_msg_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgInfo::set_has_msg_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgInfo::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgInfo::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& MsgInfo::msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.msg_data)
  return *msg_data_;
}
inline void MsgInfo::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.msg_data)
}
inline void MsgInfo::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.MsgInfo.msg_data)
}
inline void MsgInfo::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.MsgInfo.msg_data)
}
inline ::std::string* MsgInfo::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.MsgInfo.msg_data)
  return msg_data_;
}
inline ::std::string* MsgInfo::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.MsgInfo.msg_data)
}

// -------------------------------------------------------------------

// GroupVersionInfo

// required uint32 group_id = 1;
inline bool GroupVersionInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupVersionInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupVersionInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupVersionInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupVersionInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupVersionInfo.group_id)
  return group_id_;
}
inline void GroupVersionInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupVersionInfo.group_id)
}

// required uint32 version = 2;
inline bool GroupVersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupVersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupVersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupVersionInfo::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 GroupVersionInfo::version() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupVersionInfo.version)
  return version_;
}
inline void GroupVersionInfo::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupVersionInfo.version)
}

// -------------------------------------------------------------------

// GroupInfo

// required uint32 group_id = 1;
inline bool GroupInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_id)
  return group_id_;
}
inline void GroupInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_id)
}

// required uint32 version = 2;
inline bool GroupInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupInfo::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 GroupInfo::version() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.version)
  return version_;
}
inline void GroupInfo::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.version)
}

// required string group_name = 3;
inline bool GroupInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupInfo::group_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_name)
  return *group_name_;
}
inline void GroupInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_name)
}
inline void GroupInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupInfo.group_name)
}
inline void GroupInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupInfo.group_name)
}
inline ::std::string* GroupInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupInfo.group_name)
  return group_name_;
}
inline ::std::string* GroupInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupInfo::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupInfo.group_name)
}

// required string group_avatar = 4;
inline bool GroupInfo::has_group_avatar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupInfo::set_has_group_avatar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupInfo::clear_has_group_avatar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupInfo::clear_group_avatar() {
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_->clear();
  }
  clear_has_group_avatar();
}
inline const ::std::string& GroupInfo::group_avatar() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_avatar)
  return *group_avatar_;
}
inline void GroupInfo::set_group_avatar(const ::std::string& value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_avatar)
}
inline void GroupInfo::set_group_avatar(const char* value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupInfo.group_avatar)
}
inline void GroupInfo::set_group_avatar(const char* value, size_t size) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupInfo.group_avatar)
}
inline ::std::string* GroupInfo::mutable_group_avatar() {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupInfo.group_avatar)
  return group_avatar_;
}
inline ::std::string* GroupInfo::release_group_avatar() {
  clear_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_avatar_;
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupInfo::set_allocated_group_avatar(::std::string* group_avatar) {
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_avatar_;
  }
  if (group_avatar) {
    set_has_group_avatar();
    group_avatar_ = group_avatar;
  } else {
    clear_has_group_avatar();
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupInfo.group_avatar)
}

// required uint32 group_creator_id = 5;
inline bool GroupInfo::has_group_creator_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupInfo::set_has_group_creator_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupInfo::clear_has_group_creator_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupInfo::clear_group_creator_id() {
  group_creator_id_ = 0u;
  clear_has_group_creator_id();
}
inline ::google::protobuf::uint32 GroupInfo::group_creator_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_creator_id)
  return group_creator_id_;
}
inline void GroupInfo::set_group_creator_id(::google::protobuf::uint32 value) {
  set_has_group_creator_id();
  group_creator_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_creator_id)
}

// required .IM.BaseDefine.GroupType group_type = 6;
inline bool GroupInfo::has_group_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupInfo::set_has_group_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupInfo::clear_has_group_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupInfo::clear_group_type() {
  group_type_ = 0;
  clear_has_group_type();
}
inline ::IM::BaseDefine::GroupType GroupInfo::group_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_type)
  return static_cast< ::IM::BaseDefine::GroupType >(group_type_);
}
inline void GroupInfo::set_group_type(::IM::BaseDefine::GroupType value) {
  assert(::IM::BaseDefine::GroupType_IsValid(value));
  set_has_group_type();
  group_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_type)
}

// required uint32 shield_status = 7;
inline bool GroupInfo::has_shield_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupInfo::set_has_shield_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupInfo::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupInfo::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 GroupInfo::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.shield_status)
  return shield_status_;
}
inline void GroupInfo::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.shield_status)
}

// repeated uint32 group_member_list = 8;
inline int GroupInfo::group_member_list_size() const {
  return group_member_list_.size();
}
inline void GroupInfo::clear_group_member_list() {
  group_member_list_.Clear();
}
inline ::google::protobuf::uint32 GroupInfo::group_member_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_member_list)
  return group_member_list_.Get(index);
}
inline void GroupInfo::set_group_member_list(int index, ::google::protobuf::uint32 value) {
  group_member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_member_list)
}
inline void GroupInfo::add_group_member_list(::google::protobuf::uint32 value) {
  group_member_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.BaseDefine.GroupInfo.group_member_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GroupInfo::group_member_list() const {
  // @@protoc_insertion_point(field_list:IM.BaseDefine.GroupInfo.group_member_list)
  return group_member_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GroupInfo::mutable_group_member_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.BaseDefine.GroupInfo.group_member_list)
  return &group_member_list_;
}

// -------------------------------------------------------------------

// GroupMsgInfo

// required uint32 msg_id = 1;
inline bool GroupMsgInfo::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgInfo::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgInfo::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgInfo::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 GroupMsgInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMsgInfo.msg_id)
  return msg_id_;
}
inline void GroupMsgInfo::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMsgInfo.msg_id)
}

// required string user_im_name = 2;
inline bool GroupMsgInfo::has_user_im_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgInfo::set_has_user_im_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgInfo::clear_has_user_im_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgInfo::clear_user_im_name() {
  if (user_im_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_im_name_->clear();
  }
  clear_has_user_im_name();
}
inline const ::std::string& GroupMsgInfo::user_im_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMsgInfo.user_im_name)
  return *user_im_name_;
}
inline void GroupMsgInfo::set_user_im_name(const ::std::string& value) {
  set_has_user_im_name();
  if (user_im_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_im_name_ = new ::std::string;
  }
  user_im_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMsgInfo.user_im_name)
}
inline void GroupMsgInfo::set_user_im_name(const char* value) {
  set_has_user_im_name();
  if (user_im_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_im_name_ = new ::std::string;
  }
  user_im_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupMsgInfo.user_im_name)
}
inline void GroupMsgInfo::set_user_im_name(const char* value, size_t size) {
  set_has_user_im_name();
  if (user_im_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_im_name_ = new ::std::string;
  }
  user_im_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupMsgInfo.user_im_name)
}
inline ::std::string* GroupMsgInfo::mutable_user_im_name() {
  set_has_user_im_name();
  if (user_im_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_im_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupMsgInfo.user_im_name)
  return user_im_name_;
}
inline ::std::string* GroupMsgInfo::release_user_im_name() {
  clear_has_user_im_name();
  if (user_im_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_im_name_;
    user_im_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupMsgInfo::set_allocated_user_im_name(::std::string* user_im_name) {
  if (user_im_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_im_name_;
  }
  if (user_im_name) {
    set_has_user_im_name();
    user_im_name_ = user_im_name;
  } else {
    clear_has_user_im_name();
    user_im_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupMsgInfo.user_im_name)
}

// required uint32 user_im_identity = 3;
inline bool GroupMsgInfo::has_user_im_identity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMsgInfo::set_has_user_im_identity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMsgInfo::clear_has_user_im_identity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMsgInfo::clear_user_im_identity() {
  user_im_identity_ = 0u;
  clear_has_user_im_identity();
}
inline ::google::protobuf::uint32 GroupMsgInfo::user_im_identity() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMsgInfo.user_im_identity)
  return user_im_identity_;
}
inline void GroupMsgInfo::set_user_im_identity(::google::protobuf::uint32 value) {
  set_has_user_im_identity();
  user_im_identity_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMsgInfo.user_im_identity)
}

// required string group_name = 4;
inline bool GroupMsgInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMsgInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMsgInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMsgInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupMsgInfo::group_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMsgInfo.group_name)
  return *group_name_;
}
inline void GroupMsgInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMsgInfo.group_name)
}
inline void GroupMsgInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupMsgInfo.group_name)
}
inline void GroupMsgInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupMsgInfo.group_name)
}
inline ::std::string* GroupMsgInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupMsgInfo.group_name)
  return group_name_;
}
inline ::std::string* GroupMsgInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupMsgInfo::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupMsgInfo.group_name)
}

// required uint32 group_id = 5;
inline bool GroupMsgInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMsgInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMsgInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMsgInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupMsgInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMsgInfo.group_id)
  return group_id_;
}
inline void GroupMsgInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMsgInfo.group_id)
}

// repeated uint32 member_list = 6;
inline int GroupMsgInfo::member_list_size() const {
  return member_list_.size();
}
inline void GroupMsgInfo::clear_member_list() {
  member_list_.Clear();
}
inline ::google::protobuf::uint32 GroupMsgInfo::member_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMsgInfo.member_list)
  return member_list_.Get(index);
}
inline void GroupMsgInfo::set_member_list(int index, ::google::protobuf::uint32 value) {
  member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMsgInfo.member_list)
}
inline void GroupMsgInfo::add_member_list(::google::protobuf::uint32 value) {
  member_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.BaseDefine.GroupMsgInfo.member_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GroupMsgInfo::member_list() const {
  // @@protoc_insertion_point(field_list:IM.BaseDefine.GroupMsgInfo.member_list)
  return member_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GroupMsgInfo::mutable_member_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.BaseDefine.GroupMsgInfo.member_list)
  return &member_list_;
}

// -------------------------------------------------------------------

// UserTokenInfo

// required uint32 user_id = 1;
inline bool UserTokenInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTokenInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTokenInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTokenInfo::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserTokenInfo::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.user_id)
  return user_id_;
}
inline void UserTokenInfo::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.user_id)
}

// required uint32 user_type = 2;
inline bool UserTokenInfo::has_user_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTokenInfo::set_has_user_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTokenInfo::clear_has_user_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTokenInfo::clear_user_type() {
  user_type_ = 0u;
  clear_has_user_type();
}
inline ::google::protobuf::uint32 UserTokenInfo::user_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.user_type)
  return user_type_;
}
inline void UserTokenInfo::set_user_type(::google::protobuf::uint32 value) {
  set_has_user_type();
  user_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.user_type)
}

// required string token = 3;
inline bool UserTokenInfo::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTokenInfo::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTokenInfo::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTokenInfo::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserTokenInfo::token() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.token)
  return *token_;
}
inline void UserTokenInfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.token)
}
inline void UserTokenInfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserTokenInfo.token)
}
inline void UserTokenInfo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserTokenInfo.token)
}
inline ::std::string* UserTokenInfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserTokenInfo.token)
  return token_;
}
inline ::std::string* UserTokenInfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserTokenInfo::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserTokenInfo.token)
}

// required uint32 push_count = 4;
inline bool UserTokenInfo::has_push_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserTokenInfo::set_has_push_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserTokenInfo::clear_has_push_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserTokenInfo::clear_push_count() {
  push_count_ = 0u;
  clear_has_push_count();
}
inline ::google::protobuf::uint32 UserTokenInfo::push_count() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.push_count)
  return push_count_;
}
inline void UserTokenInfo::set_push_count(::google::protobuf::uint32 value) {
  set_has_push_count();
  push_count_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.push_count)
}

// required uint32 push_type = 5;
inline bool UserTokenInfo::has_push_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserTokenInfo::set_has_push_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserTokenInfo::clear_has_push_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserTokenInfo::clear_push_type() {
  push_type_ = 0u;
  clear_has_push_type();
}
inline ::google::protobuf::uint32 UserTokenInfo::push_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.push_type)
  return push_type_;
}
inline void UserTokenInfo::set_push_type(::google::protobuf::uint32 value) {
  set_has_push_type();
  push_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.push_type)
}

// optional uint32 allow_disturb = 6;
inline bool UserTokenInfo::has_allow_disturb() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserTokenInfo::set_has_allow_disturb() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserTokenInfo::clear_has_allow_disturb() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserTokenInfo::clear_allow_disturb() {
  allow_disturb_ = 0u;
  clear_has_allow_disturb();
}
inline ::google::protobuf::uint32 UserTokenInfo::allow_disturb() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.allow_disturb)
  return allow_disturb_;
}
inline void UserTokenInfo::set_allow_disturb(::google::protobuf::uint32 value) {
  set_has_allow_disturb();
  allow_disturb_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.allow_disturb)
}

// -------------------------------------------------------------------

// PushResult

// required string user_token = 1;
inline bool PushResult::has_user_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushResult::set_has_user_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushResult::clear_has_user_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushResult::clear_user_token() {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_->clear();
  }
  clear_has_user_token();
}
inline const ::std::string& PushResult::user_token() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushResult.user_token)
  return *user_token_;
}
inline void PushResult::set_user_token(const ::std::string& value) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushResult.user_token)
}
inline void PushResult::set_user_token(const char* value) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.PushResult.user_token)
}
inline void PushResult::set_user_token(const char* value, size_t size) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.PushResult.user_token)
}
inline ::std::string* PushResult::mutable_user_token() {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.PushResult.user_token)
  return user_token_;
}
inline ::std::string* PushResult::release_user_token() {
  clear_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_token_;
    user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushResult::set_allocated_user_token(::std::string* user_token) {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_token_;
  }
  if (user_token) {
    set_has_user_token();
    user_token_ = user_token;
  } else {
    clear_has_user_token();
    user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.PushResult.user_token)
}

// required uint32 result_code = 2;
inline bool PushResult::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushResult::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushResult::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushResult::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 PushResult::result_code() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushResult.result_code)
  return result_code_;
}
inline void PushResult::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushResult.result_code)
}

// -------------------------------------------------------------------

// ShieldStatus

// required uint32 user_id = 1;
inline bool ShieldStatus::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShieldStatus::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShieldStatus::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShieldStatus::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ShieldStatus::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.user_id)
  return user_id_;
}
inline void ShieldStatus::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.user_id)
}

// required uint32 group_id = 2;
inline bool ShieldStatus::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShieldStatus::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShieldStatus::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShieldStatus::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 ShieldStatus::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.group_id)
  return group_id_;
}
inline void ShieldStatus::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.group_id)
}

// required uint32 shield_status = 3;
inline bool ShieldStatus::has_shield_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShieldStatus::set_has_shield_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShieldStatus::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShieldStatus::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 ShieldStatus::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.shield_status)
  return shield_status_;
}
inline void ShieldStatus::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.shield_status)
}

// -------------------------------------------------------------------

// OfflineFileInfo

// required uint32 from_user_id = 1;
inline bool OfflineFileInfo::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfflineFileInfo::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfflineFileInfo::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfflineFileInfo::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 OfflineFileInfo::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.from_user_id)
  return from_user_id_;
}
inline void OfflineFileInfo::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.from_user_id)
}

// required string task_id = 2;
inline bool OfflineFileInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OfflineFileInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OfflineFileInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OfflineFileInfo::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& OfflineFileInfo::task_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.task_id)
  return *task_id_;
}
inline void OfflineFileInfo::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline void OfflineFileInfo::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline void OfflineFileInfo::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline ::std::string* OfflineFileInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineFileInfo.task_id)
  return task_id_;
}
inline ::std::string* OfflineFileInfo::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfflineFileInfo::set_allocated_task_id(::std::string* task_id) {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_id_;
  }
  if (task_id) {
    set_has_task_id();
    task_id_ = task_id;
  } else {
    clear_has_task_id();
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.OfflineFileInfo.task_id)
}

// required string file_name = 3;
inline bool OfflineFileInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OfflineFileInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OfflineFileInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OfflineFileInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& OfflineFileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.file_name)
  return *file_name_;
}
inline void OfflineFileInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline void OfflineFileInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline void OfflineFileInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline ::std::string* OfflineFileInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineFileInfo.file_name)
  return file_name_;
}
inline ::std::string* OfflineFileInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfflineFileInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.OfflineFileInfo.file_name)
}

// required uint32 file_size = 4;
inline bool OfflineFileInfo::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OfflineFileInfo::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OfflineFileInfo::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OfflineFileInfo::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 OfflineFileInfo::file_size() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.file_size)
  return file_size_;
}
inline void OfflineFileInfo::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.file_size)
}

// -------------------------------------------------------------------

// DepartInfo

// required uint32 dept_id = 1;
inline bool DepartInfo::has_dept_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DepartInfo::set_has_dept_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DepartInfo::clear_has_dept_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DepartInfo::clear_dept_id() {
  dept_id_ = 0u;
  clear_has_dept_id();
}
inline ::google::protobuf::uint32 DepartInfo::dept_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.dept_id)
  return dept_id_;
}
inline void DepartInfo::set_dept_id(::google::protobuf::uint32 value) {
  set_has_dept_id();
  dept_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.dept_id)
}

// required uint32 priority = 2;
inline bool DepartInfo::has_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DepartInfo::set_has_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DepartInfo::clear_has_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DepartInfo::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 DepartInfo::priority() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.priority)
  return priority_;
}
inline void DepartInfo::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.priority)
}

// required string dept_name = 3;
inline bool DepartInfo::has_dept_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DepartInfo::set_has_dept_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DepartInfo::clear_has_dept_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DepartInfo::clear_dept_name() {
  if (dept_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dept_name_->clear();
  }
  clear_has_dept_name();
}
inline const ::std::string& DepartInfo::dept_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.dept_name)
  return *dept_name_;
}
inline void DepartInfo::set_dept_name(const ::std::string& value) {
  set_has_dept_name();
  if (dept_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dept_name_ = new ::std::string;
  }
  dept_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.dept_name)
}
inline void DepartInfo::set_dept_name(const char* value) {
  set_has_dept_name();
  if (dept_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dept_name_ = new ::std::string;
  }
  dept_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.DepartInfo.dept_name)
}
inline void DepartInfo::set_dept_name(const char* value, size_t size) {
  set_has_dept_name();
  if (dept_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dept_name_ = new ::std::string;
  }
  dept_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.DepartInfo.dept_name)
}
inline ::std::string* DepartInfo::mutable_dept_name() {
  set_has_dept_name();
  if (dept_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dept_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.DepartInfo.dept_name)
  return dept_name_;
}
inline ::std::string* DepartInfo::release_dept_name() {
  clear_has_dept_name();
  if (dept_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dept_name_;
    dept_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DepartInfo::set_allocated_dept_name(::std::string* dept_name) {
  if (dept_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dept_name_;
  }
  if (dept_name) {
    set_has_dept_name();
    dept_name_ = dept_name;
  } else {
    clear_has_dept_name();
    dept_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.DepartInfo.dept_name)
}

// required uint32 parent_dept_id = 4;
inline bool DepartInfo::has_parent_dept_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DepartInfo::set_has_parent_dept_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DepartInfo::clear_has_parent_dept_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DepartInfo::clear_parent_dept_id() {
  parent_dept_id_ = 0u;
  clear_has_parent_dept_id();
}
inline ::google::protobuf::uint32 DepartInfo::parent_dept_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.parent_dept_id)
  return parent_dept_id_;
}
inline void DepartInfo::set_parent_dept_id(::google::protobuf::uint32 value) {
  set_has_parent_dept_id();
  parent_dept_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.parent_dept_id)
}

// required .IM.BaseDefine.DepartmentStatusType dept_status = 5;
inline bool DepartInfo::has_dept_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DepartInfo::set_has_dept_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DepartInfo::clear_has_dept_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DepartInfo::clear_dept_status() {
  dept_status_ = 0;
  clear_has_dept_status();
}
inline ::IM::BaseDefine::DepartmentStatusType DepartInfo::dept_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.dept_status)
  return static_cast< ::IM::BaseDefine::DepartmentStatusType >(dept_status_);
}
inline void DepartInfo::set_dept_status(::IM::BaseDefine::DepartmentStatusType value) {
  assert(::IM::BaseDefine::DepartmentStatusType_IsValid(value));
  set_has_dept_status();
  dept_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.dept_status)
}

// -------------------------------------------------------------------

// PushShieldStatus

// required uint32 user_id = 1;
inline bool PushShieldStatus::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushShieldStatus::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushShieldStatus::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushShieldStatus::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 PushShieldStatus::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushShieldStatus.user_id)
  return user_id_;
}
inline void PushShieldStatus::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushShieldStatus.user_id)
}

// required uint32 shield_status = 2;
inline bool PushShieldStatus::has_shield_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushShieldStatus::set_has_shield_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushShieldStatus::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushShieldStatus::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 PushShieldStatus::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushShieldStatus.shield_status)
  return shield_status_;
}
inline void PushShieldStatus::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushShieldStatus.shield_status)
}

// -------------------------------------------------------------------

// StudentStat

// required uint32 student_id = 1;
inline bool StudentStat::has_student_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StudentStat::set_has_student_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StudentStat::clear_has_student_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StudentStat::clear_student_id() {
  student_id_ = 0u;
  clear_has_student_id();
}
inline ::google::protobuf::uint32 StudentStat::student_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.StudentStat.student_id)
  return student_id_;
}
inline void StudentStat::set_student_id(::google::protobuf::uint32 value) {
  set_has_student_id();
  student_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.StudentStat.student_id)
}

// required uint32 online_status = 2;
inline bool StudentStat::has_online_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StudentStat::set_has_online_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StudentStat::clear_has_online_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StudentStat::clear_online_status() {
  online_status_ = 0u;
  clear_has_online_status();
}
inline ::google::protobuf::uint32 StudentStat::online_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.StudentStat.online_status)
  return online_status_;
}
inline void StudentStat::set_online_status(::google::protobuf::uint32 value) {
  set_has_online_status();
  online_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.StudentStat.online_status)
}

// required uint32 consult_status = 3;
inline bool StudentStat::has_consult_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StudentStat::set_has_consult_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StudentStat::clear_has_consult_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StudentStat::clear_consult_status() {
  consult_status_ = 0u;
  clear_has_consult_status();
}
inline ::google::protobuf::uint32 StudentStat::consult_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.StudentStat.consult_status)
  return consult_status_;
}
inline void StudentStat::set_consult_status(::google::protobuf::uint32 value) {
  set_has_consult_status();
  consult_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.StudentStat.consult_status)
}

// required uint32 teacher_id = 4;
inline bool StudentStat::has_teacher_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StudentStat::set_has_teacher_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StudentStat::clear_has_teacher_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StudentStat::clear_teacher_id() {
  teacher_id_ = 0u;
  clear_has_teacher_id();
}
inline ::google::protobuf::uint32 StudentStat::teacher_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.StudentStat.teacher_id)
  return teacher_id_;
}
inline void StudentStat::set_teacher_id(::google::protobuf::uint32 value) {
  set_has_teacher_id();
  teacher_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.StudentStat.teacher_id)
}

// required uint32 order_id = 5;
inline bool StudentStat::has_order_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StudentStat::set_has_order_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StudentStat::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StudentStat::clear_order_id() {
  order_id_ = 0u;
  clear_has_order_id();
}
inline ::google::protobuf::uint32 StudentStat::order_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.StudentStat.order_id)
  return order_id_;
}
inline void StudentStat::set_order_id(::google::protobuf::uint32 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.StudentStat.order_id)
}

// required uint32 consult_id = 6;
inline bool StudentStat::has_consult_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StudentStat::set_has_consult_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StudentStat::clear_has_consult_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StudentStat::clear_consult_id() {
  consult_id_ = 0u;
  clear_has_consult_id();
}
inline ::google::protobuf::uint32 StudentStat::consult_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.StudentStat.consult_id)
  return consult_id_;
}
inline void StudentStat::set_consult_id(::google::protobuf::uint32 value) {
  set_has_consult_id();
  consult_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.StudentStat.consult_id)
}

// optional uint32 service = 7;
inline bool StudentStat::has_service() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StudentStat::set_has_service() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StudentStat::clear_has_service() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StudentStat::clear_service() {
  service_ = 0u;
  clear_has_service();
}
inline ::google::protobuf::uint32 StudentStat::service() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.StudentStat.service)
  return service_;
}
inline void StudentStat::set_service(::google::protobuf::uint32 value) {
  set_has_service();
  service_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.StudentStat.service)
}

// -------------------------------------------------------------------

// ManagerStat

// required uint32 manager_id = 1;
inline bool ManagerStat::has_manager_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManagerStat::set_has_manager_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManagerStat::clear_has_manager_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManagerStat::clear_manager_id() {
  manager_id_ = 0u;
  clear_has_manager_id();
}
inline ::google::protobuf::uint32 ManagerStat::manager_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ManagerStat.manager_id)
  return manager_id_;
}
inline void ManagerStat::set_manager_id(::google::protobuf::uint32 value) {
  set_has_manager_id();
  manager_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ManagerStat.manager_id)
}

// required uint32 online_status = 2;
inline bool ManagerStat::has_online_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManagerStat::set_has_online_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManagerStat::clear_has_online_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManagerStat::clear_online_status() {
  online_status_ = 0u;
  clear_has_online_status();
}
inline ::google::protobuf::uint32 ManagerStat::online_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ManagerStat.online_status)
  return online_status_;
}
inline void ManagerStat::set_online_status(::google::protobuf::uint32 value) {
  set_has_online_status();
  online_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ManagerStat.online_status)
}

// required uint32 consult_cnt = 3;
inline bool ManagerStat::has_consult_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManagerStat::set_has_consult_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManagerStat::clear_has_consult_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManagerStat::clear_consult_cnt() {
  consult_cnt_ = 0u;
  clear_has_consult_cnt();
}
inline ::google::protobuf::uint32 ManagerStat::consult_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ManagerStat.consult_cnt)
  return consult_cnt_;
}
inline void ManagerStat::set_consult_cnt(::google::protobuf::uint32 value) {
  set_has_consult_cnt();
  consult_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ManagerStat.consult_cnt)
}

// required uint32 queue_cnt = 4;
inline bool ManagerStat::has_queue_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManagerStat::set_has_queue_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManagerStat::clear_has_queue_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManagerStat::clear_queue_cnt() {
  queue_cnt_ = 0u;
  clear_has_queue_cnt();
}
inline ::google::protobuf::uint32 ManagerStat::queue_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ManagerStat.queue_cnt)
  return queue_cnt_;
}
inline void ManagerStat::set_queue_cnt(::google::protobuf::uint32 value) {
  set_has_queue_cnt();
  queue_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ManagerStat.queue_cnt)
}

// -------------------------------------------------------------------

// DutyStat

// required uint32 duty_id = 1;
inline bool DutyStat::has_duty_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DutyStat::set_has_duty_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DutyStat::clear_has_duty_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DutyStat::clear_duty_id() {
  duty_id_ = 0u;
  clear_has_duty_id();
}
inline ::google::protobuf::uint32 DutyStat::duty_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DutyStat.duty_id)
  return duty_id_;
}
inline void DutyStat::set_duty_id(::google::protobuf::uint32 value) {
  set_has_duty_id();
  duty_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DutyStat.duty_id)
}

// required uint32 online_status = 2;
inline bool DutyStat::has_online_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DutyStat::set_has_online_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DutyStat::clear_has_online_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DutyStat::clear_online_status() {
  online_status_ = 0u;
  clear_has_online_status();
}
inline ::google::protobuf::uint32 DutyStat::online_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DutyStat.online_status)
  return online_status_;
}
inline void DutyStat::set_online_status(::google::protobuf::uint32 value) {
  set_has_online_status();
  online_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DutyStat.online_status)
}

// required uint32 consult_cnt = 3;
inline bool DutyStat::has_consult_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DutyStat::set_has_consult_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DutyStat::clear_has_consult_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DutyStat::clear_consult_cnt() {
  consult_cnt_ = 0u;
  clear_has_consult_cnt();
}
inline ::google::protobuf::uint32 DutyStat::consult_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DutyStat.consult_cnt)
  return consult_cnt_;
}
inline void DutyStat::set_consult_cnt(::google::protobuf::uint32 value) {
  set_has_consult_cnt();
  consult_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DutyStat.consult_cnt)
}

// required uint32 queue_cnt = 4;
inline bool DutyStat::has_queue_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DutyStat::set_has_queue_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DutyStat::clear_has_queue_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DutyStat::clear_queue_cnt() {
  queue_cnt_ = 0u;
  clear_has_queue_cnt();
}
inline ::google::protobuf::uint32 DutyStat::queue_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DutyStat.queue_cnt)
  return queue_cnt_;
}
inline void DutyStat::set_queue_cnt(::google::protobuf::uint32 value) {
  set_has_queue_cnt();
  queue_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DutyStat.queue_cnt)
}

// required uint32 consult_history = 5;
inline bool DutyStat::has_consult_history() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DutyStat::set_has_consult_history() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DutyStat::clear_has_consult_history() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DutyStat::clear_consult_history() {
  consult_history_ = 0u;
  clear_has_consult_history();
}
inline ::google::protobuf::uint32 DutyStat::consult_history() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DutyStat.consult_history)
  return consult_history_;
}
inline void DutyStat::set_consult_history(::google::protobuf::uint32 value) {
  set_has_consult_history();
  consult_history_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DutyStat.consult_history)
}

// required uint32 last_msg_time = 6;
inline bool DutyStat::has_last_msg_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DutyStat::set_has_last_msg_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DutyStat::clear_has_last_msg_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DutyStat::clear_last_msg_time() {
  last_msg_time_ = 0u;
  clear_has_last_msg_time();
}
inline ::google::protobuf::uint32 DutyStat::last_msg_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DutyStat.last_msg_time)
  return last_msg_time_;
}
inline void DutyStat::set_last_msg_time(::google::protobuf::uint32 value) {
  set_has_last_msg_time();
  last_msg_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DutyStat.last_msg_time)
}

// -------------------------------------------------------------------

// ComplaintRefundTeacherStat

// required uint32 teacher_id = 1;
inline bool ComplaintRefundTeacherStat::has_teacher_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComplaintRefundTeacherStat::set_has_teacher_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComplaintRefundTeacherStat::clear_has_teacher_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComplaintRefundTeacherStat::clear_teacher_id() {
  teacher_id_ = 0u;
  clear_has_teacher_id();
}
inline ::google::protobuf::uint32 ComplaintRefundTeacherStat::teacher_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ComplaintRefundTeacherStat.teacher_id)
  return teacher_id_;
}
inline void ComplaintRefundTeacherStat::set_teacher_id(::google::protobuf::uint32 value) {
  set_has_teacher_id();
  teacher_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ComplaintRefundTeacherStat.teacher_id)
}

// required uint32 online_status = 2;
inline bool ComplaintRefundTeacherStat::has_online_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComplaintRefundTeacherStat::set_has_online_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComplaintRefundTeacherStat::clear_has_online_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComplaintRefundTeacherStat::clear_online_status() {
  online_status_ = 0u;
  clear_has_online_status();
}
inline ::google::protobuf::uint32 ComplaintRefundTeacherStat::online_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ComplaintRefundTeacherStat.online_status)
  return online_status_;
}
inline void ComplaintRefundTeacherStat::set_online_status(::google::protobuf::uint32 value) {
  set_has_online_status();
  online_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ComplaintRefundTeacherStat.online_status)
}

// required uint32 consult_cnt = 3;
inline bool ComplaintRefundTeacherStat::has_consult_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComplaintRefundTeacherStat::set_has_consult_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComplaintRefundTeacherStat::clear_has_consult_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComplaintRefundTeacherStat::clear_consult_cnt() {
  consult_cnt_ = 0u;
  clear_has_consult_cnt();
}
inline ::google::protobuf::uint32 ComplaintRefundTeacherStat::consult_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ComplaintRefundTeacherStat.consult_cnt)
  return consult_cnt_;
}
inline void ComplaintRefundTeacherStat::set_consult_cnt(::google::protobuf::uint32 value) {
  set_has_consult_cnt();
  consult_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ComplaintRefundTeacherStat.consult_cnt)
}

// required uint32 queue_cnt = 4;
inline bool ComplaintRefundTeacherStat::has_queue_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComplaintRefundTeacherStat::set_has_queue_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComplaintRefundTeacherStat::clear_has_queue_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComplaintRefundTeacherStat::clear_queue_cnt() {
  queue_cnt_ = 0u;
  clear_has_queue_cnt();
}
inline ::google::protobuf::uint32 ComplaintRefundTeacherStat::queue_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ComplaintRefundTeacherStat.queue_cnt)
  return queue_cnt_;
}
inline void ComplaintRefundTeacherStat::set_queue_cnt(::google::protobuf::uint32 value) {
  set_has_queue_cnt();
  queue_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ComplaintRefundTeacherStat.queue_cnt)
}

// required uint32 consult_history = 5;
inline bool ComplaintRefundTeacherStat::has_consult_history() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ComplaintRefundTeacherStat::set_has_consult_history() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ComplaintRefundTeacherStat::clear_has_consult_history() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ComplaintRefundTeacherStat::clear_consult_history() {
  consult_history_ = 0u;
  clear_has_consult_history();
}
inline ::google::protobuf::uint32 ComplaintRefundTeacherStat::consult_history() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ComplaintRefundTeacherStat.consult_history)
  return consult_history_;
}
inline void ComplaintRefundTeacherStat::set_consult_history(::google::protobuf::uint32 value) {
  set_has_consult_history();
  consult_history_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ComplaintRefundTeacherStat.consult_history)
}

// required uint32 last_msg_time = 6;
inline bool ComplaintRefundTeacherStat::has_last_msg_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ComplaintRefundTeacherStat::set_has_last_msg_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ComplaintRefundTeacherStat::clear_has_last_msg_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ComplaintRefundTeacherStat::clear_last_msg_time() {
  last_msg_time_ = 0u;
  clear_has_last_msg_time();
}
inline ::google::protobuf::uint32 ComplaintRefundTeacherStat::last_msg_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ComplaintRefundTeacherStat.last_msg_time)
  return last_msg_time_;
}
inline void ComplaintRefundTeacherStat::set_last_msg_time(::google::protobuf::uint32 value) {
  set_has_last_msg_time();
  last_msg_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ComplaintRefundTeacherStat.last_msg_time)
}

// -------------------------------------------------------------------

// TeacherStat

// required uint32 teacher_id = 1;
inline bool TeacherStat::has_teacher_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeacherStat::set_has_teacher_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeacherStat::clear_has_teacher_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeacherStat::clear_teacher_id() {
  teacher_id_ = 0u;
  clear_has_teacher_id();
}
inline ::google::protobuf::uint32 TeacherStat::teacher_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.TeacherStat.teacher_id)
  return teacher_id_;
}
inline void TeacherStat::set_teacher_id(::google::protobuf::uint32 value) {
  set_has_teacher_id();
  teacher_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.TeacherStat.teacher_id)
}

// required uint32 state = 2;
inline bool TeacherStat::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeacherStat::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeacherStat::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeacherStat::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 TeacherStat::state() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.TeacherStat.state)
  return state_;
}
inline void TeacherStat::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.TeacherStat.state)
}

// -------------------------------------------------------------------

// ConsultMsg

// required uint32 from_id = 1;
inline bool ConsultMsg::has_from_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConsultMsg::set_has_from_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConsultMsg::clear_has_from_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConsultMsg::clear_from_id() {
  from_id_ = 0u;
  clear_has_from_id();
}
inline ::google::protobuf::uint32 ConsultMsg::from_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultMsg.from_id)
  return from_id_;
}
inline void ConsultMsg::set_from_id(::google::protobuf::uint32 value) {
  set_has_from_id();
  from_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultMsg.from_id)
}

// required uint32 to_id = 2;
inline bool ConsultMsg::has_to_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConsultMsg::set_has_to_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConsultMsg::clear_has_to_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConsultMsg::clear_to_id() {
  to_id_ = 0u;
  clear_has_to_id();
}
inline ::google::protobuf::uint32 ConsultMsg::to_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultMsg.to_id)
  return to_id_;
}
inline void ConsultMsg::set_to_id(::google::protobuf::uint32 value) {
  set_has_to_id();
  to_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultMsg.to_id)
}

// required uint32 msg_id = 3;
inline bool ConsultMsg::has_msg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConsultMsg::set_has_msg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConsultMsg::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConsultMsg::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 ConsultMsg::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultMsg.msg_id)
  return msg_id_;
}
inline void ConsultMsg::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultMsg.msg_id)
}

// required uint32 msg_type = 4;
inline bool ConsultMsg::has_msg_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConsultMsg::set_has_msg_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConsultMsg::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConsultMsg::clear_msg_type() {
  msg_type_ = 0u;
  clear_has_msg_type();
}
inline ::google::protobuf::uint32 ConsultMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultMsg.msg_type)
  return msg_type_;
}
inline void ConsultMsg::set_msg_type(::google::protobuf::uint32 value) {
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultMsg.msg_type)
}

// required uint32 create_time = 5;
inline bool ConsultMsg::has_create_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConsultMsg::set_has_create_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConsultMsg::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConsultMsg::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 ConsultMsg::create_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultMsg.create_time)
  return create_time_;
}
inline void ConsultMsg::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultMsg.create_time)
}

// required uint32 from_identity = 6;
inline bool ConsultMsg::has_from_identity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConsultMsg::set_has_from_identity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConsultMsg::clear_has_from_identity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConsultMsg::clear_from_identity() {
  from_identity_ = 0u;
  clear_has_from_identity();
}
inline ::google::protobuf::uint32 ConsultMsg::from_identity() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultMsg.from_identity)
  return from_identity_;
}
inline void ConsultMsg::set_from_identity(::google::protobuf::uint32 value) {
  set_has_from_identity();
  from_identity_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultMsg.from_identity)
}

// required uint32 to_identity = 7;
inline bool ConsultMsg::has_to_identity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConsultMsg::set_has_to_identity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConsultMsg::clear_has_to_identity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConsultMsg::clear_to_identity() {
  to_identity_ = 0u;
  clear_has_to_identity();
}
inline ::google::protobuf::uint32 ConsultMsg::to_identity() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultMsg.to_identity)
  return to_identity_;
}
inline void ConsultMsg::set_to_identity(::google::protobuf::uint32 value) {
  set_has_to_identity();
  to_identity_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultMsg.to_identity)
}

// required bytes msg_data = 8;
inline bool ConsultMsg::has_msg_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ConsultMsg::set_has_msg_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ConsultMsg::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ConsultMsg::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& ConsultMsg::msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultMsg.msg_data)
  return *msg_data_;
}
inline void ConsultMsg::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultMsg.msg_data)
}
inline void ConsultMsg::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.ConsultMsg.msg_data)
}
inline void ConsultMsg::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.ConsultMsg.msg_data)
}
inline ::std::string* ConsultMsg::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.ConsultMsg.msg_data)
  return msg_data_;
}
inline ::std::string* ConsultMsg::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConsultMsg::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.ConsultMsg.msg_data)
}

// -------------------------------------------------------------------

// ConsultTimeout

// required uint32 consult_id = 1;
inline bool ConsultTimeout::has_consult_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConsultTimeout::set_has_consult_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConsultTimeout::clear_has_consult_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConsultTimeout::clear_consult_id() {
  consult_id_ = 0u;
  clear_has_consult_id();
}
inline ::google::protobuf::uint32 ConsultTimeout::consult_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultTimeout.consult_id)
  return consult_id_;
}
inline void ConsultTimeout::set_consult_id(::google::protobuf::uint32 value) {
  set_has_consult_id();
  consult_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultTimeout.consult_id)
}

// required uint32 student_id = 2;
inline bool ConsultTimeout::has_student_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConsultTimeout::set_has_student_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConsultTimeout::clear_has_student_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConsultTimeout::clear_student_id() {
  student_id_ = 0u;
  clear_has_student_id();
}
inline ::google::protobuf::uint32 ConsultTimeout::student_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultTimeout.student_id)
  return student_id_;
}
inline void ConsultTimeout::set_student_id(::google::protobuf::uint32 value) {
  set_has_student_id();
  student_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultTimeout.student_id)
}

// required uint32 teacher_id = 3;
inline bool ConsultTimeout::has_teacher_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConsultTimeout::set_has_teacher_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConsultTimeout::clear_has_teacher_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConsultTimeout::clear_teacher_id() {
  teacher_id_ = 0u;
  clear_has_teacher_id();
}
inline ::google::protobuf::uint32 ConsultTimeout::teacher_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultTimeout.teacher_id)
  return teacher_id_;
}
inline void ConsultTimeout::set_teacher_id(::google::protobuf::uint32 value) {
  set_has_teacher_id();
  teacher_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultTimeout.teacher_id)
}

// required uint32 order_id = 4;
inline bool ConsultTimeout::has_order_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConsultTimeout::set_has_order_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConsultTimeout::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConsultTimeout::clear_order_id() {
  order_id_ = 0u;
  clear_has_order_id();
}
inline ::google::protobuf::uint32 ConsultTimeout::order_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultTimeout.order_id)
  return order_id_;
}
inline void ConsultTimeout::set_order_id(::google::protobuf::uint32 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultTimeout.order_id)
}

// required uint32 close_type = 5;
inline bool ConsultTimeout::has_close_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConsultTimeout::set_has_close_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConsultTimeout::clear_has_close_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConsultTimeout::clear_close_type() {
  close_type_ = 0u;
  clear_has_close_type();
}
inline ::google::protobuf::uint32 ConsultTimeout::close_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultTimeout.close_type)
  return close_type_;
}
inline void ConsultTimeout::set_close_type(::google::protobuf::uint32 value) {
  set_has_close_type();
  close_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultTimeout.close_type)
}

// optional bytes script = 6;
inline bool ConsultTimeout::has_script() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConsultTimeout::set_has_script() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConsultTimeout::clear_has_script() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConsultTimeout::clear_script() {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& ConsultTimeout::script() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultTimeout.script)
  return *script_;
}
inline void ConsultTimeout::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultTimeout.script)
}
inline void ConsultTimeout::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.ConsultTimeout.script)
}
inline void ConsultTimeout::set_script(const void* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.ConsultTimeout.script)
}
inline ::std::string* ConsultTimeout::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.ConsultTimeout.script)
  return script_;
}
inline ::std::string* ConsultTimeout::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConsultTimeout::set_allocated_script(::std::string* script) {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_;
  }
  if (script) {
    set_has_script();
    script_ = script;
  } else {
    clear_has_script();
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.ConsultTimeout.script)
}

// optional uint32 service = 7;
inline bool ConsultTimeout::has_service() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConsultTimeout::set_has_service() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConsultTimeout::clear_has_service() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConsultTimeout::clear_service() {
  service_ = 0u;
  clear_has_service();
}
inline ::google::protobuf::uint32 ConsultTimeout::service() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ConsultTimeout.service)
  return service_;
}
inline void ConsultTimeout::set_service(::google::protobuf::uint32 value) {
  set_has_service();
  service_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ConsultTimeout.service)
}

// -------------------------------------------------------------------

// GroupMemberInfo

// required uint32 id = 1;
inline bool GroupMemberInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 GroupMemberInfo::id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberInfo.id)
  return id_;
}
inline void GroupMemberInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberInfo.id)
}

// required uint32 forbidden = 2;
inline bool GroupMemberInfo::has_forbidden() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberInfo::set_has_forbidden() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberInfo::clear_has_forbidden() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberInfo::clear_forbidden() {
  forbidden_ = 0u;
  clear_has_forbidden();
}
inline ::google::protobuf::uint32 GroupMemberInfo::forbidden() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberInfo.forbidden)
  return forbidden_;
}
inline void GroupMemberInfo::set_forbidden(::google::protobuf::uint32 value) {
  set_has_forbidden();
  forbidden_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberInfo.forbidden)
}

// required uint32 member_degree = 3;
inline bool GroupMemberInfo::has_member_degree() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMemberInfo::set_has_member_degree() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMemberInfo::clear_has_member_degree() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMemberInfo::clear_member_degree() {
  member_degree_ = 0u;
  clear_has_member_degree();
}
inline ::google::protobuf::uint32 GroupMemberInfo::member_degree() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberInfo.member_degree)
  return member_degree_;
}
inline void GroupMemberInfo::set_member_degree(::google::protobuf::uint32 value) {
  set_has_member_degree();
  member_degree_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberInfo.member_degree)
}

// required uint32 member_type = 4;
inline bool GroupMemberInfo::has_member_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMemberInfo::set_has_member_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMemberInfo::clear_has_member_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMemberInfo::clear_member_type() {
  member_type_ = 0u;
  clear_has_member_type();
}
inline ::google::protobuf::uint32 GroupMemberInfo::member_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberInfo.member_type)
  return member_type_;
}
inline void GroupMemberInfo::set_member_type(::google::protobuf::uint32 value) {
  set_has_member_type();
  member_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberInfo.member_type)
}

// required uint32 message_cnt = 5;
inline bool GroupMemberInfo::has_message_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMemberInfo::set_has_message_cnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMemberInfo::clear_has_message_cnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMemberInfo::clear_message_cnt() {
  message_cnt_ = 0u;
  clear_has_message_cnt();
}
inline ::google::protobuf::uint32 GroupMemberInfo::message_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberInfo.message_cnt)
  return message_cnt_;
}
inline void GroupMemberInfo::set_message_cnt(::google::protobuf::uint32 value) {
  set_has_message_cnt();
  message_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberInfo.message_cnt)
}

// required string name = 6;
inline bool GroupMemberInfo::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupMemberInfo::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupMemberInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupMemberInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GroupMemberInfo::name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberInfo.name)
  return *name_;
}
inline void GroupMemberInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberInfo.name)
}
inline void GroupMemberInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupMemberInfo.name)
}
inline void GroupMemberInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupMemberInfo.name)
}
inline ::std::string* GroupMemberInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupMemberInfo.name)
  return name_;
}
inline ::std::string* GroupMemberInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupMemberInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupMemberInfo.name)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BaseDefine
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eBaseDefine_2eproto__INCLUDED
