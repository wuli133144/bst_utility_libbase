// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Other.proto

#ifndef PROTOBUF_IM_2eOther_2eproto__INCLUDED
#define PROTOBUF_IM_2eOther_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
#include "IM.RPC.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace Other {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eOther_2eproto();
void protobuf_AssignDesc_IM_2eOther_2eproto();
void protobuf_ShutdownFile_IM_2eOther_2eproto();

class IMHeartBeat;
class IMSingleForbidReq;
class IMSingleForbidResp;
class IMSingleForbidNotify;
class IMSingleGetForbiddenReq;
class IMSingleGetForbiddenResp;
class IMSingleShieldReq;
class IMSingleShieldResp;
class IMSingleGetShieldReq;
class IMSingleGetShieldResp;
class IMGetDeliverMsgReq;
class IMGetDeliverMsgResp;
class TeacherQuqueInfo;
class StudentQuqueInfo;
class IMGetConsultQueueReq;
class IMGetConsultQueueResp;
class DBServerInfo;
class IMOtherGetDbServerCntReq;
class IMOtherGetDbServerCntResp;
class IMOtherSetDbServerCntReq;
class IMOtherSetDbServerCntResp;
class TeacherInfo;
class IMOtherPlatFormGetTeacherInfoReq;
class IMOtherPlatFormGetTeacherInfoResp;
class IMRPCMsgData;

// ===================================================================

class IMHeartBeat : public ::google::protobuf::MessageLite {
 public:
  IMHeartBeat();
  virtual ~IMHeartBeat();

  IMHeartBeat(const IMHeartBeat& from);

  inline IMHeartBeat& operator=(const IMHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMHeartBeat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMHeartBeat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMHeartBeat* other);

  // implements Message ----------------------------------------------

  IMHeartBeat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMHeartBeat& from);
  void MergeFrom(const IMHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:IM.Other.IMHeartBeat)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class IMSingleForbidReq : public ::google::protobuf::MessageLite {
 public:
  IMSingleForbidReq();
  virtual ~IMSingleForbidReq();

  IMSingleForbidReq(const IMSingleForbidReq& from);

  inline IMSingleForbidReq& operator=(const IMSingleForbidReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSingleForbidReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSingleForbidReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSingleForbidReq* other);

  // implements Message ----------------------------------------------

  IMSingleForbidReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSingleForbidReq& from);
  void MergeFrom(const IMSingleForbidReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // required uint32 http_handle = 3;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 3;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMSingleForbidReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_http_handle();
  inline void clear_has_http_handle();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 state_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 http_handle_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMSingleForbidReq* default_instance_;
};
// -------------------------------------------------------------------

class IMSingleForbidResp : public ::google::protobuf::MessageLite {
 public:
  IMSingleForbidResp();
  virtual ~IMSingleForbidResp();

  IMSingleForbidResp(const IMSingleForbidResp& from);

  inline IMSingleForbidResp& operator=(const IMSingleForbidResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSingleForbidResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSingleForbidResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSingleForbidResp* other);

  // implements Message ----------------------------------------------

  IMSingleForbidResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSingleForbidResp& from);
  void MergeFrom(const IMSingleForbidResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // required uint32 http_handle = 3;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 3;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // required uint32 result_code = 4;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 4;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMSingleForbidResp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_http_handle();
  inline void clear_has_http_handle();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 http_handle_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMSingleForbidResp* default_instance_;
};
// -------------------------------------------------------------------

class IMSingleForbidNotify : public ::google::protobuf::MessageLite {
 public:
  IMSingleForbidNotify();
  virtual ~IMSingleForbidNotify();

  IMSingleForbidNotify(const IMSingleForbidNotify& from);

  inline IMSingleForbidNotify& operator=(const IMSingleForbidNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSingleForbidNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSingleForbidNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSingleForbidNotify* other);

  // implements Message ----------------------------------------------

  IMSingleForbidNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSingleForbidNotify& from);
  void MergeFrom(const IMSingleForbidNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMSingleForbidNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 state_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMSingleForbidNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMSingleGetForbiddenReq : public ::google::protobuf::MessageLite {
 public:
  IMSingleGetForbiddenReq();
  virtual ~IMSingleGetForbiddenReq();

  IMSingleGetForbiddenReq(const IMSingleGetForbiddenReq& from);

  inline IMSingleGetForbiddenReq& operator=(const IMSingleGetForbiddenReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSingleGetForbiddenReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSingleGetForbiddenReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSingleGetForbiddenReq* other);

  // implements Message ----------------------------------------------

  IMSingleGetForbiddenReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSingleGetForbiddenReq& from);
  void MergeFrom(const IMSingleGetForbiddenReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMSingleGetForbiddenReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMSingleGetForbiddenReq* default_instance_;
};
// -------------------------------------------------------------------

class IMSingleGetForbiddenResp : public ::google::protobuf::MessageLite {
 public:
  IMSingleGetForbiddenResp();
  virtual ~IMSingleGetForbiddenResp();

  IMSingleGetForbiddenResp(const IMSingleGetForbiddenResp& from);

  inline IMSingleGetForbiddenResp& operator=(const IMSingleGetForbiddenResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSingleGetForbiddenResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSingleGetForbiddenResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSingleGetForbiddenResp* other);

  // implements Message ----------------------------------------------

  IMSingleGetForbiddenResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSingleGetForbiddenResp& from);
  void MergeFrom(const IMSingleGetForbiddenResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // required uint32 result_code = 3;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMSingleGetForbiddenResp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 state_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMSingleGetForbiddenResp* default_instance_;
};
// -------------------------------------------------------------------

class IMSingleShieldReq : public ::google::protobuf::MessageLite {
 public:
  IMSingleShieldReq();
  virtual ~IMSingleShieldReq();

  IMSingleShieldReq(const IMSingleShieldReq& from);

  inline IMSingleShieldReq& operator=(const IMSingleShieldReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSingleShieldReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSingleShieldReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSingleShieldReq* other);

  // implements Message ----------------------------------------------

  IMSingleShieldReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSingleShieldReq& from);
  void MergeFrom(const IMSingleShieldReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 peer_id() const;
  inline void set_peer_id(::google::protobuf::uint32 value);

  // required uint32 state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMSingleShieldReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 peer_id_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMSingleShieldReq* default_instance_;
};
// -------------------------------------------------------------------

class IMSingleShieldResp : public ::google::protobuf::MessageLite {
 public:
  IMSingleShieldResp();
  virtual ~IMSingleShieldResp();

  IMSingleShieldResp(const IMSingleShieldResp& from);

  inline IMSingleShieldResp& operator=(const IMSingleShieldResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSingleShieldResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSingleShieldResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSingleShieldResp* other);

  // implements Message ----------------------------------------------

  IMSingleShieldResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSingleShieldResp& from);
  void MergeFrom(const IMSingleShieldResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 peer_id() const;
  inline void set_peer_id(::google::protobuf::uint32 value);

  // required uint32 state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // required uint32 result_code = 4;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 4;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMSingleShieldResp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 peer_id_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMSingleShieldResp* default_instance_;
};
// -------------------------------------------------------------------

class IMSingleGetShieldReq : public ::google::protobuf::MessageLite {
 public:
  IMSingleGetShieldReq();
  virtual ~IMSingleGetShieldReq();

  IMSingleGetShieldReq(const IMSingleGetShieldReq& from);

  inline IMSingleGetShieldReq& operator=(const IMSingleGetShieldReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSingleGetShieldReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSingleGetShieldReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSingleGetShieldReq* other);

  // implements Message ----------------------------------------------

  IMSingleGetShieldReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSingleGetShieldReq& from);
  void MergeFrom(const IMSingleGetShieldReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 peer_id() const;
  inline void set_peer_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMSingleGetShieldReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 peer_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMSingleGetShieldReq* default_instance_;
};
// -------------------------------------------------------------------

class IMSingleGetShieldResp : public ::google::protobuf::MessageLite {
 public:
  IMSingleGetShieldResp();
  virtual ~IMSingleGetShieldResp();

  IMSingleGetShieldResp(const IMSingleGetShieldResp& from);

  inline IMSingleGetShieldResp& operator=(const IMSingleGetShieldResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSingleGetShieldResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSingleGetShieldResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSingleGetShieldResp* other);

  // implements Message ----------------------------------------------

  IMSingleGetShieldResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSingleGetShieldResp& from);
  void MergeFrom(const IMSingleGetShieldResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 peer_id() const;
  inline void set_peer_id(::google::protobuf::uint32 value);

  // required uint32 state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // required uint32 result_code = 4;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 4;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMSingleGetShieldResp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 peer_id_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMSingleGetShieldResp* default_instance_;
};
// -------------------------------------------------------------------

class IMGetDeliverMsgReq : public ::google::protobuf::MessageLite {
 public:
  IMGetDeliverMsgReq();
  virtual ~IMGetDeliverMsgReq();

  IMGetDeliverMsgReq(const IMGetDeliverMsgReq& from);

  inline IMGetDeliverMsgReq& operator=(const IMGetDeliverMsgReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGetDeliverMsgReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGetDeliverMsgReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGetDeliverMsgReq* other);

  // implements Message ----------------------------------------------

  IMGetDeliverMsgReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGetDeliverMsgReq& from);
  void MergeFrom(const IMGetDeliverMsgReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 old_consult_id = 1;
  inline bool has_old_consult_id() const;
  inline void clear_old_consult_id();
  static const int kOldConsultIdFieldNumber = 1;
  inline ::google::protobuf::uint32 old_consult_id() const;
  inline void set_old_consult_id(::google::protobuf::uint32 value);

  // required uint32 new_consult_id = 2;
  inline bool has_new_consult_id() const;
  inline void clear_new_consult_id();
  static const int kNewConsultIdFieldNumber = 2;
  inline ::google::protobuf::uint32 new_consult_id() const;
  inline void set_new_consult_id(::google::protobuf::uint32 value);

  // required uint32 student_id = 3;
  inline bool has_student_id() const;
  inline void clear_student_id();
  static const int kStudentIdFieldNumber = 3;
  inline ::google::protobuf::uint32 student_id() const;
  inline void set_student_id(::google::protobuf::uint32 value);

  // required uint32 duty_id = 4;
  inline bool has_duty_id() const;
  inline void clear_duty_id();
  static const int kDutyIdFieldNumber = 4;
  inline ::google::protobuf::uint32 duty_id() const;
  inline void set_duty_id(::google::protobuf::uint32 value);

  // required uint32 manager_id = 5;
  inline bool has_manager_id() const;
  inline void clear_manager_id();
  static const int kManagerIdFieldNumber = 5;
  inline ::google::protobuf::uint32 manager_id() const;
  inline void set_manager_id(::google::protobuf::uint32 value);

  // required uint32 order_id = 6;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 6;
  inline ::google::protobuf::uint32 order_id() const;
  inline void set_order_id(::google::protobuf::uint32 value);

  // required uint32 deliver_type = 7;
  inline bool has_deliver_type() const;
  inline void clear_deliver_type();
  static const int kDeliverTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 deliver_type() const;
  inline void set_deliver_type(::google::protobuf::uint32 value);

  // optional string manager_name = 20;
  inline bool has_manager_name() const;
  inline void clear_manager_name();
  static const int kManagerNameFieldNumber = 20;
  inline const ::std::string& manager_name() const;
  inline void set_manager_name(const ::std::string& value);
  inline void set_manager_name(const char* value);
  inline void set_manager_name(const char* value, size_t size);
  inline ::std::string* mutable_manager_name();
  inline ::std::string* release_manager_name();
  inline void set_allocated_manager_name(::std::string* manager_name);

  // optional string manager_portrait = 21;
  inline bool has_manager_portrait() const;
  inline void clear_manager_portrait();
  static const int kManagerPortraitFieldNumber = 21;
  inline const ::std::string& manager_portrait() const;
  inline void set_manager_portrait(const ::std::string& value);
  inline void set_manager_portrait(const char* value);
  inline void set_manager_portrait(const char* value, size_t size);
  inline ::std::string* mutable_manager_portrait();
  inline ::std::string* release_manager_portrait();
  inline void set_allocated_manager_portrait(::std::string* manager_portrait);

  // @@protoc_insertion_point(class_scope:IM.Other.IMGetDeliverMsgReq)
 private:
  inline void set_has_old_consult_id();
  inline void clear_has_old_consult_id();
  inline void set_has_new_consult_id();
  inline void clear_has_new_consult_id();
  inline void set_has_student_id();
  inline void clear_has_student_id();
  inline void set_has_duty_id();
  inline void clear_has_duty_id();
  inline void set_has_manager_id();
  inline void clear_has_manager_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_deliver_type();
  inline void clear_has_deliver_type();
  inline void set_has_manager_name();
  inline void clear_has_manager_name();
  inline void set_has_manager_portrait();
  inline void clear_has_manager_portrait();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 old_consult_id_;
  ::google::protobuf::uint32 new_consult_id_;
  ::google::protobuf::uint32 student_id_;
  ::google::protobuf::uint32 duty_id_;
  ::google::protobuf::uint32 manager_id_;
  ::google::protobuf::uint32 order_id_;
  ::std::string* manager_name_;
  ::std::string* manager_portrait_;
  ::google::protobuf::uint32 deliver_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMGetDeliverMsgReq* default_instance_;
};
// -------------------------------------------------------------------

class IMGetDeliverMsgResp : public ::google::protobuf::MessageLite {
 public:
  IMGetDeliverMsgResp();
  virtual ~IMGetDeliverMsgResp();

  IMGetDeliverMsgResp(const IMGetDeliverMsgResp& from);

  inline IMGetDeliverMsgResp& operator=(const IMGetDeliverMsgResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGetDeliverMsgResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGetDeliverMsgResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGetDeliverMsgResp* other);

  // implements Message ----------------------------------------------

  IMGetDeliverMsgResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGetDeliverMsgResp& from);
  void MergeFrom(const IMGetDeliverMsgResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 old_consult_id = 1;
  inline bool has_old_consult_id() const;
  inline void clear_old_consult_id();
  static const int kOldConsultIdFieldNumber = 1;
  inline ::google::protobuf::uint32 old_consult_id() const;
  inline void set_old_consult_id(::google::protobuf::uint32 value);

  // required uint32 new_consult_id = 2;
  inline bool has_new_consult_id() const;
  inline void clear_new_consult_id();
  static const int kNewConsultIdFieldNumber = 2;
  inline ::google::protobuf::uint32 new_consult_id() const;
  inline void set_new_consult_id(::google::protobuf::uint32 value);

  // required uint32 student_id = 3;
  inline bool has_student_id() const;
  inline void clear_student_id();
  static const int kStudentIdFieldNumber = 3;
  inline ::google::protobuf::uint32 student_id() const;
  inline void set_student_id(::google::protobuf::uint32 value);

  // required uint32 duty_id = 4;
  inline bool has_duty_id() const;
  inline void clear_duty_id();
  static const int kDutyIdFieldNumber = 4;
  inline ::google::protobuf::uint32 duty_id() const;
  inline void set_duty_id(::google::protobuf::uint32 value);

  // required uint32 manager_id = 5;
  inline bool has_manager_id() const;
  inline void clear_manager_id();
  static const int kManagerIdFieldNumber = 5;
  inline ::google::protobuf::uint32 manager_id() const;
  inline void set_manager_id(::google::protobuf::uint32 value);

  // required uint32 order_id = 6;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 6;
  inline ::google::protobuf::uint32 order_id() const;
  inline void set_order_id(::google::protobuf::uint32 value);

  // required uint32 deliver_type = 7;
  inline bool has_deliver_type() const;
  inline void clear_deliver_type();
  static const int kDeliverTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 deliver_type() const;
  inline void set_deliver_type(::google::protobuf::uint32 value);

  // required uint32 result = 8;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 8;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.ConsultMsg consult_msg_list = 9;
  inline int consult_msg_list_size() const;
  inline void clear_consult_msg_list();
  static const int kConsultMsgListFieldNumber = 9;
  inline const ::IM::BaseDefine::ConsultMsg& consult_msg_list(int index) const;
  inline ::IM::BaseDefine::ConsultMsg* mutable_consult_msg_list(int index);
  inline ::IM::BaseDefine::ConsultMsg* add_consult_msg_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ConsultMsg >&
      consult_msg_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ConsultMsg >*
      mutable_consult_msg_list();

  // optional string manager_name = 20;
  inline bool has_manager_name() const;
  inline void clear_manager_name();
  static const int kManagerNameFieldNumber = 20;
  inline const ::std::string& manager_name() const;
  inline void set_manager_name(const ::std::string& value);
  inline void set_manager_name(const char* value);
  inline void set_manager_name(const char* value, size_t size);
  inline ::std::string* mutable_manager_name();
  inline ::std::string* release_manager_name();
  inline void set_allocated_manager_name(::std::string* manager_name);

  // optional string manager_portrait = 21;
  inline bool has_manager_portrait() const;
  inline void clear_manager_portrait();
  static const int kManagerPortraitFieldNumber = 21;
  inline const ::std::string& manager_portrait() const;
  inline void set_manager_portrait(const ::std::string& value);
  inline void set_manager_portrait(const char* value);
  inline void set_manager_portrait(const char* value, size_t size);
  inline ::std::string* mutable_manager_portrait();
  inline ::std::string* release_manager_portrait();
  inline void set_allocated_manager_portrait(::std::string* manager_portrait);

  // @@protoc_insertion_point(class_scope:IM.Other.IMGetDeliverMsgResp)
 private:
  inline void set_has_old_consult_id();
  inline void clear_has_old_consult_id();
  inline void set_has_new_consult_id();
  inline void clear_has_new_consult_id();
  inline void set_has_student_id();
  inline void clear_has_student_id();
  inline void set_has_duty_id();
  inline void clear_has_duty_id();
  inline void set_has_manager_id();
  inline void clear_has_manager_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_deliver_type();
  inline void clear_has_deliver_type();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_manager_name();
  inline void clear_has_manager_name();
  inline void set_has_manager_portrait();
  inline void clear_has_manager_portrait();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 old_consult_id_;
  ::google::protobuf::uint32 new_consult_id_;
  ::google::protobuf::uint32 student_id_;
  ::google::protobuf::uint32 duty_id_;
  ::google::protobuf::uint32 manager_id_;
  ::google::protobuf::uint32 order_id_;
  ::google::protobuf::uint32 deliver_type_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ConsultMsg > consult_msg_list_;
  ::std::string* manager_name_;
  ::std::string* manager_portrait_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMGetDeliverMsgResp* default_instance_;
};
// -------------------------------------------------------------------

class TeacherQuqueInfo : public ::google::protobuf::MessageLite {
 public:
  TeacherQuqueInfo();
  virtual ~TeacherQuqueInfo();

  TeacherQuqueInfo(const TeacherQuqueInfo& from);

  inline TeacherQuqueInfo& operator=(const TeacherQuqueInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TeacherQuqueInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TeacherQuqueInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TeacherQuqueInfo* other);

  // implements Message ----------------------------------------------

  TeacherQuqueInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TeacherQuqueInfo& from);
  void MergeFrom(const TeacherQuqueInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 teacher_id = 1;
  inline bool has_teacher_id() const;
  inline void clear_teacher_id();
  static const int kTeacherIdFieldNumber = 1;
  inline ::google::protobuf::uint32 teacher_id() const;
  inline void set_teacher_id(::google::protobuf::uint32 value);

  // required uint32 teacher_state = 2;
  inline bool has_teacher_state() const;
  inline void clear_teacher_state();
  static const int kTeacherStateFieldNumber = 2;
  inline ::google::protobuf::uint32 teacher_state() const;
  inline void set_teacher_state(::google::protobuf::uint32 value);

  // required uint32 queue_size = 3;
  inline bool has_queue_size() const;
  inline void clear_queue_size();
  static const int kQueueSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 queue_size() const;
  inline void set_queue_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Other.TeacherQuqueInfo)
 private:
  inline void set_has_teacher_id();
  inline void clear_has_teacher_id();
  inline void set_has_teacher_state();
  inline void clear_has_teacher_state();
  inline void set_has_queue_size();
  inline void clear_has_queue_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 teacher_id_;
  ::google::protobuf::uint32 teacher_state_;
  ::google::protobuf::uint32 queue_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static TeacherQuqueInfo* default_instance_;
};
// -------------------------------------------------------------------

class StudentQuqueInfo : public ::google::protobuf::MessageLite {
 public:
  StudentQuqueInfo();
  virtual ~StudentQuqueInfo();

  StudentQuqueInfo(const StudentQuqueInfo& from);

  inline StudentQuqueInfo& operator=(const StudentQuqueInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const StudentQuqueInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StudentQuqueInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StudentQuqueInfo* other);

  // implements Message ----------------------------------------------

  StudentQuqueInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StudentQuqueInfo& from);
  void MergeFrom(const StudentQuqueInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 student_id = 1;
  inline bool has_student_id() const;
  inline void clear_student_id();
  static const int kStudentIdFieldNumber = 1;
  inline ::google::protobuf::uint32 student_id() const;
  inline void set_student_id(::google::protobuf::uint32 value);

  // required uint32 teacher_id = 2;
  inline bool has_teacher_id() const;
  inline void clear_teacher_id();
  static const int kTeacherIdFieldNumber = 2;
  inline ::google::protobuf::uint32 teacher_id() const;
  inline void set_teacher_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Other.StudentQuqueInfo)
 private:
  inline void set_has_student_id();
  inline void clear_has_student_id();
  inline void set_has_teacher_id();
  inline void clear_has_teacher_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 student_id_;
  ::google::protobuf::uint32 teacher_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static StudentQuqueInfo* default_instance_;
};
// -------------------------------------------------------------------

class IMGetConsultQueueReq : public ::google::protobuf::MessageLite {
 public:
  IMGetConsultQueueReq();
  virtual ~IMGetConsultQueueReq();

  IMGetConsultQueueReq(const IMGetConsultQueueReq& from);

  inline IMGetConsultQueueReq& operator=(const IMGetConsultQueueReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGetConsultQueueReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGetConsultQueueReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGetConsultQueueReq* other);

  // implements Message ----------------------------------------------

  IMGetConsultQueueReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGetConsultQueueReq& from);
  void MergeFrom(const IMGetConsultQueueReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 http_handle = 1;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Other.IMGetConsultQueueReq)
 private:
  inline void set_has_http_handle();
  inline void clear_has_http_handle();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 http_handle_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMGetConsultQueueReq* default_instance_;
};
// -------------------------------------------------------------------

class IMGetConsultQueueResp : public ::google::protobuf::MessageLite {
 public:
  IMGetConsultQueueResp();
  virtual ~IMGetConsultQueueResp();

  IMGetConsultQueueResp(const IMGetConsultQueueResp& from);

  inline IMGetConsultQueueResp& operator=(const IMGetConsultQueueResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGetConsultQueueResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGetConsultQueueResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGetConsultQueueResp* other);

  // implements Message ----------------------------------------------

  IMGetConsultQueueResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGetConsultQueueResp& from);
  void MergeFrom(const IMGetConsultQueueResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 teacher_map_size = 1;
  inline bool has_teacher_map_size() const;
  inline void clear_teacher_map_size();
  static const int kTeacherMapSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 teacher_map_size() const;
  inline void set_teacher_map_size(::google::protobuf::uint32 value);

  // required uint32 online_teacher_size = 2;
  inline bool has_online_teacher_size() const;
  inline void clear_online_teacher_size();
  static const int kOnlineTeacherSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 online_teacher_size() const;
  inline void set_online_teacher_size(::google::protobuf::uint32 value);

  // required uint32 offline_teacher_size = 3;
  inline bool has_offline_teacher_size() const;
  inline void clear_offline_teacher_size();
  static const int kOfflineTeacherSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 offline_teacher_size() const;
  inline void set_offline_teacher_size(::google::protobuf::uint32 value);

  // required uint32 leave_teacher_size = 4;
  inline bool has_leave_teacher_size() const;
  inline void clear_leave_teacher_size();
  static const int kLeaveTeacherSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 leave_teacher_size() const;
  inline void set_leave_teacher_size(::google::protobuf::uint32 value);

  // required uint32 has_queue_teacher_size = 5;
  inline bool has_has_queue_teacher_size() const;
  inline void clear_has_queue_teacher_size();
  static const int kHasQueueTeacherSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 has_queue_teacher_size() const;
  inline void set_has_queue_teacher_size(::google::protobuf::uint32 value);

  // required uint32 inqueue_student_size_from_teacher = 6;
  inline bool has_inqueue_student_size_from_teacher() const;
  inline void clear_inqueue_student_size_from_teacher();
  static const int kInqueueStudentSizeFromTeacherFieldNumber = 6;
  inline ::google::protobuf::uint32 inqueue_student_size_from_teacher() const;
  inline void set_inqueue_student_size_from_teacher(::google::protobuf::uint32 value);

  // repeated .IM.Other.TeacherQuqueInfo teacher_queue_info = 7;
  inline int teacher_queue_info_size() const;
  inline void clear_teacher_queue_info();
  static const int kTeacherQueueInfoFieldNumber = 7;
  inline const ::IM::Other::TeacherQuqueInfo& teacher_queue_info(int index) const;
  inline ::IM::Other::TeacherQuqueInfo* mutable_teacher_queue_info(int index);
  inline ::IM::Other::TeacherQuqueInfo* add_teacher_queue_info();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherQuqueInfo >&
      teacher_queue_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherQuqueInfo >*
      mutable_teacher_queue_info();

  // required uint32 inqueue_student_size_from_student = 8;
  inline bool has_inqueue_student_size_from_student() const;
  inline void clear_inqueue_student_size_from_student();
  static const int kInqueueStudentSizeFromStudentFieldNumber = 8;
  inline ::google::protobuf::uint32 inqueue_student_size_from_student() const;
  inline void set_inqueue_student_size_from_student(::google::protobuf::uint32 value);

  // repeated .IM.Other.StudentQuqueInfo student_queue_info = 9;
  inline int student_queue_info_size() const;
  inline void clear_student_queue_info();
  static const int kStudentQueueInfoFieldNumber = 9;
  inline const ::IM::Other::StudentQuqueInfo& student_queue_info(int index) const;
  inline ::IM::Other::StudentQuqueInfo* mutable_student_queue_info(int index);
  inline ::IM::Other::StudentQuqueInfo* add_student_queue_info();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Other::StudentQuqueInfo >&
      student_queue_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Other::StudentQuqueInfo >*
      mutable_student_queue_info();

  // required uint32 http_handle = 10;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 10;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Other.IMGetConsultQueueResp)
 private:
  inline void set_has_teacher_map_size();
  inline void clear_has_teacher_map_size();
  inline void set_has_online_teacher_size();
  inline void clear_has_online_teacher_size();
  inline void set_has_offline_teacher_size();
  inline void clear_has_offline_teacher_size();
  inline void set_has_leave_teacher_size();
  inline void clear_has_leave_teacher_size();
  inline void set_has_has_queue_teacher_size();
  inline void clear_has_has_queue_teacher_size();
  inline void set_has_inqueue_student_size_from_teacher();
  inline void clear_has_inqueue_student_size_from_teacher();
  inline void set_has_inqueue_student_size_from_student();
  inline void clear_has_inqueue_student_size_from_student();
  inline void set_has_http_handle();
  inline void clear_has_http_handle();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 teacher_map_size_;
  ::google::protobuf::uint32 online_teacher_size_;
  ::google::protobuf::uint32 offline_teacher_size_;
  ::google::protobuf::uint32 leave_teacher_size_;
  ::google::protobuf::uint32 has_queue_teacher_size_;
  ::google::protobuf::uint32 inqueue_student_size_from_teacher_;
  ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherQuqueInfo > teacher_queue_info_;
  ::google::protobuf::RepeatedPtrField< ::IM::Other::StudentQuqueInfo > student_queue_info_;
  ::google::protobuf::uint32 inqueue_student_size_from_student_;
  ::google::protobuf::uint32 http_handle_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMGetConsultQueueResp* default_instance_;
};
// -------------------------------------------------------------------

class DBServerInfo : public ::google::protobuf::MessageLite {
 public:
  DBServerInfo();
  virtual ~DBServerInfo();

  DBServerInfo(const DBServerInfo& from);

  inline DBServerInfo& operator=(const DBServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DBServerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DBServerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DBServerInfo* other);

  // implements Message ----------------------------------------------

  DBServerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DBServerInfo& from);
  void MergeFrom(const DBServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Other.DBServerInfo)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static DBServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class IMOtherGetDbServerCntReq : public ::google::protobuf::MessageLite {
 public:
  IMOtherGetDbServerCntReq();
  virtual ~IMOtherGetDbServerCntReq();

  IMOtherGetDbServerCntReq(const IMOtherGetDbServerCntReq& from);

  inline IMOtherGetDbServerCntReq& operator=(const IMOtherGetDbServerCntReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMOtherGetDbServerCntReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMOtherGetDbServerCntReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMOtherGetDbServerCntReq* other);

  // implements Message ----------------------------------------------

  IMOtherGetDbServerCntReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMOtherGetDbServerCntReq& from);
  void MergeFrom(const IMOtherGetDbServerCntReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 http_handle = 1;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMOtherGetDbServerCntReq)
 private:
  inline void set_has_http_handle();
  inline void clear_has_http_handle();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 http_handle_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMOtherGetDbServerCntReq* default_instance_;
};
// -------------------------------------------------------------------

class IMOtherGetDbServerCntResp : public ::google::protobuf::MessageLite {
 public:
  IMOtherGetDbServerCntResp();
  virtual ~IMOtherGetDbServerCntResp();

  IMOtherGetDbServerCntResp(const IMOtherGetDbServerCntResp& from);

  inline IMOtherGetDbServerCntResp& operator=(const IMOtherGetDbServerCntResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMOtherGetDbServerCntResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMOtherGetDbServerCntResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMOtherGetDbServerCntResp* other);

  // implements Message ----------------------------------------------

  IMOtherGetDbServerCntResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMOtherGetDbServerCntResp& from);
  void MergeFrom(const IMOtherGetDbServerCntResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 http_handle = 1;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // required uint32 db_server_login_count = 2;
  inline bool has_db_server_login_count() const;
  inline void clear_db_server_login_count();
  static const int kDbServerLoginCountFieldNumber = 2;
  inline ::google::protobuf::uint32 db_server_login_count() const;
  inline void set_db_server_login_count(::google::protobuf::uint32 value);

  // required uint32 db_server_count = 3;
  inline bool has_db_server_count() const;
  inline void clear_db_server_count();
  static const int kDbServerCountFieldNumber = 3;
  inline ::google::protobuf::uint32 db_server_count() const;
  inline void set_db_server_count(::google::protobuf::uint32 value);

  // required uint32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // repeated .IM.Other.DBServerInfo db_server_info_list = 5;
  inline int db_server_info_list_size() const;
  inline void clear_db_server_info_list();
  static const int kDbServerInfoListFieldNumber = 5;
  inline const ::IM::Other::DBServerInfo& db_server_info_list(int index) const;
  inline ::IM::Other::DBServerInfo* mutable_db_server_info_list(int index);
  inline ::IM::Other::DBServerInfo* add_db_server_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Other::DBServerInfo >&
      db_server_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Other::DBServerInfo >*
      mutable_db_server_info_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMOtherGetDbServerCntResp)
 private:
  inline void set_has_http_handle();
  inline void clear_has_http_handle();
  inline void set_has_db_server_login_count();
  inline void clear_has_db_server_login_count();
  inline void set_has_db_server_count();
  inline void clear_has_db_server_count();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 http_handle_;
  ::google::protobuf::uint32 db_server_login_count_;
  ::google::protobuf::uint32 db_server_count_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::RepeatedPtrField< ::IM::Other::DBServerInfo > db_server_info_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMOtherGetDbServerCntResp* default_instance_;
};
// -------------------------------------------------------------------

class IMOtherSetDbServerCntReq : public ::google::protobuf::MessageLite {
 public:
  IMOtherSetDbServerCntReq();
  virtual ~IMOtherSetDbServerCntReq();

  IMOtherSetDbServerCntReq(const IMOtherSetDbServerCntReq& from);

  inline IMOtherSetDbServerCntReq& operator=(const IMOtherSetDbServerCntReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMOtherSetDbServerCntReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMOtherSetDbServerCntReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMOtherSetDbServerCntReq* other);

  // implements Message ----------------------------------------------

  IMOtherSetDbServerCntReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMOtherSetDbServerCntReq& from);
  void MergeFrom(const IMOtherSetDbServerCntReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 http_handle = 1;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // required uint32 db_server_login_count = 2;
  inline bool has_db_server_login_count() const;
  inline void clear_db_server_login_count();
  static const int kDbServerLoginCountFieldNumber = 2;
  inline ::google::protobuf::uint32 db_server_login_count() const;
  inline void set_db_server_login_count(::google::protobuf::uint32 value);

  // required uint32 db_server_count = 3;
  inline bool has_db_server_count() const;
  inline void clear_db_server_count();
  static const int kDbServerCountFieldNumber = 3;
  inline ::google::protobuf::uint32 db_server_count() const;
  inline void set_db_server_count(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMOtherSetDbServerCntReq)
 private:
  inline void set_has_http_handle();
  inline void clear_has_http_handle();
  inline void set_has_db_server_login_count();
  inline void clear_has_db_server_login_count();
  inline void set_has_db_server_count();
  inline void clear_has_db_server_count();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 http_handle_;
  ::google::protobuf::uint32 db_server_login_count_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 db_server_count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMOtherSetDbServerCntReq* default_instance_;
};
// -------------------------------------------------------------------

class IMOtherSetDbServerCntResp : public ::google::protobuf::MessageLite {
 public:
  IMOtherSetDbServerCntResp();
  virtual ~IMOtherSetDbServerCntResp();

  IMOtherSetDbServerCntResp(const IMOtherSetDbServerCntResp& from);

  inline IMOtherSetDbServerCntResp& operator=(const IMOtherSetDbServerCntResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMOtherSetDbServerCntResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMOtherSetDbServerCntResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMOtherSetDbServerCntResp* other);

  // implements Message ----------------------------------------------

  IMOtherSetDbServerCntResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMOtherSetDbServerCntResp& from);
  void MergeFrom(const IMOtherSetDbServerCntResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 http_handle = 1;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // required uint32 db_server_login_count = 2;
  inline bool has_db_server_login_count() const;
  inline void clear_db_server_login_count();
  static const int kDbServerLoginCountFieldNumber = 2;
  inline ::google::protobuf::uint32 db_server_login_count() const;
  inline void set_db_server_login_count(::google::protobuf::uint32 value);

  // required uint32 db_server_count = 3;
  inline bool has_db_server_count() const;
  inline void clear_db_server_count();
  static const int kDbServerCountFieldNumber = 3;
  inline ::google::protobuf::uint32 db_server_count() const;
  inline void set_db_server_count(::google::protobuf::uint32 value);

  // required uint32 result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMOtherSetDbServerCntResp)
 private:
  inline void set_has_http_handle();
  inline void clear_has_http_handle();
  inline void set_has_db_server_login_count();
  inline void clear_has_db_server_login_count();
  inline void set_has_db_server_count();
  inline void clear_has_db_server_count();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 http_handle_;
  ::google::protobuf::uint32 db_server_login_count_;
  ::google::protobuf::uint32 db_server_count_;
  ::google::protobuf::uint32 result_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMOtherSetDbServerCntResp* default_instance_;
};
// -------------------------------------------------------------------

class TeacherInfo : public ::google::protobuf::MessageLite {
 public:
  TeacherInfo();
  virtual ~TeacherInfo();

  TeacherInfo(const TeacherInfo& from);

  inline TeacherInfo& operator=(const TeacherInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TeacherInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TeacherInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TeacherInfo* other);

  // implements Message ----------------------------------------------

  TeacherInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TeacherInfo& from);
  void MergeFrom(const TeacherInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 online_stat = 2;
  inline bool has_online_stat() const;
  inline void clear_online_stat();
  static const int kOnlineStatFieldNumber = 2;
  inline ::google::protobuf::uint32 online_stat() const;
  inline void set_online_stat(::google::protobuf::uint32 value);

  // required uint32 queue_cnt = 3;
  inline bool has_queue_cnt() const;
  inline void clear_queue_cnt();
  static const int kQueueCntFieldNumber = 3;
  inline ::google::protobuf::uint32 queue_cnt() const;
  inline void set_queue_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Other.TeacherInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_online_stat();
  inline void clear_has_online_stat();
  inline void set_has_queue_cnt();
  inline void clear_has_queue_cnt();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 online_stat_;
  ::google::protobuf::uint32 queue_cnt_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static TeacherInfo* default_instance_;
};
// -------------------------------------------------------------------

class IMOtherPlatFormGetTeacherInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMOtherPlatFormGetTeacherInfoReq();
  virtual ~IMOtherPlatFormGetTeacherInfoReq();

  IMOtherPlatFormGetTeacherInfoReq(const IMOtherPlatFormGetTeacherInfoReq& from);

  inline IMOtherPlatFormGetTeacherInfoReq& operator=(const IMOtherPlatFormGetTeacherInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMOtherPlatFormGetTeacherInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMOtherPlatFormGetTeacherInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMOtherPlatFormGetTeacherInfoReq* other);

  // implements Message ----------------------------------------------

  IMOtherPlatFormGetTeacherInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMOtherPlatFormGetTeacherInfoReq& from);
  void MergeFrom(const IMOtherPlatFormGetTeacherInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 http_handle = 1;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // repeated uint32 teacher_id_list = 2;
  inline int teacher_id_list_size() const;
  inline void clear_teacher_id_list();
  static const int kTeacherIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 teacher_id_list(int index) const;
  inline void set_teacher_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_teacher_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      teacher_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_teacher_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMOtherPlatFormGetTeacherInfoReq)
 private:
  inline void set_has_http_handle();
  inline void clear_has_http_handle();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > teacher_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 http_handle_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMOtherPlatFormGetTeacherInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMOtherPlatFormGetTeacherInfoResp : public ::google::protobuf::MessageLite {
 public:
  IMOtherPlatFormGetTeacherInfoResp();
  virtual ~IMOtherPlatFormGetTeacherInfoResp();

  IMOtherPlatFormGetTeacherInfoResp(const IMOtherPlatFormGetTeacherInfoResp& from);

  inline IMOtherPlatFormGetTeacherInfoResp& operator=(const IMOtherPlatFormGetTeacherInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMOtherPlatFormGetTeacherInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMOtherPlatFormGetTeacherInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMOtherPlatFormGetTeacherInfoResp* other);

  // implements Message ----------------------------------------------

  IMOtherPlatFormGetTeacherInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMOtherPlatFormGetTeacherInfoResp& from);
  void MergeFrom(const IMOtherPlatFormGetTeacherInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 http_handle = 1;
  inline bool has_http_handle() const;
  inline void clear_http_handle();
  static const int kHttpHandleFieldNumber = 1;
  inline ::google::protobuf::uint32 http_handle() const;
  inline void set_http_handle(::google::protobuf::uint32 value);

  // repeated .IM.Other.TeacherInfo teacher_info_list = 2;
  inline int teacher_info_list_size() const;
  inline void clear_teacher_info_list();
  static const int kTeacherInfoListFieldNumber = 2;
  inline const ::IM::Other::TeacherInfo& teacher_info_list(int index) const;
  inline ::IM::Other::TeacherInfo* mutable_teacher_info_list(int index);
  inline ::IM::Other::TeacherInfo* add_teacher_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherInfo >&
      teacher_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherInfo >*
      mutable_teacher_info_list();

  // required uint32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMOtherPlatFormGetTeacherInfoResp)
 private:
  inline void set_has_http_handle();
  inline void clear_has_http_handle();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherInfo > teacher_info_list_;
  ::google::protobuf::uint32 http_handle_;
  ::google::protobuf::uint32 result_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMOtherPlatFormGetTeacherInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class IMRPCMsgData : public ::google::protobuf::MessageLite {
 public:
  IMRPCMsgData();
  virtual ~IMRPCMsgData();

  IMRPCMsgData(const IMRPCMsgData& from);

  inline IMRPCMsgData& operator=(const IMRPCMsgData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRPCMsgData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRPCMsgData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRPCMsgData* other);

  // implements Message ----------------------------------------------

  IMRPCMsgData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRPCMsgData& from);
  void MergeFrom(const IMRPCMsgData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string user_portrait = 3;
  inline bool has_user_portrait() const;
  inline void clear_user_portrait();
  static const int kUserPortraitFieldNumber = 3;
  inline const ::std::string& user_portrait() const;
  inline void set_user_portrait(const ::std::string& value);
  inline void set_user_portrait(const char* value);
  inline void set_user_portrait(const char* value, size_t size);
  inline ::std::string* mutable_user_portrait();
  inline ::std::string* release_user_portrait();
  inline void set_allocated_user_portrait(::std::string* user_portrait);

  // required uint32 user_im_id = 4;
  inline bool has_user_im_id() const;
  inline void clear_user_im_id();
  static const int kUserImIdFieldNumber = 4;
  inline ::google::protobuf::uint32 user_im_id() const;
  inline void set_user_im_id(::google::protobuf::uint32 value);

  // required uint32 msg_type = 5;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 msg_type() const;
  inline void set_msg_type(::google::protobuf::uint32 value);

  // required bytes msg_data = 6;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 6;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // required uint32 create_time = 7;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 8;
  inline int group_msg_res_list_size() const;
  inline void clear_group_msg_res_list();
  static const int kGroupMsgResListFieldNumber = 8;
  inline const ::IM::RPC::GroupMsgRes& group_msg_res_list(int index) const;
  inline ::IM::RPC::GroupMsgRes* mutable_group_msg_res_list(int index);
  inline ::IM::RPC::GroupMsgRes* add_group_msg_res_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >&
      group_msg_res_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >*
      mutable_group_msg_res_list();

  // required .IM.RPC.TarsInfo tars_info = 9;
  inline bool has_tars_info() const;
  inline void clear_tars_info();
  static const int kTarsInfoFieldNumber = 9;
  inline const ::IM::RPC::TarsInfo& tars_info() const;
  inline ::IM::RPC::TarsInfo* mutable_tars_info();
  inline ::IM::RPC::TarsInfo* release_tars_info();
  inline void set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info);

  // repeated .IM.BaseDefine.GroupMsgInfo msgs_info_list = 10;
  inline int msgs_info_list_size() const;
  inline void clear_msgs_info_list();
  static const int kMsgsInfoListFieldNumber = 10;
  inline const ::IM::BaseDefine::GroupMsgInfo& msgs_info_list(int index) const;
  inline ::IM::BaseDefine::GroupMsgInfo* mutable_msgs_info_list(int index);
  inline ::IM::BaseDefine::GroupMsgInfo* add_msgs_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupMsgInfo >&
      msgs_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupMsgInfo >*
      mutable_msgs_info_list();

  // required uint32 result = 11;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 11;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Other.IMRPCMsgData)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_portrait();
  inline void clear_has_user_portrait();
  inline void set_has_user_im_id();
  inline void clear_has_user_im_id();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_tars_info();
  inline void clear_has_tars_info();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 user_im_id_;
  ::std::string* user_portrait_;
  ::std::string* msg_data_;
  ::google::protobuf::uint32 msg_type_;
  ::google::protobuf::uint32 create_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes > group_msg_res_list_;
  ::IM::RPC::TarsInfo* tars_info_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupMsgInfo > msgs_info_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eOther_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eOther_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eOther_2eproto();
  friend void protobuf_ShutdownFile_IM_2eOther_2eproto();

  void InitAsDefaultInstance();
  static IMRPCMsgData* default_instance_;
};
// ===================================================================


// ===================================================================

// IMHeartBeat

// -------------------------------------------------------------------

// IMSingleForbidReq

// required uint32 user_id = 1;
inline bool IMSingleForbidReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSingleForbidReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSingleForbidReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSingleForbidReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSingleForbidReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidReq.user_id)
  return user_id_;
}
inline void IMSingleForbidReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidReq.user_id)
}

// required uint32 state = 2;
inline bool IMSingleForbidReq::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSingleForbidReq::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSingleForbidReq::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSingleForbidReq::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 IMSingleForbidReq::state() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidReq.state)
  return state_;
}
inline void IMSingleForbidReq::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidReq.state)
}

// required uint32 http_handle = 3;
inline bool IMSingleForbidReq::has_http_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSingleForbidReq::set_has_http_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSingleForbidReq::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSingleForbidReq::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMSingleForbidReq::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidReq.http_handle)
  return http_handle_;
}
inline void IMSingleForbidReq::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidReq.http_handle)
}

// optional bytes attach_data = 20;
inline bool IMSingleForbidReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMSingleForbidReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMSingleForbidReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMSingleForbidReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSingleForbidReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidReq.attach_data)
  return *attach_data_;
}
inline void IMSingleForbidReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidReq.attach_data)
}
inline void IMSingleForbidReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMSingleForbidReq.attach_data)
}
inline void IMSingleForbidReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMSingleForbidReq.attach_data)
}
inline ::std::string* IMSingleForbidReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMSingleForbidReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMSingleForbidReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSingleForbidReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMSingleForbidReq.attach_data)
}

// -------------------------------------------------------------------

// IMSingleForbidResp

// required uint32 user_id = 1;
inline bool IMSingleForbidResp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSingleForbidResp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSingleForbidResp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSingleForbidResp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSingleForbidResp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidResp.user_id)
  return user_id_;
}
inline void IMSingleForbidResp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidResp.user_id)
}

// required uint32 state = 2;
inline bool IMSingleForbidResp::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSingleForbidResp::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSingleForbidResp::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSingleForbidResp::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 IMSingleForbidResp::state() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidResp.state)
  return state_;
}
inline void IMSingleForbidResp::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidResp.state)
}

// required uint32 http_handle = 3;
inline bool IMSingleForbidResp::has_http_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSingleForbidResp::set_has_http_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSingleForbidResp::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSingleForbidResp::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMSingleForbidResp::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidResp.http_handle)
  return http_handle_;
}
inline void IMSingleForbidResp::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidResp.http_handle)
}

// required uint32 result_code = 4;
inline bool IMSingleForbidResp::has_result_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMSingleForbidResp::set_has_result_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMSingleForbidResp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMSingleForbidResp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMSingleForbidResp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidResp.result_code)
  return result_code_;
}
inline void IMSingleForbidResp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidResp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMSingleForbidResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMSingleForbidResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMSingleForbidResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMSingleForbidResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSingleForbidResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidResp.attach_data)
  return *attach_data_;
}
inline void IMSingleForbidResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidResp.attach_data)
}
inline void IMSingleForbidResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMSingleForbidResp.attach_data)
}
inline void IMSingleForbidResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMSingleForbidResp.attach_data)
}
inline ::std::string* IMSingleForbidResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMSingleForbidResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMSingleForbidResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSingleForbidResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMSingleForbidResp.attach_data)
}

// -------------------------------------------------------------------

// IMSingleForbidNotify

// required uint32 user_id = 1;
inline bool IMSingleForbidNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSingleForbidNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSingleForbidNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSingleForbidNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSingleForbidNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidNotify.user_id)
  return user_id_;
}
inline void IMSingleForbidNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidNotify.user_id)
}

// required uint32 state = 2;
inline bool IMSingleForbidNotify::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSingleForbidNotify::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSingleForbidNotify::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSingleForbidNotify::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 IMSingleForbidNotify::state() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidNotify.state)
  return state_;
}
inline void IMSingleForbidNotify::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidNotify.state)
}

// optional bytes attach_data = 20;
inline bool IMSingleForbidNotify::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSingleForbidNotify::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSingleForbidNotify::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSingleForbidNotify::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSingleForbidNotify::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleForbidNotify.attach_data)
  return *attach_data_;
}
inline void IMSingleForbidNotify::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleForbidNotify.attach_data)
}
inline void IMSingleForbidNotify::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMSingleForbidNotify.attach_data)
}
inline void IMSingleForbidNotify::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMSingleForbidNotify.attach_data)
}
inline ::std::string* IMSingleForbidNotify::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMSingleForbidNotify.attach_data)
  return attach_data_;
}
inline ::std::string* IMSingleForbidNotify::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSingleForbidNotify::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMSingleForbidNotify.attach_data)
}

// -------------------------------------------------------------------

// IMSingleGetForbiddenReq

// required uint32 user_id = 1;
inline bool IMSingleGetForbiddenReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSingleGetForbiddenReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSingleGetForbiddenReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSingleGetForbiddenReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSingleGetForbiddenReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetForbiddenReq.user_id)
  return user_id_;
}
inline void IMSingleGetForbiddenReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetForbiddenReq.user_id)
}

// optional bytes attach_data = 20;
inline bool IMSingleGetForbiddenReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSingleGetForbiddenReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSingleGetForbiddenReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSingleGetForbiddenReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSingleGetForbiddenReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetForbiddenReq.attach_data)
  return *attach_data_;
}
inline void IMSingleGetForbiddenReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetForbiddenReq.attach_data)
}
inline void IMSingleGetForbiddenReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMSingleGetForbiddenReq.attach_data)
}
inline void IMSingleGetForbiddenReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMSingleGetForbiddenReq.attach_data)
}
inline ::std::string* IMSingleGetForbiddenReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMSingleGetForbiddenReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMSingleGetForbiddenReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSingleGetForbiddenReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMSingleGetForbiddenReq.attach_data)
}

// -------------------------------------------------------------------

// IMSingleGetForbiddenResp

// required uint32 user_id = 1;
inline bool IMSingleGetForbiddenResp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSingleGetForbiddenResp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSingleGetForbiddenResp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSingleGetForbiddenResp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSingleGetForbiddenResp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetForbiddenResp.user_id)
  return user_id_;
}
inline void IMSingleGetForbiddenResp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetForbiddenResp.user_id)
}

// required uint32 state = 2;
inline bool IMSingleGetForbiddenResp::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSingleGetForbiddenResp::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSingleGetForbiddenResp::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSingleGetForbiddenResp::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 IMSingleGetForbiddenResp::state() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetForbiddenResp.state)
  return state_;
}
inline void IMSingleGetForbiddenResp::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetForbiddenResp.state)
}

// required uint32 result_code = 3;
inline bool IMSingleGetForbiddenResp::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSingleGetForbiddenResp::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSingleGetForbiddenResp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSingleGetForbiddenResp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMSingleGetForbiddenResp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetForbiddenResp.result_code)
  return result_code_;
}
inline void IMSingleGetForbiddenResp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetForbiddenResp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMSingleGetForbiddenResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMSingleGetForbiddenResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMSingleGetForbiddenResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMSingleGetForbiddenResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSingleGetForbiddenResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetForbiddenResp.attach_data)
  return *attach_data_;
}
inline void IMSingleGetForbiddenResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetForbiddenResp.attach_data)
}
inline void IMSingleGetForbiddenResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMSingleGetForbiddenResp.attach_data)
}
inline void IMSingleGetForbiddenResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMSingleGetForbiddenResp.attach_data)
}
inline ::std::string* IMSingleGetForbiddenResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMSingleGetForbiddenResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMSingleGetForbiddenResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSingleGetForbiddenResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMSingleGetForbiddenResp.attach_data)
}

// -------------------------------------------------------------------

// IMSingleShieldReq

// required uint32 user_id = 1;
inline bool IMSingleShieldReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSingleShieldReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSingleShieldReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSingleShieldReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSingleShieldReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleShieldReq.user_id)
  return user_id_;
}
inline void IMSingleShieldReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleShieldReq.user_id)
}

// required uint32 peer_id = 2;
inline bool IMSingleShieldReq::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSingleShieldReq::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSingleShieldReq::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSingleShieldReq::clear_peer_id() {
  peer_id_ = 0u;
  clear_has_peer_id();
}
inline ::google::protobuf::uint32 IMSingleShieldReq::peer_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleShieldReq.peer_id)
  return peer_id_;
}
inline void IMSingleShieldReq::set_peer_id(::google::protobuf::uint32 value) {
  set_has_peer_id();
  peer_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleShieldReq.peer_id)
}

// required uint32 state = 3;
inline bool IMSingleShieldReq::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSingleShieldReq::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSingleShieldReq::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSingleShieldReq::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 IMSingleShieldReq::state() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleShieldReq.state)
  return state_;
}
inline void IMSingleShieldReq::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleShieldReq.state)
}

// optional bytes attach_data = 20;
inline bool IMSingleShieldReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMSingleShieldReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMSingleShieldReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMSingleShieldReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSingleShieldReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleShieldReq.attach_data)
  return *attach_data_;
}
inline void IMSingleShieldReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleShieldReq.attach_data)
}
inline void IMSingleShieldReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMSingleShieldReq.attach_data)
}
inline void IMSingleShieldReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMSingleShieldReq.attach_data)
}
inline ::std::string* IMSingleShieldReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMSingleShieldReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMSingleShieldReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSingleShieldReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMSingleShieldReq.attach_data)
}

// -------------------------------------------------------------------

// IMSingleShieldResp

// required uint32 user_id = 1;
inline bool IMSingleShieldResp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSingleShieldResp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSingleShieldResp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSingleShieldResp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSingleShieldResp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleShieldResp.user_id)
  return user_id_;
}
inline void IMSingleShieldResp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleShieldResp.user_id)
}

// required uint32 peer_id = 2;
inline bool IMSingleShieldResp::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSingleShieldResp::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSingleShieldResp::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSingleShieldResp::clear_peer_id() {
  peer_id_ = 0u;
  clear_has_peer_id();
}
inline ::google::protobuf::uint32 IMSingleShieldResp::peer_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleShieldResp.peer_id)
  return peer_id_;
}
inline void IMSingleShieldResp::set_peer_id(::google::protobuf::uint32 value) {
  set_has_peer_id();
  peer_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleShieldResp.peer_id)
}

// required uint32 state = 3;
inline bool IMSingleShieldResp::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSingleShieldResp::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSingleShieldResp::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSingleShieldResp::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 IMSingleShieldResp::state() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleShieldResp.state)
  return state_;
}
inline void IMSingleShieldResp::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleShieldResp.state)
}

// required uint32 result_code = 4;
inline bool IMSingleShieldResp::has_result_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMSingleShieldResp::set_has_result_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMSingleShieldResp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMSingleShieldResp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMSingleShieldResp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleShieldResp.result_code)
  return result_code_;
}
inline void IMSingleShieldResp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleShieldResp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMSingleShieldResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMSingleShieldResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMSingleShieldResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMSingleShieldResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSingleShieldResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleShieldResp.attach_data)
  return *attach_data_;
}
inline void IMSingleShieldResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleShieldResp.attach_data)
}
inline void IMSingleShieldResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMSingleShieldResp.attach_data)
}
inline void IMSingleShieldResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMSingleShieldResp.attach_data)
}
inline ::std::string* IMSingleShieldResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMSingleShieldResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMSingleShieldResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSingleShieldResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMSingleShieldResp.attach_data)
}

// -------------------------------------------------------------------

// IMSingleGetShieldReq

// required uint32 user_id = 1;
inline bool IMSingleGetShieldReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSingleGetShieldReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSingleGetShieldReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSingleGetShieldReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSingleGetShieldReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetShieldReq.user_id)
  return user_id_;
}
inline void IMSingleGetShieldReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetShieldReq.user_id)
}

// required uint32 peer_id = 2;
inline bool IMSingleGetShieldReq::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSingleGetShieldReq::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSingleGetShieldReq::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSingleGetShieldReq::clear_peer_id() {
  peer_id_ = 0u;
  clear_has_peer_id();
}
inline ::google::protobuf::uint32 IMSingleGetShieldReq::peer_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetShieldReq.peer_id)
  return peer_id_;
}
inline void IMSingleGetShieldReq::set_peer_id(::google::protobuf::uint32 value) {
  set_has_peer_id();
  peer_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetShieldReq.peer_id)
}

// optional bytes attach_data = 20;
inline bool IMSingleGetShieldReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSingleGetShieldReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSingleGetShieldReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSingleGetShieldReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSingleGetShieldReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetShieldReq.attach_data)
  return *attach_data_;
}
inline void IMSingleGetShieldReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetShieldReq.attach_data)
}
inline void IMSingleGetShieldReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMSingleGetShieldReq.attach_data)
}
inline void IMSingleGetShieldReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMSingleGetShieldReq.attach_data)
}
inline ::std::string* IMSingleGetShieldReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMSingleGetShieldReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMSingleGetShieldReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSingleGetShieldReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMSingleGetShieldReq.attach_data)
}

// -------------------------------------------------------------------

// IMSingleGetShieldResp

// required uint32 user_id = 1;
inline bool IMSingleGetShieldResp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSingleGetShieldResp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSingleGetShieldResp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSingleGetShieldResp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSingleGetShieldResp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetShieldResp.user_id)
  return user_id_;
}
inline void IMSingleGetShieldResp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetShieldResp.user_id)
}

// required uint32 peer_id = 2;
inline bool IMSingleGetShieldResp::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSingleGetShieldResp::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSingleGetShieldResp::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSingleGetShieldResp::clear_peer_id() {
  peer_id_ = 0u;
  clear_has_peer_id();
}
inline ::google::protobuf::uint32 IMSingleGetShieldResp::peer_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetShieldResp.peer_id)
  return peer_id_;
}
inline void IMSingleGetShieldResp::set_peer_id(::google::protobuf::uint32 value) {
  set_has_peer_id();
  peer_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetShieldResp.peer_id)
}

// required uint32 state = 3;
inline bool IMSingleGetShieldResp::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSingleGetShieldResp::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSingleGetShieldResp::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSingleGetShieldResp::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 IMSingleGetShieldResp::state() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetShieldResp.state)
  return state_;
}
inline void IMSingleGetShieldResp::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetShieldResp.state)
}

// required uint32 result_code = 4;
inline bool IMSingleGetShieldResp::has_result_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMSingleGetShieldResp::set_has_result_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMSingleGetShieldResp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMSingleGetShieldResp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMSingleGetShieldResp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetShieldResp.result_code)
  return result_code_;
}
inline void IMSingleGetShieldResp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetShieldResp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMSingleGetShieldResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMSingleGetShieldResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMSingleGetShieldResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMSingleGetShieldResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSingleGetShieldResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMSingleGetShieldResp.attach_data)
  return *attach_data_;
}
inline void IMSingleGetShieldResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMSingleGetShieldResp.attach_data)
}
inline void IMSingleGetShieldResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMSingleGetShieldResp.attach_data)
}
inline void IMSingleGetShieldResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMSingleGetShieldResp.attach_data)
}
inline ::std::string* IMSingleGetShieldResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMSingleGetShieldResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMSingleGetShieldResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSingleGetShieldResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMSingleGetShieldResp.attach_data)
}

// -------------------------------------------------------------------

// IMGetDeliverMsgReq

// required uint32 old_consult_id = 1;
inline bool IMGetDeliverMsgReq::has_old_consult_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGetDeliverMsgReq::set_has_old_consult_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGetDeliverMsgReq::clear_has_old_consult_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGetDeliverMsgReq::clear_old_consult_id() {
  old_consult_id_ = 0u;
  clear_has_old_consult_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgReq::old_consult_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgReq.old_consult_id)
  return old_consult_id_;
}
inline void IMGetDeliverMsgReq::set_old_consult_id(::google::protobuf::uint32 value) {
  set_has_old_consult_id();
  old_consult_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgReq.old_consult_id)
}

// required uint32 new_consult_id = 2;
inline bool IMGetDeliverMsgReq::has_new_consult_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGetDeliverMsgReq::set_has_new_consult_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGetDeliverMsgReq::clear_has_new_consult_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGetDeliverMsgReq::clear_new_consult_id() {
  new_consult_id_ = 0u;
  clear_has_new_consult_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgReq::new_consult_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgReq.new_consult_id)
  return new_consult_id_;
}
inline void IMGetDeliverMsgReq::set_new_consult_id(::google::protobuf::uint32 value) {
  set_has_new_consult_id();
  new_consult_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgReq.new_consult_id)
}

// required uint32 student_id = 3;
inline bool IMGetDeliverMsgReq::has_student_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGetDeliverMsgReq::set_has_student_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGetDeliverMsgReq::clear_has_student_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGetDeliverMsgReq::clear_student_id() {
  student_id_ = 0u;
  clear_has_student_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgReq::student_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgReq.student_id)
  return student_id_;
}
inline void IMGetDeliverMsgReq::set_student_id(::google::protobuf::uint32 value) {
  set_has_student_id();
  student_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgReq.student_id)
}

// required uint32 duty_id = 4;
inline bool IMGetDeliverMsgReq::has_duty_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMGetDeliverMsgReq::set_has_duty_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMGetDeliverMsgReq::clear_has_duty_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMGetDeliverMsgReq::clear_duty_id() {
  duty_id_ = 0u;
  clear_has_duty_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgReq::duty_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgReq.duty_id)
  return duty_id_;
}
inline void IMGetDeliverMsgReq::set_duty_id(::google::protobuf::uint32 value) {
  set_has_duty_id();
  duty_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgReq.duty_id)
}

// required uint32 manager_id = 5;
inline bool IMGetDeliverMsgReq::has_manager_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMGetDeliverMsgReq::set_has_manager_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMGetDeliverMsgReq::clear_has_manager_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMGetDeliverMsgReq::clear_manager_id() {
  manager_id_ = 0u;
  clear_has_manager_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgReq::manager_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgReq.manager_id)
  return manager_id_;
}
inline void IMGetDeliverMsgReq::set_manager_id(::google::protobuf::uint32 value) {
  set_has_manager_id();
  manager_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgReq.manager_id)
}

// required uint32 order_id = 6;
inline bool IMGetDeliverMsgReq::has_order_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMGetDeliverMsgReq::set_has_order_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMGetDeliverMsgReq::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMGetDeliverMsgReq::clear_order_id() {
  order_id_ = 0u;
  clear_has_order_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgReq::order_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgReq.order_id)
  return order_id_;
}
inline void IMGetDeliverMsgReq::set_order_id(::google::protobuf::uint32 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgReq.order_id)
}

// required uint32 deliver_type = 7;
inline bool IMGetDeliverMsgReq::has_deliver_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMGetDeliverMsgReq::set_has_deliver_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMGetDeliverMsgReq::clear_has_deliver_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMGetDeliverMsgReq::clear_deliver_type() {
  deliver_type_ = 0u;
  clear_has_deliver_type();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgReq::deliver_type() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgReq.deliver_type)
  return deliver_type_;
}
inline void IMGetDeliverMsgReq::set_deliver_type(::google::protobuf::uint32 value) {
  set_has_deliver_type();
  deliver_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgReq.deliver_type)
}

// optional string manager_name = 20;
inline bool IMGetDeliverMsgReq::has_manager_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMGetDeliverMsgReq::set_has_manager_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMGetDeliverMsgReq::clear_has_manager_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMGetDeliverMsgReq::clear_manager_name() {
  if (manager_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_->clear();
  }
  clear_has_manager_name();
}
inline const ::std::string& IMGetDeliverMsgReq::manager_name() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgReq.manager_name)
  return *manager_name_;
}
inline void IMGetDeliverMsgReq::set_manager_name(const ::std::string& value) {
  set_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_ = new ::std::string;
  }
  manager_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgReq.manager_name)
}
inline void IMGetDeliverMsgReq::set_manager_name(const char* value) {
  set_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_ = new ::std::string;
  }
  manager_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMGetDeliverMsgReq.manager_name)
}
inline void IMGetDeliverMsgReq::set_manager_name(const char* value, size_t size) {
  set_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_ = new ::std::string;
  }
  manager_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMGetDeliverMsgReq.manager_name)
}
inline ::std::string* IMGetDeliverMsgReq::mutable_manager_name() {
  set_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMGetDeliverMsgReq.manager_name)
  return manager_name_;
}
inline ::std::string* IMGetDeliverMsgReq::release_manager_name() {
  clear_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = manager_name_;
    manager_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMGetDeliverMsgReq::set_allocated_manager_name(::std::string* manager_name) {
  if (manager_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manager_name_;
  }
  if (manager_name) {
    set_has_manager_name();
    manager_name_ = manager_name;
  } else {
    clear_has_manager_name();
    manager_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMGetDeliverMsgReq.manager_name)
}

// optional string manager_portrait = 21;
inline bool IMGetDeliverMsgReq::has_manager_portrait() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IMGetDeliverMsgReq::set_has_manager_portrait() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IMGetDeliverMsgReq::clear_has_manager_portrait() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IMGetDeliverMsgReq::clear_manager_portrait() {
  if (manager_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_->clear();
  }
  clear_has_manager_portrait();
}
inline const ::std::string& IMGetDeliverMsgReq::manager_portrait() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgReq.manager_portrait)
  return *manager_portrait_;
}
inline void IMGetDeliverMsgReq::set_manager_portrait(const ::std::string& value) {
  set_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_ = new ::std::string;
  }
  manager_portrait_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgReq.manager_portrait)
}
inline void IMGetDeliverMsgReq::set_manager_portrait(const char* value) {
  set_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_ = new ::std::string;
  }
  manager_portrait_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMGetDeliverMsgReq.manager_portrait)
}
inline void IMGetDeliverMsgReq::set_manager_portrait(const char* value, size_t size) {
  set_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_ = new ::std::string;
  }
  manager_portrait_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMGetDeliverMsgReq.manager_portrait)
}
inline ::std::string* IMGetDeliverMsgReq::mutable_manager_portrait() {
  set_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMGetDeliverMsgReq.manager_portrait)
  return manager_portrait_;
}
inline ::std::string* IMGetDeliverMsgReq::release_manager_portrait() {
  clear_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = manager_portrait_;
    manager_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMGetDeliverMsgReq::set_allocated_manager_portrait(::std::string* manager_portrait) {
  if (manager_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manager_portrait_;
  }
  if (manager_portrait) {
    set_has_manager_portrait();
    manager_portrait_ = manager_portrait;
  } else {
    clear_has_manager_portrait();
    manager_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMGetDeliverMsgReq.manager_portrait)
}

// -------------------------------------------------------------------

// IMGetDeliverMsgResp

// required uint32 old_consult_id = 1;
inline bool IMGetDeliverMsgResp::has_old_consult_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_old_consult_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGetDeliverMsgResp::clear_has_old_consult_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGetDeliverMsgResp::clear_old_consult_id() {
  old_consult_id_ = 0u;
  clear_has_old_consult_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgResp::old_consult_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.old_consult_id)
  return old_consult_id_;
}
inline void IMGetDeliverMsgResp::set_old_consult_id(::google::protobuf::uint32 value) {
  set_has_old_consult_id();
  old_consult_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.old_consult_id)
}

// required uint32 new_consult_id = 2;
inline bool IMGetDeliverMsgResp::has_new_consult_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_new_consult_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGetDeliverMsgResp::clear_has_new_consult_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGetDeliverMsgResp::clear_new_consult_id() {
  new_consult_id_ = 0u;
  clear_has_new_consult_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgResp::new_consult_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.new_consult_id)
  return new_consult_id_;
}
inline void IMGetDeliverMsgResp::set_new_consult_id(::google::protobuf::uint32 value) {
  set_has_new_consult_id();
  new_consult_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.new_consult_id)
}

// required uint32 student_id = 3;
inline bool IMGetDeliverMsgResp::has_student_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_student_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGetDeliverMsgResp::clear_has_student_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGetDeliverMsgResp::clear_student_id() {
  student_id_ = 0u;
  clear_has_student_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgResp::student_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.student_id)
  return student_id_;
}
inline void IMGetDeliverMsgResp::set_student_id(::google::protobuf::uint32 value) {
  set_has_student_id();
  student_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.student_id)
}

// required uint32 duty_id = 4;
inline bool IMGetDeliverMsgResp::has_duty_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_duty_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMGetDeliverMsgResp::clear_has_duty_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMGetDeliverMsgResp::clear_duty_id() {
  duty_id_ = 0u;
  clear_has_duty_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgResp::duty_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.duty_id)
  return duty_id_;
}
inline void IMGetDeliverMsgResp::set_duty_id(::google::protobuf::uint32 value) {
  set_has_duty_id();
  duty_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.duty_id)
}

// required uint32 manager_id = 5;
inline bool IMGetDeliverMsgResp::has_manager_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_manager_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMGetDeliverMsgResp::clear_has_manager_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMGetDeliverMsgResp::clear_manager_id() {
  manager_id_ = 0u;
  clear_has_manager_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgResp::manager_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.manager_id)
  return manager_id_;
}
inline void IMGetDeliverMsgResp::set_manager_id(::google::protobuf::uint32 value) {
  set_has_manager_id();
  manager_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.manager_id)
}

// required uint32 order_id = 6;
inline bool IMGetDeliverMsgResp::has_order_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_order_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMGetDeliverMsgResp::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMGetDeliverMsgResp::clear_order_id() {
  order_id_ = 0u;
  clear_has_order_id();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgResp::order_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.order_id)
  return order_id_;
}
inline void IMGetDeliverMsgResp::set_order_id(::google::protobuf::uint32 value) {
  set_has_order_id();
  order_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.order_id)
}

// required uint32 deliver_type = 7;
inline bool IMGetDeliverMsgResp::has_deliver_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_deliver_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMGetDeliverMsgResp::clear_has_deliver_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMGetDeliverMsgResp::clear_deliver_type() {
  deliver_type_ = 0u;
  clear_has_deliver_type();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgResp::deliver_type() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.deliver_type)
  return deliver_type_;
}
inline void IMGetDeliverMsgResp::set_deliver_type(::google::protobuf::uint32 value) {
  set_has_deliver_type();
  deliver_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.deliver_type)
}

// required uint32 result = 8;
inline bool IMGetDeliverMsgResp::has_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMGetDeliverMsgResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMGetDeliverMsgResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMGetDeliverMsgResp::result() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.result)
  return result_;
}
inline void IMGetDeliverMsgResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.result)
}

// repeated .IM.BaseDefine.ConsultMsg consult_msg_list = 9;
inline int IMGetDeliverMsgResp::consult_msg_list_size() const {
  return consult_msg_list_.size();
}
inline void IMGetDeliverMsgResp::clear_consult_msg_list() {
  consult_msg_list_.Clear();
}
inline const ::IM::BaseDefine::ConsultMsg& IMGetDeliverMsgResp::consult_msg_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.consult_msg_list)
  return consult_msg_list_.Get(index);
}
inline ::IM::BaseDefine::ConsultMsg* IMGetDeliverMsgResp::mutable_consult_msg_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Other.IMGetDeliverMsgResp.consult_msg_list)
  return consult_msg_list_.Mutable(index);
}
inline ::IM::BaseDefine::ConsultMsg* IMGetDeliverMsgResp::add_consult_msg_list() {
  // @@protoc_insertion_point(field_add:IM.Other.IMGetDeliverMsgResp.consult_msg_list)
  return consult_msg_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ConsultMsg >&
IMGetDeliverMsgResp::consult_msg_list() const {
  // @@protoc_insertion_point(field_list:IM.Other.IMGetDeliverMsgResp.consult_msg_list)
  return consult_msg_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ConsultMsg >*
IMGetDeliverMsgResp::mutable_consult_msg_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Other.IMGetDeliverMsgResp.consult_msg_list)
  return &consult_msg_list_;
}

// optional string manager_name = 20;
inline bool IMGetDeliverMsgResp::has_manager_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_manager_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IMGetDeliverMsgResp::clear_has_manager_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IMGetDeliverMsgResp::clear_manager_name() {
  if (manager_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_->clear();
  }
  clear_has_manager_name();
}
inline const ::std::string& IMGetDeliverMsgResp::manager_name() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.manager_name)
  return *manager_name_;
}
inline void IMGetDeliverMsgResp::set_manager_name(const ::std::string& value) {
  set_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_ = new ::std::string;
  }
  manager_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.manager_name)
}
inline void IMGetDeliverMsgResp::set_manager_name(const char* value) {
  set_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_ = new ::std::string;
  }
  manager_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMGetDeliverMsgResp.manager_name)
}
inline void IMGetDeliverMsgResp::set_manager_name(const char* value, size_t size) {
  set_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_ = new ::std::string;
  }
  manager_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMGetDeliverMsgResp.manager_name)
}
inline ::std::string* IMGetDeliverMsgResp::mutable_manager_name() {
  set_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMGetDeliverMsgResp.manager_name)
  return manager_name_;
}
inline ::std::string* IMGetDeliverMsgResp::release_manager_name() {
  clear_has_manager_name();
  if (manager_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = manager_name_;
    manager_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMGetDeliverMsgResp::set_allocated_manager_name(::std::string* manager_name) {
  if (manager_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manager_name_;
  }
  if (manager_name) {
    set_has_manager_name();
    manager_name_ = manager_name;
  } else {
    clear_has_manager_name();
    manager_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMGetDeliverMsgResp.manager_name)
}

// optional string manager_portrait = 21;
inline bool IMGetDeliverMsgResp::has_manager_portrait() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IMGetDeliverMsgResp::set_has_manager_portrait() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IMGetDeliverMsgResp::clear_has_manager_portrait() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IMGetDeliverMsgResp::clear_manager_portrait() {
  if (manager_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_->clear();
  }
  clear_has_manager_portrait();
}
inline const ::std::string& IMGetDeliverMsgResp::manager_portrait() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetDeliverMsgResp.manager_portrait)
  return *manager_portrait_;
}
inline void IMGetDeliverMsgResp::set_manager_portrait(const ::std::string& value) {
  set_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_ = new ::std::string;
  }
  manager_portrait_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMGetDeliverMsgResp.manager_portrait)
}
inline void IMGetDeliverMsgResp::set_manager_portrait(const char* value) {
  set_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_ = new ::std::string;
  }
  manager_portrait_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMGetDeliverMsgResp.manager_portrait)
}
inline void IMGetDeliverMsgResp::set_manager_portrait(const char* value, size_t size) {
  set_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_ = new ::std::string;
  }
  manager_portrait_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMGetDeliverMsgResp.manager_portrait)
}
inline ::std::string* IMGetDeliverMsgResp::mutable_manager_portrait() {
  set_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manager_portrait_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMGetDeliverMsgResp.manager_portrait)
  return manager_portrait_;
}
inline ::std::string* IMGetDeliverMsgResp::release_manager_portrait() {
  clear_has_manager_portrait();
  if (manager_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = manager_portrait_;
    manager_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMGetDeliverMsgResp::set_allocated_manager_portrait(::std::string* manager_portrait) {
  if (manager_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manager_portrait_;
  }
  if (manager_portrait) {
    set_has_manager_portrait();
    manager_portrait_ = manager_portrait;
  } else {
    clear_has_manager_portrait();
    manager_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMGetDeliverMsgResp.manager_portrait)
}

// -------------------------------------------------------------------

// TeacherQuqueInfo

// required uint32 teacher_id = 1;
inline bool TeacherQuqueInfo::has_teacher_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeacherQuqueInfo::set_has_teacher_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeacherQuqueInfo::clear_has_teacher_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeacherQuqueInfo::clear_teacher_id() {
  teacher_id_ = 0u;
  clear_has_teacher_id();
}
inline ::google::protobuf::uint32 TeacherQuqueInfo::teacher_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.TeacherQuqueInfo.teacher_id)
  return teacher_id_;
}
inline void TeacherQuqueInfo::set_teacher_id(::google::protobuf::uint32 value) {
  set_has_teacher_id();
  teacher_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.TeacherQuqueInfo.teacher_id)
}

// required uint32 teacher_state = 2;
inline bool TeacherQuqueInfo::has_teacher_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeacherQuqueInfo::set_has_teacher_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeacherQuqueInfo::clear_has_teacher_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeacherQuqueInfo::clear_teacher_state() {
  teacher_state_ = 0u;
  clear_has_teacher_state();
}
inline ::google::protobuf::uint32 TeacherQuqueInfo::teacher_state() const {
  // @@protoc_insertion_point(field_get:IM.Other.TeacherQuqueInfo.teacher_state)
  return teacher_state_;
}
inline void TeacherQuqueInfo::set_teacher_state(::google::protobuf::uint32 value) {
  set_has_teacher_state();
  teacher_state_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.TeacherQuqueInfo.teacher_state)
}

// required uint32 queue_size = 3;
inline bool TeacherQuqueInfo::has_queue_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeacherQuqueInfo::set_has_queue_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeacherQuqueInfo::clear_has_queue_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeacherQuqueInfo::clear_queue_size() {
  queue_size_ = 0u;
  clear_has_queue_size();
}
inline ::google::protobuf::uint32 TeacherQuqueInfo::queue_size() const {
  // @@protoc_insertion_point(field_get:IM.Other.TeacherQuqueInfo.queue_size)
  return queue_size_;
}
inline void TeacherQuqueInfo::set_queue_size(::google::protobuf::uint32 value) {
  set_has_queue_size();
  queue_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.TeacherQuqueInfo.queue_size)
}

// -------------------------------------------------------------------

// StudentQuqueInfo

// required uint32 student_id = 1;
inline bool StudentQuqueInfo::has_student_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StudentQuqueInfo::set_has_student_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StudentQuqueInfo::clear_has_student_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StudentQuqueInfo::clear_student_id() {
  student_id_ = 0u;
  clear_has_student_id();
}
inline ::google::protobuf::uint32 StudentQuqueInfo::student_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.StudentQuqueInfo.student_id)
  return student_id_;
}
inline void StudentQuqueInfo::set_student_id(::google::protobuf::uint32 value) {
  set_has_student_id();
  student_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.StudentQuqueInfo.student_id)
}

// required uint32 teacher_id = 2;
inline bool StudentQuqueInfo::has_teacher_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StudentQuqueInfo::set_has_teacher_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StudentQuqueInfo::clear_has_teacher_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StudentQuqueInfo::clear_teacher_id() {
  teacher_id_ = 0u;
  clear_has_teacher_id();
}
inline ::google::protobuf::uint32 StudentQuqueInfo::teacher_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.StudentQuqueInfo.teacher_id)
  return teacher_id_;
}
inline void StudentQuqueInfo::set_teacher_id(::google::protobuf::uint32 value) {
  set_has_teacher_id();
  teacher_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.StudentQuqueInfo.teacher_id)
}

// -------------------------------------------------------------------

// IMGetConsultQueueReq

// required uint32 http_handle = 1;
inline bool IMGetConsultQueueReq::has_http_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGetConsultQueueReq::set_has_http_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGetConsultQueueReq::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGetConsultQueueReq::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMGetConsultQueueReq::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueReq.http_handle)
  return http_handle_;
}
inline void IMGetConsultQueueReq::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetConsultQueueReq.http_handle)
}

// -------------------------------------------------------------------

// IMGetConsultQueueResp

// required uint32 teacher_map_size = 1;
inline bool IMGetConsultQueueResp::has_teacher_map_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGetConsultQueueResp::set_has_teacher_map_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGetConsultQueueResp::clear_has_teacher_map_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGetConsultQueueResp::clear_teacher_map_size() {
  teacher_map_size_ = 0u;
  clear_has_teacher_map_size();
}
inline ::google::protobuf::uint32 IMGetConsultQueueResp::teacher_map_size() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.teacher_map_size)
  return teacher_map_size_;
}
inline void IMGetConsultQueueResp::set_teacher_map_size(::google::protobuf::uint32 value) {
  set_has_teacher_map_size();
  teacher_map_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetConsultQueueResp.teacher_map_size)
}

// required uint32 online_teacher_size = 2;
inline bool IMGetConsultQueueResp::has_online_teacher_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGetConsultQueueResp::set_has_online_teacher_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGetConsultQueueResp::clear_has_online_teacher_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGetConsultQueueResp::clear_online_teacher_size() {
  online_teacher_size_ = 0u;
  clear_has_online_teacher_size();
}
inline ::google::protobuf::uint32 IMGetConsultQueueResp::online_teacher_size() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.online_teacher_size)
  return online_teacher_size_;
}
inline void IMGetConsultQueueResp::set_online_teacher_size(::google::protobuf::uint32 value) {
  set_has_online_teacher_size();
  online_teacher_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetConsultQueueResp.online_teacher_size)
}

// required uint32 offline_teacher_size = 3;
inline bool IMGetConsultQueueResp::has_offline_teacher_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGetConsultQueueResp::set_has_offline_teacher_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGetConsultQueueResp::clear_has_offline_teacher_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGetConsultQueueResp::clear_offline_teacher_size() {
  offline_teacher_size_ = 0u;
  clear_has_offline_teacher_size();
}
inline ::google::protobuf::uint32 IMGetConsultQueueResp::offline_teacher_size() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.offline_teacher_size)
  return offline_teacher_size_;
}
inline void IMGetConsultQueueResp::set_offline_teacher_size(::google::protobuf::uint32 value) {
  set_has_offline_teacher_size();
  offline_teacher_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetConsultQueueResp.offline_teacher_size)
}

// required uint32 leave_teacher_size = 4;
inline bool IMGetConsultQueueResp::has_leave_teacher_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMGetConsultQueueResp::set_has_leave_teacher_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMGetConsultQueueResp::clear_has_leave_teacher_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMGetConsultQueueResp::clear_leave_teacher_size() {
  leave_teacher_size_ = 0u;
  clear_has_leave_teacher_size();
}
inline ::google::protobuf::uint32 IMGetConsultQueueResp::leave_teacher_size() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.leave_teacher_size)
  return leave_teacher_size_;
}
inline void IMGetConsultQueueResp::set_leave_teacher_size(::google::protobuf::uint32 value) {
  set_has_leave_teacher_size();
  leave_teacher_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetConsultQueueResp.leave_teacher_size)
}

// required uint32 has_queue_teacher_size = 5;
inline bool IMGetConsultQueueResp::has_has_queue_teacher_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMGetConsultQueueResp::set_has_has_queue_teacher_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMGetConsultQueueResp::clear_has_has_queue_teacher_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMGetConsultQueueResp::clear_has_queue_teacher_size() {
  has_queue_teacher_size_ = 0u;
  clear_has_has_queue_teacher_size();
}
inline ::google::protobuf::uint32 IMGetConsultQueueResp::has_queue_teacher_size() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.has_queue_teacher_size)
  return has_queue_teacher_size_;
}
inline void IMGetConsultQueueResp::set_has_queue_teacher_size(::google::protobuf::uint32 value) {
  set_has_has_queue_teacher_size();
  has_queue_teacher_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetConsultQueueResp.has_queue_teacher_size)
}

// required uint32 inqueue_student_size_from_teacher = 6;
inline bool IMGetConsultQueueResp::has_inqueue_student_size_from_teacher() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMGetConsultQueueResp::set_has_inqueue_student_size_from_teacher() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMGetConsultQueueResp::clear_has_inqueue_student_size_from_teacher() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMGetConsultQueueResp::clear_inqueue_student_size_from_teacher() {
  inqueue_student_size_from_teacher_ = 0u;
  clear_has_inqueue_student_size_from_teacher();
}
inline ::google::protobuf::uint32 IMGetConsultQueueResp::inqueue_student_size_from_teacher() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.inqueue_student_size_from_teacher)
  return inqueue_student_size_from_teacher_;
}
inline void IMGetConsultQueueResp::set_inqueue_student_size_from_teacher(::google::protobuf::uint32 value) {
  set_has_inqueue_student_size_from_teacher();
  inqueue_student_size_from_teacher_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetConsultQueueResp.inqueue_student_size_from_teacher)
}

// repeated .IM.Other.TeacherQuqueInfo teacher_queue_info = 7;
inline int IMGetConsultQueueResp::teacher_queue_info_size() const {
  return teacher_queue_info_.size();
}
inline void IMGetConsultQueueResp::clear_teacher_queue_info() {
  teacher_queue_info_.Clear();
}
inline const ::IM::Other::TeacherQuqueInfo& IMGetConsultQueueResp::teacher_queue_info(int index) const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.teacher_queue_info)
  return teacher_queue_info_.Get(index);
}
inline ::IM::Other::TeacherQuqueInfo* IMGetConsultQueueResp::mutable_teacher_queue_info(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Other.IMGetConsultQueueResp.teacher_queue_info)
  return teacher_queue_info_.Mutable(index);
}
inline ::IM::Other::TeacherQuqueInfo* IMGetConsultQueueResp::add_teacher_queue_info() {
  // @@protoc_insertion_point(field_add:IM.Other.IMGetConsultQueueResp.teacher_queue_info)
  return teacher_queue_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherQuqueInfo >&
IMGetConsultQueueResp::teacher_queue_info() const {
  // @@protoc_insertion_point(field_list:IM.Other.IMGetConsultQueueResp.teacher_queue_info)
  return teacher_queue_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherQuqueInfo >*
IMGetConsultQueueResp::mutable_teacher_queue_info() {
  // @@protoc_insertion_point(field_mutable_list:IM.Other.IMGetConsultQueueResp.teacher_queue_info)
  return &teacher_queue_info_;
}

// required uint32 inqueue_student_size_from_student = 8;
inline bool IMGetConsultQueueResp::has_inqueue_student_size_from_student() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMGetConsultQueueResp::set_has_inqueue_student_size_from_student() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMGetConsultQueueResp::clear_has_inqueue_student_size_from_student() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMGetConsultQueueResp::clear_inqueue_student_size_from_student() {
  inqueue_student_size_from_student_ = 0u;
  clear_has_inqueue_student_size_from_student();
}
inline ::google::protobuf::uint32 IMGetConsultQueueResp::inqueue_student_size_from_student() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.inqueue_student_size_from_student)
  return inqueue_student_size_from_student_;
}
inline void IMGetConsultQueueResp::set_inqueue_student_size_from_student(::google::protobuf::uint32 value) {
  set_has_inqueue_student_size_from_student();
  inqueue_student_size_from_student_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetConsultQueueResp.inqueue_student_size_from_student)
}

// repeated .IM.Other.StudentQuqueInfo student_queue_info = 9;
inline int IMGetConsultQueueResp::student_queue_info_size() const {
  return student_queue_info_.size();
}
inline void IMGetConsultQueueResp::clear_student_queue_info() {
  student_queue_info_.Clear();
}
inline const ::IM::Other::StudentQuqueInfo& IMGetConsultQueueResp::student_queue_info(int index) const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.student_queue_info)
  return student_queue_info_.Get(index);
}
inline ::IM::Other::StudentQuqueInfo* IMGetConsultQueueResp::mutable_student_queue_info(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Other.IMGetConsultQueueResp.student_queue_info)
  return student_queue_info_.Mutable(index);
}
inline ::IM::Other::StudentQuqueInfo* IMGetConsultQueueResp::add_student_queue_info() {
  // @@protoc_insertion_point(field_add:IM.Other.IMGetConsultQueueResp.student_queue_info)
  return student_queue_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Other::StudentQuqueInfo >&
IMGetConsultQueueResp::student_queue_info() const {
  // @@protoc_insertion_point(field_list:IM.Other.IMGetConsultQueueResp.student_queue_info)
  return student_queue_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Other::StudentQuqueInfo >*
IMGetConsultQueueResp::mutable_student_queue_info() {
  // @@protoc_insertion_point(field_mutable_list:IM.Other.IMGetConsultQueueResp.student_queue_info)
  return &student_queue_info_;
}

// required uint32 http_handle = 10;
inline bool IMGetConsultQueueResp::has_http_handle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IMGetConsultQueueResp::set_has_http_handle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IMGetConsultQueueResp::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IMGetConsultQueueResp::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMGetConsultQueueResp::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMGetConsultQueueResp.http_handle)
  return http_handle_;
}
inline void IMGetConsultQueueResp::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMGetConsultQueueResp.http_handle)
}

// -------------------------------------------------------------------

// DBServerInfo

// required bytes ip = 1;
inline bool DBServerInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBServerInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBServerInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBServerInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& DBServerInfo::ip() const {
  // @@protoc_insertion_point(field_get:IM.Other.DBServerInfo.ip)
  return *ip_;
}
inline void DBServerInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.DBServerInfo.ip)
}
inline void DBServerInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.DBServerInfo.ip)
}
inline void DBServerInfo::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.DBServerInfo.ip)
}
inline ::std::string* DBServerInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.DBServerInfo.ip)
  return ip_;
}
inline ::std::string* DBServerInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DBServerInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.DBServerInfo.ip)
}

// required uint32 port = 2;
inline bool DBServerInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBServerInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBServerInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBServerInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 DBServerInfo::port() const {
  // @@protoc_insertion_point(field_get:IM.Other.DBServerInfo.port)
  return port_;
}
inline void DBServerInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.DBServerInfo.port)
}

// -------------------------------------------------------------------

// IMOtherGetDbServerCntReq

// required uint32 http_handle = 1;
inline bool IMOtherGetDbServerCntReq::has_http_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMOtherGetDbServerCntReq::set_has_http_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMOtherGetDbServerCntReq::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMOtherGetDbServerCntReq::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMOtherGetDbServerCntReq::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherGetDbServerCntReq.http_handle)
  return http_handle_;
}
inline void IMOtherGetDbServerCntReq::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherGetDbServerCntReq.http_handle)
}

// optional bytes attach_data = 20;
inline bool IMOtherGetDbServerCntReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMOtherGetDbServerCntReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMOtherGetDbServerCntReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMOtherGetDbServerCntReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMOtherGetDbServerCntReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherGetDbServerCntReq.attach_data)
  return *attach_data_;
}
inline void IMOtherGetDbServerCntReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherGetDbServerCntReq.attach_data)
}
inline void IMOtherGetDbServerCntReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMOtherGetDbServerCntReq.attach_data)
}
inline void IMOtherGetDbServerCntReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMOtherGetDbServerCntReq.attach_data)
}
inline ::std::string* IMOtherGetDbServerCntReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMOtherGetDbServerCntReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMOtherGetDbServerCntReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMOtherGetDbServerCntReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMOtherGetDbServerCntReq.attach_data)
}

// -------------------------------------------------------------------

// IMOtherGetDbServerCntResp

// required uint32 http_handle = 1;
inline bool IMOtherGetDbServerCntResp::has_http_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMOtherGetDbServerCntResp::set_has_http_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMOtherGetDbServerCntResp::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMOtherGetDbServerCntResp::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMOtherGetDbServerCntResp::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherGetDbServerCntResp.http_handle)
  return http_handle_;
}
inline void IMOtherGetDbServerCntResp::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherGetDbServerCntResp.http_handle)
}

// required uint32 db_server_login_count = 2;
inline bool IMOtherGetDbServerCntResp::has_db_server_login_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMOtherGetDbServerCntResp::set_has_db_server_login_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMOtherGetDbServerCntResp::clear_has_db_server_login_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMOtherGetDbServerCntResp::clear_db_server_login_count() {
  db_server_login_count_ = 0u;
  clear_has_db_server_login_count();
}
inline ::google::protobuf::uint32 IMOtherGetDbServerCntResp::db_server_login_count() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherGetDbServerCntResp.db_server_login_count)
  return db_server_login_count_;
}
inline void IMOtherGetDbServerCntResp::set_db_server_login_count(::google::protobuf::uint32 value) {
  set_has_db_server_login_count();
  db_server_login_count_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherGetDbServerCntResp.db_server_login_count)
}

// required uint32 db_server_count = 3;
inline bool IMOtherGetDbServerCntResp::has_db_server_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMOtherGetDbServerCntResp::set_has_db_server_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMOtherGetDbServerCntResp::clear_has_db_server_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMOtherGetDbServerCntResp::clear_db_server_count() {
  db_server_count_ = 0u;
  clear_has_db_server_count();
}
inline ::google::protobuf::uint32 IMOtherGetDbServerCntResp::db_server_count() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherGetDbServerCntResp.db_server_count)
  return db_server_count_;
}
inline void IMOtherGetDbServerCntResp::set_db_server_count(::google::protobuf::uint32 value) {
  set_has_db_server_count();
  db_server_count_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherGetDbServerCntResp.db_server_count)
}

// required uint32 result = 4;
inline bool IMOtherGetDbServerCntResp::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMOtherGetDbServerCntResp::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMOtherGetDbServerCntResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMOtherGetDbServerCntResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMOtherGetDbServerCntResp::result() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherGetDbServerCntResp.result)
  return result_;
}
inline void IMOtherGetDbServerCntResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherGetDbServerCntResp.result)
}

// repeated .IM.Other.DBServerInfo db_server_info_list = 5;
inline int IMOtherGetDbServerCntResp::db_server_info_list_size() const {
  return db_server_info_list_.size();
}
inline void IMOtherGetDbServerCntResp::clear_db_server_info_list() {
  db_server_info_list_.Clear();
}
inline const ::IM::Other::DBServerInfo& IMOtherGetDbServerCntResp::db_server_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherGetDbServerCntResp.db_server_info_list)
  return db_server_info_list_.Get(index);
}
inline ::IM::Other::DBServerInfo* IMOtherGetDbServerCntResp::mutable_db_server_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Other.IMOtherGetDbServerCntResp.db_server_info_list)
  return db_server_info_list_.Mutable(index);
}
inline ::IM::Other::DBServerInfo* IMOtherGetDbServerCntResp::add_db_server_info_list() {
  // @@protoc_insertion_point(field_add:IM.Other.IMOtherGetDbServerCntResp.db_server_info_list)
  return db_server_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Other::DBServerInfo >&
IMOtherGetDbServerCntResp::db_server_info_list() const {
  // @@protoc_insertion_point(field_list:IM.Other.IMOtherGetDbServerCntResp.db_server_info_list)
  return db_server_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Other::DBServerInfo >*
IMOtherGetDbServerCntResp::mutable_db_server_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Other.IMOtherGetDbServerCntResp.db_server_info_list)
  return &db_server_info_list_;
}

// optional bytes attach_data = 20;
inline bool IMOtherGetDbServerCntResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMOtherGetDbServerCntResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMOtherGetDbServerCntResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMOtherGetDbServerCntResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMOtherGetDbServerCntResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherGetDbServerCntResp.attach_data)
  return *attach_data_;
}
inline void IMOtherGetDbServerCntResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherGetDbServerCntResp.attach_data)
}
inline void IMOtherGetDbServerCntResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMOtherGetDbServerCntResp.attach_data)
}
inline void IMOtherGetDbServerCntResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMOtherGetDbServerCntResp.attach_data)
}
inline ::std::string* IMOtherGetDbServerCntResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMOtherGetDbServerCntResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMOtherGetDbServerCntResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMOtherGetDbServerCntResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMOtherGetDbServerCntResp.attach_data)
}

// -------------------------------------------------------------------

// IMOtherSetDbServerCntReq

// required uint32 http_handle = 1;
inline bool IMOtherSetDbServerCntReq::has_http_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMOtherSetDbServerCntReq::set_has_http_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMOtherSetDbServerCntReq::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMOtherSetDbServerCntReq::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMOtherSetDbServerCntReq::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherSetDbServerCntReq.http_handle)
  return http_handle_;
}
inline void IMOtherSetDbServerCntReq::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherSetDbServerCntReq.http_handle)
}

// required uint32 db_server_login_count = 2;
inline bool IMOtherSetDbServerCntReq::has_db_server_login_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMOtherSetDbServerCntReq::set_has_db_server_login_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMOtherSetDbServerCntReq::clear_has_db_server_login_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMOtherSetDbServerCntReq::clear_db_server_login_count() {
  db_server_login_count_ = 0u;
  clear_has_db_server_login_count();
}
inline ::google::protobuf::uint32 IMOtherSetDbServerCntReq::db_server_login_count() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherSetDbServerCntReq.db_server_login_count)
  return db_server_login_count_;
}
inline void IMOtherSetDbServerCntReq::set_db_server_login_count(::google::protobuf::uint32 value) {
  set_has_db_server_login_count();
  db_server_login_count_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherSetDbServerCntReq.db_server_login_count)
}

// required uint32 db_server_count = 3;
inline bool IMOtherSetDbServerCntReq::has_db_server_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMOtherSetDbServerCntReq::set_has_db_server_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMOtherSetDbServerCntReq::clear_has_db_server_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMOtherSetDbServerCntReq::clear_db_server_count() {
  db_server_count_ = 0u;
  clear_has_db_server_count();
}
inline ::google::protobuf::uint32 IMOtherSetDbServerCntReq::db_server_count() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherSetDbServerCntReq.db_server_count)
  return db_server_count_;
}
inline void IMOtherSetDbServerCntReq::set_db_server_count(::google::protobuf::uint32 value) {
  set_has_db_server_count();
  db_server_count_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherSetDbServerCntReq.db_server_count)
}

// optional bytes attach_data = 20;
inline bool IMOtherSetDbServerCntReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMOtherSetDbServerCntReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMOtherSetDbServerCntReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMOtherSetDbServerCntReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMOtherSetDbServerCntReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherSetDbServerCntReq.attach_data)
  return *attach_data_;
}
inline void IMOtherSetDbServerCntReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherSetDbServerCntReq.attach_data)
}
inline void IMOtherSetDbServerCntReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMOtherSetDbServerCntReq.attach_data)
}
inline void IMOtherSetDbServerCntReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMOtherSetDbServerCntReq.attach_data)
}
inline ::std::string* IMOtherSetDbServerCntReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMOtherSetDbServerCntReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMOtherSetDbServerCntReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMOtherSetDbServerCntReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMOtherSetDbServerCntReq.attach_data)
}

// -------------------------------------------------------------------

// IMOtherSetDbServerCntResp

// required uint32 http_handle = 1;
inline bool IMOtherSetDbServerCntResp::has_http_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMOtherSetDbServerCntResp::set_has_http_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMOtherSetDbServerCntResp::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMOtherSetDbServerCntResp::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMOtherSetDbServerCntResp::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherSetDbServerCntResp.http_handle)
  return http_handle_;
}
inline void IMOtherSetDbServerCntResp::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherSetDbServerCntResp.http_handle)
}

// required uint32 db_server_login_count = 2;
inline bool IMOtherSetDbServerCntResp::has_db_server_login_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMOtherSetDbServerCntResp::set_has_db_server_login_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMOtherSetDbServerCntResp::clear_has_db_server_login_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMOtherSetDbServerCntResp::clear_db_server_login_count() {
  db_server_login_count_ = 0u;
  clear_has_db_server_login_count();
}
inline ::google::protobuf::uint32 IMOtherSetDbServerCntResp::db_server_login_count() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherSetDbServerCntResp.db_server_login_count)
  return db_server_login_count_;
}
inline void IMOtherSetDbServerCntResp::set_db_server_login_count(::google::protobuf::uint32 value) {
  set_has_db_server_login_count();
  db_server_login_count_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherSetDbServerCntResp.db_server_login_count)
}

// required uint32 db_server_count = 3;
inline bool IMOtherSetDbServerCntResp::has_db_server_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMOtherSetDbServerCntResp::set_has_db_server_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMOtherSetDbServerCntResp::clear_has_db_server_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMOtherSetDbServerCntResp::clear_db_server_count() {
  db_server_count_ = 0u;
  clear_has_db_server_count();
}
inline ::google::protobuf::uint32 IMOtherSetDbServerCntResp::db_server_count() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherSetDbServerCntResp.db_server_count)
  return db_server_count_;
}
inline void IMOtherSetDbServerCntResp::set_db_server_count(::google::protobuf::uint32 value) {
  set_has_db_server_count();
  db_server_count_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherSetDbServerCntResp.db_server_count)
}

// required uint32 result = 4;
inline bool IMOtherSetDbServerCntResp::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMOtherSetDbServerCntResp::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMOtherSetDbServerCntResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMOtherSetDbServerCntResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMOtherSetDbServerCntResp::result() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherSetDbServerCntResp.result)
  return result_;
}
inline void IMOtherSetDbServerCntResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherSetDbServerCntResp.result)
}

// optional bytes attach_data = 20;
inline bool IMOtherSetDbServerCntResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMOtherSetDbServerCntResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMOtherSetDbServerCntResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMOtherSetDbServerCntResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMOtherSetDbServerCntResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherSetDbServerCntResp.attach_data)
  return *attach_data_;
}
inline void IMOtherSetDbServerCntResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherSetDbServerCntResp.attach_data)
}
inline void IMOtherSetDbServerCntResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMOtherSetDbServerCntResp.attach_data)
}
inline void IMOtherSetDbServerCntResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMOtherSetDbServerCntResp.attach_data)
}
inline ::std::string* IMOtherSetDbServerCntResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMOtherSetDbServerCntResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMOtherSetDbServerCntResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMOtherSetDbServerCntResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMOtherSetDbServerCntResp.attach_data)
}

// -------------------------------------------------------------------

// TeacherInfo

// required uint32 id = 1;
inline bool TeacherInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeacherInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeacherInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeacherInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TeacherInfo::id() const {
  // @@protoc_insertion_point(field_get:IM.Other.TeacherInfo.id)
  return id_;
}
inline void TeacherInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.TeacherInfo.id)
}

// required uint32 online_stat = 2;
inline bool TeacherInfo::has_online_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeacherInfo::set_has_online_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeacherInfo::clear_has_online_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeacherInfo::clear_online_stat() {
  online_stat_ = 0u;
  clear_has_online_stat();
}
inline ::google::protobuf::uint32 TeacherInfo::online_stat() const {
  // @@protoc_insertion_point(field_get:IM.Other.TeacherInfo.online_stat)
  return online_stat_;
}
inline void TeacherInfo::set_online_stat(::google::protobuf::uint32 value) {
  set_has_online_stat();
  online_stat_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.TeacherInfo.online_stat)
}

// required uint32 queue_cnt = 3;
inline bool TeacherInfo::has_queue_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeacherInfo::set_has_queue_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeacherInfo::clear_has_queue_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeacherInfo::clear_queue_cnt() {
  queue_cnt_ = 0u;
  clear_has_queue_cnt();
}
inline ::google::protobuf::uint32 TeacherInfo::queue_cnt() const {
  // @@protoc_insertion_point(field_get:IM.Other.TeacherInfo.queue_cnt)
  return queue_cnt_;
}
inline void TeacherInfo::set_queue_cnt(::google::protobuf::uint32 value) {
  set_has_queue_cnt();
  queue_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.TeacherInfo.queue_cnt)
}

// -------------------------------------------------------------------

// IMOtherPlatFormGetTeacherInfoReq

// required uint32 http_handle = 1;
inline bool IMOtherPlatFormGetTeacherInfoReq::has_http_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMOtherPlatFormGetTeacherInfoReq::set_has_http_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMOtherPlatFormGetTeacherInfoReq::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMOtherPlatFormGetTeacherInfoReq::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMOtherPlatFormGetTeacherInfoReq::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherPlatFormGetTeacherInfoReq.http_handle)
  return http_handle_;
}
inline void IMOtherPlatFormGetTeacherInfoReq::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherPlatFormGetTeacherInfoReq.http_handle)
}

// repeated uint32 teacher_id_list = 2;
inline int IMOtherPlatFormGetTeacherInfoReq::teacher_id_list_size() const {
  return teacher_id_list_.size();
}
inline void IMOtherPlatFormGetTeacherInfoReq::clear_teacher_id_list() {
  teacher_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMOtherPlatFormGetTeacherInfoReq::teacher_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherPlatFormGetTeacherInfoReq.teacher_id_list)
  return teacher_id_list_.Get(index);
}
inline void IMOtherPlatFormGetTeacherInfoReq::set_teacher_id_list(int index, ::google::protobuf::uint32 value) {
  teacher_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherPlatFormGetTeacherInfoReq.teacher_id_list)
}
inline void IMOtherPlatFormGetTeacherInfoReq::add_teacher_id_list(::google::protobuf::uint32 value) {
  teacher_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Other.IMOtherPlatFormGetTeacherInfoReq.teacher_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMOtherPlatFormGetTeacherInfoReq::teacher_id_list() const {
  // @@protoc_insertion_point(field_list:IM.Other.IMOtherPlatFormGetTeacherInfoReq.teacher_id_list)
  return teacher_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMOtherPlatFormGetTeacherInfoReq::mutable_teacher_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Other.IMOtherPlatFormGetTeacherInfoReq.teacher_id_list)
  return &teacher_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMOtherPlatFormGetTeacherInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMOtherPlatFormGetTeacherInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMOtherPlatFormGetTeacherInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMOtherPlatFormGetTeacherInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMOtherPlatFormGetTeacherInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherPlatFormGetTeacherInfoReq.attach_data)
  return *attach_data_;
}
inline void IMOtherPlatFormGetTeacherInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherPlatFormGetTeacherInfoReq.attach_data)
}
inline void IMOtherPlatFormGetTeacherInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMOtherPlatFormGetTeacherInfoReq.attach_data)
}
inline void IMOtherPlatFormGetTeacherInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMOtherPlatFormGetTeacherInfoReq.attach_data)
}
inline ::std::string* IMOtherPlatFormGetTeacherInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMOtherPlatFormGetTeacherInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMOtherPlatFormGetTeacherInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMOtherPlatFormGetTeacherInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMOtherPlatFormGetTeacherInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMOtherPlatFormGetTeacherInfoResp

// required uint32 http_handle = 1;
inline bool IMOtherPlatFormGetTeacherInfoResp::has_http_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMOtherPlatFormGetTeacherInfoResp::set_has_http_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMOtherPlatFormGetTeacherInfoResp::clear_has_http_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMOtherPlatFormGetTeacherInfoResp::clear_http_handle() {
  http_handle_ = 0u;
  clear_has_http_handle();
}
inline ::google::protobuf::uint32 IMOtherPlatFormGetTeacherInfoResp::http_handle() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherPlatFormGetTeacherInfoResp.http_handle)
  return http_handle_;
}
inline void IMOtherPlatFormGetTeacherInfoResp::set_http_handle(::google::protobuf::uint32 value) {
  set_has_http_handle();
  http_handle_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherPlatFormGetTeacherInfoResp.http_handle)
}

// repeated .IM.Other.TeacherInfo teacher_info_list = 2;
inline int IMOtherPlatFormGetTeacherInfoResp::teacher_info_list_size() const {
  return teacher_info_list_.size();
}
inline void IMOtherPlatFormGetTeacherInfoResp::clear_teacher_info_list() {
  teacher_info_list_.Clear();
}
inline const ::IM::Other::TeacherInfo& IMOtherPlatFormGetTeacherInfoResp::teacher_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherPlatFormGetTeacherInfoResp.teacher_info_list)
  return teacher_info_list_.Get(index);
}
inline ::IM::Other::TeacherInfo* IMOtherPlatFormGetTeacherInfoResp::mutable_teacher_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Other.IMOtherPlatFormGetTeacherInfoResp.teacher_info_list)
  return teacher_info_list_.Mutable(index);
}
inline ::IM::Other::TeacherInfo* IMOtherPlatFormGetTeacherInfoResp::add_teacher_info_list() {
  // @@protoc_insertion_point(field_add:IM.Other.IMOtherPlatFormGetTeacherInfoResp.teacher_info_list)
  return teacher_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherInfo >&
IMOtherPlatFormGetTeacherInfoResp::teacher_info_list() const {
  // @@protoc_insertion_point(field_list:IM.Other.IMOtherPlatFormGetTeacherInfoResp.teacher_info_list)
  return teacher_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Other::TeacherInfo >*
IMOtherPlatFormGetTeacherInfoResp::mutable_teacher_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Other.IMOtherPlatFormGetTeacherInfoResp.teacher_info_list)
  return &teacher_info_list_;
}

// required uint32 result = 3;
inline bool IMOtherPlatFormGetTeacherInfoResp::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMOtherPlatFormGetTeacherInfoResp::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMOtherPlatFormGetTeacherInfoResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMOtherPlatFormGetTeacherInfoResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMOtherPlatFormGetTeacherInfoResp::result() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherPlatFormGetTeacherInfoResp.result)
  return result_;
}
inline void IMOtherPlatFormGetTeacherInfoResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherPlatFormGetTeacherInfoResp.result)
}

// optional bytes attach_data = 20;
inline bool IMOtherPlatFormGetTeacherInfoResp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMOtherPlatFormGetTeacherInfoResp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMOtherPlatFormGetTeacherInfoResp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMOtherPlatFormGetTeacherInfoResp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMOtherPlatFormGetTeacherInfoResp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMOtherPlatFormGetTeacherInfoResp.attach_data)
  return *attach_data_;
}
inline void IMOtherPlatFormGetTeacherInfoResp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMOtherPlatFormGetTeacherInfoResp.attach_data)
}
inline void IMOtherPlatFormGetTeacherInfoResp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMOtherPlatFormGetTeacherInfoResp.attach_data)
}
inline void IMOtherPlatFormGetTeacherInfoResp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMOtherPlatFormGetTeacherInfoResp.attach_data)
}
inline ::std::string* IMOtherPlatFormGetTeacherInfoResp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMOtherPlatFormGetTeacherInfoResp.attach_data)
  return attach_data_;
}
inline ::std::string* IMOtherPlatFormGetTeacherInfoResp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMOtherPlatFormGetTeacherInfoResp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMOtherPlatFormGetTeacherInfoResp.attach_data)
}

// -------------------------------------------------------------------

// IMRPCMsgData

// required uint32 user_id = 1;
inline bool IMRPCMsgData::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRPCMsgData::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRPCMsgData::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRPCMsgData::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRPCMsgData::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.user_id)
  return user_id_;
}
inline void IMRPCMsgData::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMRPCMsgData.user_id)
}

// required string user_name = 2;
inline bool IMRPCMsgData::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRPCMsgData::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRPCMsgData::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRPCMsgData::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& IMRPCMsgData::user_name() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.user_name)
  return *user_name_;
}
inline void IMRPCMsgData::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMRPCMsgData.user_name)
}
inline void IMRPCMsgData::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMRPCMsgData.user_name)
}
inline void IMRPCMsgData::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMRPCMsgData.user_name)
}
inline ::std::string* IMRPCMsgData::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMRPCMsgData.user_name)
  return user_name_;
}
inline ::std::string* IMRPCMsgData::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCMsgData::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMRPCMsgData.user_name)
}

// required string user_portrait = 3;
inline bool IMRPCMsgData::has_user_portrait() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRPCMsgData::set_has_user_portrait() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRPCMsgData::clear_has_user_portrait() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRPCMsgData::clear_user_portrait() {
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_->clear();
  }
  clear_has_user_portrait();
}
inline const ::std::string& IMRPCMsgData::user_portrait() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.user_portrait)
  return *user_portrait_;
}
inline void IMRPCMsgData::set_user_portrait(const ::std::string& value) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMRPCMsgData.user_portrait)
}
inline void IMRPCMsgData::set_user_portrait(const char* value) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMRPCMsgData.user_portrait)
}
inline void IMRPCMsgData::set_user_portrait(const char* value, size_t size) {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  user_portrait_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMRPCMsgData.user_portrait)
}
inline ::std::string* IMRPCMsgData::mutable_user_portrait() {
  set_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_portrait_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMRPCMsgData.user_portrait)
  return user_portrait_;
}
inline ::std::string* IMRPCMsgData::release_user_portrait() {
  clear_has_user_portrait();
  if (user_portrait_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_portrait_;
    user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCMsgData::set_allocated_user_portrait(::std::string* user_portrait) {
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_portrait_;
  }
  if (user_portrait) {
    set_has_user_portrait();
    user_portrait_ = user_portrait;
  } else {
    clear_has_user_portrait();
    user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMRPCMsgData.user_portrait)
}

// required uint32 user_im_id = 4;
inline bool IMRPCMsgData::has_user_im_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRPCMsgData::set_has_user_im_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRPCMsgData::clear_has_user_im_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRPCMsgData::clear_user_im_id() {
  user_im_id_ = 0u;
  clear_has_user_im_id();
}
inline ::google::protobuf::uint32 IMRPCMsgData::user_im_id() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.user_im_id)
  return user_im_id_;
}
inline void IMRPCMsgData::set_user_im_id(::google::protobuf::uint32 value) {
  set_has_user_im_id();
  user_im_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMRPCMsgData.user_im_id)
}

// required uint32 msg_type = 5;
inline bool IMRPCMsgData::has_msg_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRPCMsgData::set_has_msg_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRPCMsgData::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRPCMsgData::clear_msg_type() {
  msg_type_ = 0u;
  clear_has_msg_type();
}
inline ::google::protobuf::uint32 IMRPCMsgData::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.msg_type)
  return msg_type_;
}
inline void IMRPCMsgData::set_msg_type(::google::protobuf::uint32 value) {
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMRPCMsgData.msg_type)
}

// required bytes msg_data = 6;
inline bool IMRPCMsgData::has_msg_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMRPCMsgData::set_has_msg_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMRPCMsgData::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMRPCMsgData::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& IMRPCMsgData::msg_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.msg_data)
  return *msg_data_;
}
inline void IMRPCMsgData::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMRPCMsgData.msg_data)
}
inline void IMRPCMsgData::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMRPCMsgData.msg_data)
}
inline void IMRPCMsgData::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMRPCMsgData.msg_data)
}
inline ::std::string* IMRPCMsgData::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMRPCMsgData.msg_data)
  return msg_data_;
}
inline ::std::string* IMRPCMsgData::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCMsgData::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMRPCMsgData.msg_data)
}

// required uint32 create_time = 7;
inline bool IMRPCMsgData::has_create_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMRPCMsgData::set_has_create_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMRPCMsgData::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMRPCMsgData::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 IMRPCMsgData::create_time() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.create_time)
  return create_time_;
}
inline void IMRPCMsgData::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMRPCMsgData.create_time)
}

// repeated .IM.RPC.GroupMsgRes group_msg_res_list = 8;
inline int IMRPCMsgData::group_msg_res_list_size() const {
  return group_msg_res_list_.size();
}
inline void IMRPCMsgData::clear_group_msg_res_list() {
  group_msg_res_list_.Clear();
}
inline const ::IM::RPC::GroupMsgRes& IMRPCMsgData::group_msg_res_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.group_msg_res_list)
  return group_msg_res_list_.Get(index);
}
inline ::IM::RPC::GroupMsgRes* IMRPCMsgData::mutable_group_msg_res_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Other.IMRPCMsgData.group_msg_res_list)
  return group_msg_res_list_.Mutable(index);
}
inline ::IM::RPC::GroupMsgRes* IMRPCMsgData::add_group_msg_res_list() {
  // @@protoc_insertion_point(field_add:IM.Other.IMRPCMsgData.group_msg_res_list)
  return group_msg_res_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >&
IMRPCMsgData::group_msg_res_list() const {
  // @@protoc_insertion_point(field_list:IM.Other.IMRPCMsgData.group_msg_res_list)
  return group_msg_res_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::RPC::GroupMsgRes >*
IMRPCMsgData::mutable_group_msg_res_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Other.IMRPCMsgData.group_msg_res_list)
  return &group_msg_res_list_;
}

// required .IM.RPC.TarsInfo tars_info = 9;
inline bool IMRPCMsgData::has_tars_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IMRPCMsgData::set_has_tars_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IMRPCMsgData::clear_has_tars_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IMRPCMsgData::clear_tars_info() {
  if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
  clear_has_tars_info();
}
inline const ::IM::RPC::TarsInfo& IMRPCMsgData::tars_info() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.tars_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tars_info_ != NULL ? *tars_info_ : *default_instance().tars_info_;
#else
  return tars_info_ != NULL ? *tars_info_ : *default_instance_->tars_info_;
#endif
}
inline ::IM::RPC::TarsInfo* IMRPCMsgData::mutable_tars_info() {
  set_has_tars_info();
  if (tars_info_ == NULL) tars_info_ = new ::IM::RPC::TarsInfo;
  // @@protoc_insertion_point(field_mutable:IM.Other.IMRPCMsgData.tars_info)
  return tars_info_;
}
inline ::IM::RPC::TarsInfo* IMRPCMsgData::release_tars_info() {
  clear_has_tars_info();
  ::IM::RPC::TarsInfo* temp = tars_info_;
  tars_info_ = NULL;
  return temp;
}
inline void IMRPCMsgData::set_allocated_tars_info(::IM::RPC::TarsInfo* tars_info) {
  delete tars_info_;
  tars_info_ = tars_info;
  if (tars_info) {
    set_has_tars_info();
  } else {
    clear_has_tars_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMRPCMsgData.tars_info)
}

// repeated .IM.BaseDefine.GroupMsgInfo msgs_info_list = 10;
inline int IMRPCMsgData::msgs_info_list_size() const {
  return msgs_info_list_.size();
}
inline void IMRPCMsgData::clear_msgs_info_list() {
  msgs_info_list_.Clear();
}
inline const ::IM::BaseDefine::GroupMsgInfo& IMRPCMsgData::msgs_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.msgs_info_list)
  return msgs_info_list_.Get(index);
}
inline ::IM::BaseDefine::GroupMsgInfo* IMRPCMsgData::mutable_msgs_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Other.IMRPCMsgData.msgs_info_list)
  return msgs_info_list_.Mutable(index);
}
inline ::IM::BaseDefine::GroupMsgInfo* IMRPCMsgData::add_msgs_info_list() {
  // @@protoc_insertion_point(field_add:IM.Other.IMRPCMsgData.msgs_info_list)
  return msgs_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupMsgInfo >&
IMRPCMsgData::msgs_info_list() const {
  // @@protoc_insertion_point(field_list:IM.Other.IMRPCMsgData.msgs_info_list)
  return msgs_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::GroupMsgInfo >*
IMRPCMsgData::mutable_msgs_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Other.IMRPCMsgData.msgs_info_list)
  return &msgs_info_list_;
}

// required uint32 result = 11;
inline bool IMRPCMsgData::has_result() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IMRPCMsgData::set_has_result() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IMRPCMsgData::clear_has_result() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IMRPCMsgData::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 IMRPCMsgData::result() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.result)
  return result_;
}
inline void IMRPCMsgData::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:IM.Other.IMRPCMsgData.result)
}

// optional bytes attach_data = 20;
inline bool IMRPCMsgData::has_attach_data() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IMRPCMsgData::set_has_attach_data() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IMRPCMsgData::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IMRPCMsgData::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRPCMsgData::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Other.IMRPCMsgData.attach_data)
  return *attach_data_;
}
inline void IMRPCMsgData::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Other.IMRPCMsgData.attach_data)
}
inline void IMRPCMsgData::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Other.IMRPCMsgData.attach_data)
}
inline void IMRPCMsgData::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Other.IMRPCMsgData.attach_data)
}
inline ::std::string* IMRPCMsgData::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Other.IMRPCMsgData.attach_data)
  return attach_data_;
}
inline ::std::string* IMRPCMsgData::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRPCMsgData::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Other.IMRPCMsgData.attach_data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Other
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eOther_2eproto__INCLUDED
