// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Other.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.Other.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace Other {

void protobuf_ShutdownFile_IM_2eOther_2eproto() {
  delete IMHeartBeat::default_instance_;
  delete IMSingleForbidReq::default_instance_;
  delete IMSingleForbidResp::default_instance_;
  delete IMSingleForbidNotify::default_instance_;
  delete IMSingleGetForbiddenReq::default_instance_;
  delete IMSingleGetForbiddenResp::default_instance_;
  delete IMSingleShieldReq::default_instance_;
  delete IMSingleShieldResp::default_instance_;
  delete IMSingleGetShieldReq::default_instance_;
  delete IMSingleGetShieldResp::default_instance_;
  delete IMGetDeliverMsgReq::default_instance_;
  delete IMGetDeliverMsgResp::default_instance_;
  delete TeacherQuqueInfo::default_instance_;
  delete StudentQuqueInfo::default_instance_;
  delete IMGetConsultQueueReq::default_instance_;
  delete IMGetConsultQueueResp::default_instance_;
  delete DBServerInfo::default_instance_;
  delete IMOtherGetDbServerCntReq::default_instance_;
  delete IMOtherGetDbServerCntResp::default_instance_;
  delete IMOtherSetDbServerCntReq::default_instance_;
  delete IMOtherSetDbServerCntResp::default_instance_;
  delete TeacherInfo::default_instance_;
  delete IMOtherPlatFormGetTeacherInfoReq::default_instance_;
  delete IMOtherPlatFormGetTeacherInfoResp::default_instance_;
  delete IMRPCMsgData::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eOther_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eOther_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::IM::BaseDefine::protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  ::IM::RPC::protobuf_AddDesc_IM_2eRPC_2eproto();
  IMHeartBeat::default_instance_ = new IMHeartBeat();
  IMSingleForbidReq::default_instance_ = new IMSingleForbidReq();
  IMSingleForbidResp::default_instance_ = new IMSingleForbidResp();
  IMSingleForbidNotify::default_instance_ = new IMSingleForbidNotify();
  IMSingleGetForbiddenReq::default_instance_ = new IMSingleGetForbiddenReq();
  IMSingleGetForbiddenResp::default_instance_ = new IMSingleGetForbiddenResp();
  IMSingleShieldReq::default_instance_ = new IMSingleShieldReq();
  IMSingleShieldResp::default_instance_ = new IMSingleShieldResp();
  IMSingleGetShieldReq::default_instance_ = new IMSingleGetShieldReq();
  IMSingleGetShieldResp::default_instance_ = new IMSingleGetShieldResp();
  IMGetDeliverMsgReq::default_instance_ = new IMGetDeliverMsgReq();
  IMGetDeliverMsgResp::default_instance_ = new IMGetDeliverMsgResp();
  TeacherQuqueInfo::default_instance_ = new TeacherQuqueInfo();
  StudentQuqueInfo::default_instance_ = new StudentQuqueInfo();
  IMGetConsultQueueReq::default_instance_ = new IMGetConsultQueueReq();
  IMGetConsultQueueResp::default_instance_ = new IMGetConsultQueueResp();
  DBServerInfo::default_instance_ = new DBServerInfo();
  IMOtherGetDbServerCntReq::default_instance_ = new IMOtherGetDbServerCntReq();
  IMOtherGetDbServerCntResp::default_instance_ = new IMOtherGetDbServerCntResp();
  IMOtherSetDbServerCntReq::default_instance_ = new IMOtherSetDbServerCntReq();
  IMOtherSetDbServerCntResp::default_instance_ = new IMOtherSetDbServerCntResp();
  TeacherInfo::default_instance_ = new TeacherInfo();
  IMOtherPlatFormGetTeacherInfoReq::default_instance_ = new IMOtherPlatFormGetTeacherInfoReq();
  IMOtherPlatFormGetTeacherInfoResp::default_instance_ = new IMOtherPlatFormGetTeacherInfoResp();
  IMRPCMsgData::default_instance_ = new IMRPCMsgData();
  IMHeartBeat::default_instance_->InitAsDefaultInstance();
  IMSingleForbidReq::default_instance_->InitAsDefaultInstance();
  IMSingleForbidResp::default_instance_->InitAsDefaultInstance();
  IMSingleForbidNotify::default_instance_->InitAsDefaultInstance();
  IMSingleGetForbiddenReq::default_instance_->InitAsDefaultInstance();
  IMSingleGetForbiddenResp::default_instance_->InitAsDefaultInstance();
  IMSingleShieldReq::default_instance_->InitAsDefaultInstance();
  IMSingleShieldResp::default_instance_->InitAsDefaultInstance();
  IMSingleGetShieldReq::default_instance_->InitAsDefaultInstance();
  IMSingleGetShieldResp::default_instance_->InitAsDefaultInstance();
  IMGetDeliverMsgReq::default_instance_->InitAsDefaultInstance();
  IMGetDeliverMsgResp::default_instance_->InitAsDefaultInstance();
  TeacherQuqueInfo::default_instance_->InitAsDefaultInstance();
  StudentQuqueInfo::default_instance_->InitAsDefaultInstance();
  IMGetConsultQueueReq::default_instance_->InitAsDefaultInstance();
  IMGetConsultQueueResp::default_instance_->InitAsDefaultInstance();
  DBServerInfo::default_instance_->InitAsDefaultInstance();
  IMOtherGetDbServerCntReq::default_instance_->InitAsDefaultInstance();
  IMOtherGetDbServerCntResp::default_instance_->InitAsDefaultInstance();
  IMOtherSetDbServerCntReq::default_instance_->InitAsDefaultInstance();
  IMOtherSetDbServerCntResp::default_instance_->InitAsDefaultInstance();
  TeacherInfo::default_instance_->InitAsDefaultInstance();
  IMOtherPlatFormGetTeacherInfoReq::default_instance_->InitAsDefaultInstance();
  IMOtherPlatFormGetTeacherInfoResp::default_instance_->InitAsDefaultInstance();
  IMRPCMsgData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eOther_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eOther_2eproto_once_);
void protobuf_AddDesc_IM_2eOther_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eOther_2eproto_once_,
                 &protobuf_AddDesc_IM_2eOther_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eOther_2eproto {
  StaticDescriptorInitializer_IM_2eOther_2eproto() {
    protobuf_AddDesc_IM_2eOther_2eproto();
  }
} static_descriptor_initializer_IM_2eOther_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

IMHeartBeat::IMHeartBeat()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMHeartBeat)
}

void IMHeartBeat::InitAsDefaultInstance() {
}

IMHeartBeat::IMHeartBeat(const IMHeartBeat& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMHeartBeat)
}

void IMHeartBeat::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMHeartBeat::~IMHeartBeat() {
  // @@protoc_insertion_point(destructor:IM.Other.IMHeartBeat)
  SharedDtor();
}

void IMHeartBeat::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMHeartBeat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMHeartBeat& IMHeartBeat::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMHeartBeat* IMHeartBeat::default_instance_ = NULL;

IMHeartBeat* IMHeartBeat::New() const {
  return new IMHeartBeat;
}

void IMHeartBeat::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMHeartBeat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMHeartBeat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMHeartBeat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMHeartBeat)
  return false;
#undef DO_
}

void IMHeartBeat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMHeartBeat)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMHeartBeat)
}

int IMHeartBeat::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMHeartBeat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMHeartBeat*>(&from));
}

void IMHeartBeat::MergeFrom(const IMHeartBeat& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMHeartBeat::CopyFrom(const IMHeartBeat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMHeartBeat::IsInitialized() const {

  return true;
}

void IMHeartBeat::Swap(IMHeartBeat* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMHeartBeat::GetTypeName() const {
  return "IM.Other.IMHeartBeat";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSingleForbidReq::kUserIdFieldNumber;
const int IMSingleForbidReq::kStateFieldNumber;
const int IMSingleForbidReq::kHttpHandleFieldNumber;
const int IMSingleForbidReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMSingleForbidReq::IMSingleForbidReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMSingleForbidReq)
}

void IMSingleForbidReq::InitAsDefaultInstance() {
}

IMSingleForbidReq::IMSingleForbidReq(const IMSingleForbidReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMSingleForbidReq)
}

void IMSingleForbidReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  state_ = 0u;
  http_handle_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSingleForbidReq::~IMSingleForbidReq() {
  // @@protoc_insertion_point(destructor:IM.Other.IMSingleForbidReq)
  SharedDtor();
}

void IMSingleForbidReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSingleForbidReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSingleForbidReq& IMSingleForbidReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMSingleForbidReq* IMSingleForbidReq::default_instance_ = NULL;

IMSingleForbidReq* IMSingleForbidReq::New() const {
  return new IMSingleForbidReq;
}

void IMSingleForbidReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMSingleForbidReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(user_id_, state_);
    http_handle_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSingleForbidReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMSingleForbidReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // required uint32 state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_http_handle;
        break;
      }

      // required uint32 http_handle = 3;
      case 3: {
        if (tag == 24) {
         parse_http_handle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMSingleForbidReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMSingleForbidReq)
  return false;
#undef DO_
}

void IMSingleForbidReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMSingleForbidReq)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->state(), output);
  }

  // required uint32 http_handle = 3;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->http_handle(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMSingleForbidReq)
}

int IMSingleForbidReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

    // required uint32 http_handle = 3;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSingleForbidReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSingleForbidReq*>(&from));
}

void IMSingleForbidReq::MergeFrom(const IMSingleForbidReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSingleForbidReq::CopyFrom(const IMSingleForbidReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSingleForbidReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMSingleForbidReq::Swap(IMSingleForbidReq* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(state_, other->state_);
    std::swap(http_handle_, other->http_handle_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSingleForbidReq::GetTypeName() const {
  return "IM.Other.IMSingleForbidReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSingleForbidResp::kUserIdFieldNumber;
const int IMSingleForbidResp::kStateFieldNumber;
const int IMSingleForbidResp::kHttpHandleFieldNumber;
const int IMSingleForbidResp::kResultCodeFieldNumber;
const int IMSingleForbidResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMSingleForbidResp::IMSingleForbidResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMSingleForbidResp)
}

void IMSingleForbidResp::InitAsDefaultInstance() {
}

IMSingleForbidResp::IMSingleForbidResp(const IMSingleForbidResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMSingleForbidResp)
}

void IMSingleForbidResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  state_ = 0u;
  http_handle_ = 0u;
  result_code_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSingleForbidResp::~IMSingleForbidResp() {
  // @@protoc_insertion_point(destructor:IM.Other.IMSingleForbidResp)
  SharedDtor();
}

void IMSingleForbidResp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSingleForbidResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSingleForbidResp& IMSingleForbidResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMSingleForbidResp* IMSingleForbidResp::default_instance_ = NULL;

IMSingleForbidResp* IMSingleForbidResp::New() const {
  return new IMSingleForbidResp;
}

void IMSingleForbidResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMSingleForbidResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(user_id_, result_code_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSingleForbidResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMSingleForbidResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // required uint32 state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_http_handle;
        break;
      }

      // required uint32 http_handle = 3;
      case 3: {
        if (tag == 24) {
         parse_http_handle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_result_code;
        break;
      }

      // required uint32 result_code = 4;
      case 4: {
        if (tag == 32) {
         parse_result_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMSingleForbidResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMSingleForbidResp)
  return false;
#undef DO_
}

void IMSingleForbidResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMSingleForbidResp)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->state(), output);
  }

  // required uint32 http_handle = 3;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->http_handle(), output);
  }

  // required uint32 result_code = 4;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->result_code(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMSingleForbidResp)
}

int IMSingleForbidResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

    // required uint32 http_handle = 3;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

    // required uint32 result_code = 4;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSingleForbidResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSingleForbidResp*>(&from));
}

void IMSingleForbidResp::MergeFrom(const IMSingleForbidResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSingleForbidResp::CopyFrom(const IMSingleForbidResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSingleForbidResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void IMSingleForbidResp::Swap(IMSingleForbidResp* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(state_, other->state_);
    std::swap(http_handle_, other->http_handle_);
    std::swap(result_code_, other->result_code_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSingleForbidResp::GetTypeName() const {
  return "IM.Other.IMSingleForbidResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSingleForbidNotify::kUserIdFieldNumber;
const int IMSingleForbidNotify::kStateFieldNumber;
const int IMSingleForbidNotify::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMSingleForbidNotify::IMSingleForbidNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMSingleForbidNotify)
}

void IMSingleForbidNotify::InitAsDefaultInstance() {
}

IMSingleForbidNotify::IMSingleForbidNotify(const IMSingleForbidNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMSingleForbidNotify)
}

void IMSingleForbidNotify::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  state_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSingleForbidNotify::~IMSingleForbidNotify() {
  // @@protoc_insertion_point(destructor:IM.Other.IMSingleForbidNotify)
  SharedDtor();
}

void IMSingleForbidNotify::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSingleForbidNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSingleForbidNotify& IMSingleForbidNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMSingleForbidNotify* IMSingleForbidNotify::default_instance_ = NULL;

IMSingleForbidNotify* IMSingleForbidNotify::New() const {
  return new IMSingleForbidNotify;
}

void IMSingleForbidNotify::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMSingleForbidNotify*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(user_id_, state_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSingleForbidNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMSingleForbidNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // required uint32 state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMSingleForbidNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMSingleForbidNotify)
  return false;
#undef DO_
}

void IMSingleForbidNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMSingleForbidNotify)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->state(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMSingleForbidNotify)
}

int IMSingleForbidNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSingleForbidNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSingleForbidNotify*>(&from));
}

void IMSingleForbidNotify::MergeFrom(const IMSingleForbidNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSingleForbidNotify::CopyFrom(const IMSingleForbidNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSingleForbidNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMSingleForbidNotify::Swap(IMSingleForbidNotify* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(state_, other->state_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSingleForbidNotify::GetTypeName() const {
  return "IM.Other.IMSingleForbidNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSingleGetForbiddenReq::kUserIdFieldNumber;
const int IMSingleGetForbiddenReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMSingleGetForbiddenReq::IMSingleGetForbiddenReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMSingleGetForbiddenReq)
}

void IMSingleGetForbiddenReq::InitAsDefaultInstance() {
}

IMSingleGetForbiddenReq::IMSingleGetForbiddenReq(const IMSingleGetForbiddenReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMSingleGetForbiddenReq)
}

void IMSingleGetForbiddenReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSingleGetForbiddenReq::~IMSingleGetForbiddenReq() {
  // @@protoc_insertion_point(destructor:IM.Other.IMSingleGetForbiddenReq)
  SharedDtor();
}

void IMSingleGetForbiddenReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSingleGetForbiddenReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSingleGetForbiddenReq& IMSingleGetForbiddenReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMSingleGetForbiddenReq* IMSingleGetForbiddenReq::default_instance_ = NULL;

IMSingleGetForbiddenReq* IMSingleGetForbiddenReq::New() const {
  return new IMSingleGetForbiddenReq;
}

void IMSingleGetForbiddenReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    user_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSingleGetForbiddenReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMSingleGetForbiddenReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMSingleGetForbiddenReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMSingleGetForbiddenReq)
  return false;
#undef DO_
}

void IMSingleGetForbiddenReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMSingleGetForbiddenReq)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMSingleGetForbiddenReq)
}

int IMSingleGetForbiddenReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSingleGetForbiddenReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSingleGetForbiddenReq*>(&from));
}

void IMSingleGetForbiddenReq::MergeFrom(const IMSingleGetForbiddenReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSingleGetForbiddenReq::CopyFrom(const IMSingleGetForbiddenReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSingleGetForbiddenReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMSingleGetForbiddenReq::Swap(IMSingleGetForbiddenReq* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSingleGetForbiddenReq::GetTypeName() const {
  return "IM.Other.IMSingleGetForbiddenReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSingleGetForbiddenResp::kUserIdFieldNumber;
const int IMSingleGetForbiddenResp::kStateFieldNumber;
const int IMSingleGetForbiddenResp::kResultCodeFieldNumber;
const int IMSingleGetForbiddenResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMSingleGetForbiddenResp::IMSingleGetForbiddenResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMSingleGetForbiddenResp)
}

void IMSingleGetForbiddenResp::InitAsDefaultInstance() {
}

IMSingleGetForbiddenResp::IMSingleGetForbiddenResp(const IMSingleGetForbiddenResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMSingleGetForbiddenResp)
}

void IMSingleGetForbiddenResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  state_ = 0u;
  result_code_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSingleGetForbiddenResp::~IMSingleGetForbiddenResp() {
  // @@protoc_insertion_point(destructor:IM.Other.IMSingleGetForbiddenResp)
  SharedDtor();
}

void IMSingleGetForbiddenResp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSingleGetForbiddenResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSingleGetForbiddenResp& IMSingleGetForbiddenResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMSingleGetForbiddenResp* IMSingleGetForbiddenResp::default_instance_ = NULL;

IMSingleGetForbiddenResp* IMSingleGetForbiddenResp::New() const {
  return new IMSingleGetForbiddenResp;
}

void IMSingleGetForbiddenResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMSingleGetForbiddenResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(user_id_, state_);
    result_code_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSingleGetForbiddenResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMSingleGetForbiddenResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // required uint32 state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_result_code;
        break;
      }

      // required uint32 result_code = 3;
      case 3: {
        if (tag == 24) {
         parse_result_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMSingleGetForbiddenResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMSingleGetForbiddenResp)
  return false;
#undef DO_
}

void IMSingleGetForbiddenResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMSingleGetForbiddenResp)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->state(), output);
  }

  // required uint32 result_code = 3;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->result_code(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMSingleGetForbiddenResp)
}

int IMSingleGetForbiddenResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

    // required uint32 result_code = 3;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSingleGetForbiddenResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSingleGetForbiddenResp*>(&from));
}

void IMSingleGetForbiddenResp::MergeFrom(const IMSingleGetForbiddenResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSingleGetForbiddenResp::CopyFrom(const IMSingleGetForbiddenResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSingleGetForbiddenResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMSingleGetForbiddenResp::Swap(IMSingleGetForbiddenResp* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(state_, other->state_);
    std::swap(result_code_, other->result_code_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSingleGetForbiddenResp::GetTypeName() const {
  return "IM.Other.IMSingleGetForbiddenResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSingleShieldReq::kUserIdFieldNumber;
const int IMSingleShieldReq::kPeerIdFieldNumber;
const int IMSingleShieldReq::kStateFieldNumber;
const int IMSingleShieldReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMSingleShieldReq::IMSingleShieldReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMSingleShieldReq)
}

void IMSingleShieldReq::InitAsDefaultInstance() {
}

IMSingleShieldReq::IMSingleShieldReq(const IMSingleShieldReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMSingleShieldReq)
}

void IMSingleShieldReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  peer_id_ = 0u;
  state_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSingleShieldReq::~IMSingleShieldReq() {
  // @@protoc_insertion_point(destructor:IM.Other.IMSingleShieldReq)
  SharedDtor();
}

void IMSingleShieldReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSingleShieldReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSingleShieldReq& IMSingleShieldReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMSingleShieldReq* IMSingleShieldReq::default_instance_ = NULL;

IMSingleShieldReq* IMSingleShieldReq::New() const {
  return new IMSingleShieldReq;
}

void IMSingleShieldReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMSingleShieldReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(user_id_, peer_id_);
    state_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSingleShieldReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMSingleShieldReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_peer_id;
        break;
      }

      // required uint32 peer_id = 2;
      case 2: {
        if (tag == 16) {
         parse_peer_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peer_id_)));
          set_has_peer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_state;
        break;
      }

      // required uint32 state = 3;
      case 3: {
        if (tag == 24) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMSingleShieldReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMSingleShieldReq)
  return false;
#undef DO_
}

void IMSingleShieldReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMSingleShieldReq)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 peer_id = 2;
  if (has_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->peer_id(), output);
  }

  // required uint32 state = 3;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->state(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMSingleShieldReq)
}

int IMSingleShieldReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 peer_id = 2;
    if (has_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peer_id());
    }

    // required uint32 state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSingleShieldReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSingleShieldReq*>(&from));
}

void IMSingleShieldReq::MergeFrom(const IMSingleShieldReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_peer_id()) {
      set_peer_id(from.peer_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSingleShieldReq::CopyFrom(const IMSingleShieldReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSingleShieldReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMSingleShieldReq::Swap(IMSingleShieldReq* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(peer_id_, other->peer_id_);
    std::swap(state_, other->state_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSingleShieldReq::GetTypeName() const {
  return "IM.Other.IMSingleShieldReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSingleShieldResp::kUserIdFieldNumber;
const int IMSingleShieldResp::kPeerIdFieldNumber;
const int IMSingleShieldResp::kStateFieldNumber;
const int IMSingleShieldResp::kResultCodeFieldNumber;
const int IMSingleShieldResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMSingleShieldResp::IMSingleShieldResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMSingleShieldResp)
}

void IMSingleShieldResp::InitAsDefaultInstance() {
}

IMSingleShieldResp::IMSingleShieldResp(const IMSingleShieldResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMSingleShieldResp)
}

void IMSingleShieldResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  peer_id_ = 0u;
  state_ = 0u;
  result_code_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSingleShieldResp::~IMSingleShieldResp() {
  // @@protoc_insertion_point(destructor:IM.Other.IMSingleShieldResp)
  SharedDtor();
}

void IMSingleShieldResp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSingleShieldResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSingleShieldResp& IMSingleShieldResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMSingleShieldResp* IMSingleShieldResp::default_instance_ = NULL;

IMSingleShieldResp* IMSingleShieldResp::New() const {
  return new IMSingleShieldResp;
}

void IMSingleShieldResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMSingleShieldResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(user_id_, result_code_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSingleShieldResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMSingleShieldResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_peer_id;
        break;
      }

      // required uint32 peer_id = 2;
      case 2: {
        if (tag == 16) {
         parse_peer_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peer_id_)));
          set_has_peer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_state;
        break;
      }

      // required uint32 state = 3;
      case 3: {
        if (tag == 24) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_result_code;
        break;
      }

      // required uint32 result_code = 4;
      case 4: {
        if (tag == 32) {
         parse_result_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMSingleShieldResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMSingleShieldResp)
  return false;
#undef DO_
}

void IMSingleShieldResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMSingleShieldResp)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 peer_id = 2;
  if (has_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->peer_id(), output);
  }

  // required uint32 state = 3;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->state(), output);
  }

  // required uint32 result_code = 4;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->result_code(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMSingleShieldResp)
}

int IMSingleShieldResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 peer_id = 2;
    if (has_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peer_id());
    }

    // required uint32 state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

    // required uint32 result_code = 4;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSingleShieldResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSingleShieldResp*>(&from));
}

void IMSingleShieldResp::MergeFrom(const IMSingleShieldResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_peer_id()) {
      set_peer_id(from.peer_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSingleShieldResp::CopyFrom(const IMSingleShieldResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSingleShieldResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void IMSingleShieldResp::Swap(IMSingleShieldResp* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(peer_id_, other->peer_id_);
    std::swap(state_, other->state_);
    std::swap(result_code_, other->result_code_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSingleShieldResp::GetTypeName() const {
  return "IM.Other.IMSingleShieldResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSingleGetShieldReq::kUserIdFieldNumber;
const int IMSingleGetShieldReq::kPeerIdFieldNumber;
const int IMSingleGetShieldReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMSingleGetShieldReq::IMSingleGetShieldReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMSingleGetShieldReq)
}

void IMSingleGetShieldReq::InitAsDefaultInstance() {
}

IMSingleGetShieldReq::IMSingleGetShieldReq(const IMSingleGetShieldReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMSingleGetShieldReq)
}

void IMSingleGetShieldReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  peer_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSingleGetShieldReq::~IMSingleGetShieldReq() {
  // @@protoc_insertion_point(destructor:IM.Other.IMSingleGetShieldReq)
  SharedDtor();
}

void IMSingleGetShieldReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSingleGetShieldReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSingleGetShieldReq& IMSingleGetShieldReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMSingleGetShieldReq* IMSingleGetShieldReq::default_instance_ = NULL;

IMSingleGetShieldReq* IMSingleGetShieldReq::New() const {
  return new IMSingleGetShieldReq;
}

void IMSingleGetShieldReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMSingleGetShieldReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(user_id_, peer_id_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSingleGetShieldReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMSingleGetShieldReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_peer_id;
        break;
      }

      // required uint32 peer_id = 2;
      case 2: {
        if (tag == 16) {
         parse_peer_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peer_id_)));
          set_has_peer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMSingleGetShieldReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMSingleGetShieldReq)
  return false;
#undef DO_
}

void IMSingleGetShieldReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMSingleGetShieldReq)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 peer_id = 2;
  if (has_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->peer_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMSingleGetShieldReq)
}

int IMSingleGetShieldReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 peer_id = 2;
    if (has_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peer_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSingleGetShieldReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSingleGetShieldReq*>(&from));
}

void IMSingleGetShieldReq::MergeFrom(const IMSingleGetShieldReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_peer_id()) {
      set_peer_id(from.peer_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSingleGetShieldReq::CopyFrom(const IMSingleGetShieldReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSingleGetShieldReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMSingleGetShieldReq::Swap(IMSingleGetShieldReq* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(peer_id_, other->peer_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSingleGetShieldReq::GetTypeName() const {
  return "IM.Other.IMSingleGetShieldReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSingleGetShieldResp::kUserIdFieldNumber;
const int IMSingleGetShieldResp::kPeerIdFieldNumber;
const int IMSingleGetShieldResp::kStateFieldNumber;
const int IMSingleGetShieldResp::kResultCodeFieldNumber;
const int IMSingleGetShieldResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMSingleGetShieldResp::IMSingleGetShieldResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMSingleGetShieldResp)
}

void IMSingleGetShieldResp::InitAsDefaultInstance() {
}

IMSingleGetShieldResp::IMSingleGetShieldResp(const IMSingleGetShieldResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMSingleGetShieldResp)
}

void IMSingleGetShieldResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  peer_id_ = 0u;
  state_ = 0u;
  result_code_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSingleGetShieldResp::~IMSingleGetShieldResp() {
  // @@protoc_insertion_point(destructor:IM.Other.IMSingleGetShieldResp)
  SharedDtor();
}

void IMSingleGetShieldResp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSingleGetShieldResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSingleGetShieldResp& IMSingleGetShieldResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMSingleGetShieldResp* IMSingleGetShieldResp::default_instance_ = NULL;

IMSingleGetShieldResp* IMSingleGetShieldResp::New() const {
  return new IMSingleGetShieldResp;
}

void IMSingleGetShieldResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMSingleGetShieldResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(user_id_, result_code_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSingleGetShieldResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMSingleGetShieldResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_peer_id;
        break;
      }

      // required uint32 peer_id = 2;
      case 2: {
        if (tag == 16) {
         parse_peer_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peer_id_)));
          set_has_peer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_state;
        break;
      }

      // required uint32 state = 3;
      case 3: {
        if (tag == 24) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_result_code;
        break;
      }

      // required uint32 result_code = 4;
      case 4: {
        if (tag == 32) {
         parse_result_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMSingleGetShieldResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMSingleGetShieldResp)
  return false;
#undef DO_
}

void IMSingleGetShieldResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMSingleGetShieldResp)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 peer_id = 2;
  if (has_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->peer_id(), output);
  }

  // required uint32 state = 3;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->state(), output);
  }

  // required uint32 result_code = 4;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->result_code(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMSingleGetShieldResp)
}

int IMSingleGetShieldResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 peer_id = 2;
    if (has_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peer_id());
    }

    // required uint32 state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

    // required uint32 result_code = 4;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSingleGetShieldResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSingleGetShieldResp*>(&from));
}

void IMSingleGetShieldResp::MergeFrom(const IMSingleGetShieldResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_peer_id()) {
      set_peer_id(from.peer_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSingleGetShieldResp::CopyFrom(const IMSingleGetShieldResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSingleGetShieldResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void IMSingleGetShieldResp::Swap(IMSingleGetShieldResp* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(peer_id_, other->peer_id_);
    std::swap(state_, other->state_);
    std::swap(result_code_, other->result_code_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSingleGetShieldResp::GetTypeName() const {
  return "IM.Other.IMSingleGetShieldResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetDeliverMsgReq::kOldConsultIdFieldNumber;
const int IMGetDeliverMsgReq::kNewConsultIdFieldNumber;
const int IMGetDeliverMsgReq::kStudentIdFieldNumber;
const int IMGetDeliverMsgReq::kDutyIdFieldNumber;
const int IMGetDeliverMsgReq::kManagerIdFieldNumber;
const int IMGetDeliverMsgReq::kOrderIdFieldNumber;
const int IMGetDeliverMsgReq::kDeliverTypeFieldNumber;
const int IMGetDeliverMsgReq::kManagerNameFieldNumber;
const int IMGetDeliverMsgReq::kManagerPortraitFieldNumber;
#endif  // !_MSC_VER

IMGetDeliverMsgReq::IMGetDeliverMsgReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMGetDeliverMsgReq)
}

void IMGetDeliverMsgReq::InitAsDefaultInstance() {
}

IMGetDeliverMsgReq::IMGetDeliverMsgReq(const IMGetDeliverMsgReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMGetDeliverMsgReq)
}

void IMGetDeliverMsgReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  old_consult_id_ = 0u;
  new_consult_id_ = 0u;
  student_id_ = 0u;
  duty_id_ = 0u;
  manager_id_ = 0u;
  order_id_ = 0u;
  deliver_type_ = 0u;
  manager_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  manager_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetDeliverMsgReq::~IMGetDeliverMsgReq() {
  // @@protoc_insertion_point(destructor:IM.Other.IMGetDeliverMsgReq)
  SharedDtor();
}

void IMGetDeliverMsgReq::SharedDtor() {
  if (manager_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manager_name_;
  }
  if (manager_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manager_portrait_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetDeliverMsgReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetDeliverMsgReq& IMGetDeliverMsgReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMGetDeliverMsgReq* IMGetDeliverMsgReq::default_instance_ = NULL;

IMGetDeliverMsgReq* IMGetDeliverMsgReq::New() const {
  return new IMGetDeliverMsgReq;
}

void IMGetDeliverMsgReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetDeliverMsgReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(old_consult_id_, order_id_);
    deliver_type_ = 0u;
    if (has_manager_name()) {
      if (manager_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        manager_name_->clear();
      }
    }
  }
  if (has_manager_portrait()) {
    if (manager_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      manager_portrait_->clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetDeliverMsgReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMGetDeliverMsgReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 old_consult_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &old_consult_id_)));
          set_has_old_consult_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_new_consult_id;
        break;
      }

      // required uint32 new_consult_id = 2;
      case 2: {
        if (tag == 16) {
         parse_new_consult_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &new_consult_id_)));
          set_has_new_consult_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_student_id;
        break;
      }

      // required uint32 student_id = 3;
      case 3: {
        if (tag == 24) {
         parse_student_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &student_id_)));
          set_has_student_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_duty_id;
        break;
      }

      // required uint32 duty_id = 4;
      case 4: {
        if (tag == 32) {
         parse_duty_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duty_id_)));
          set_has_duty_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_manager_id;
        break;
      }

      // required uint32 manager_id = 5;
      case 5: {
        if (tag == 40) {
         parse_manager_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &manager_id_)));
          set_has_manager_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_order_id;
        break;
      }

      // required uint32 order_id = 6;
      case 6: {
        if (tag == 48) {
         parse_order_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_id_)));
          set_has_order_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_deliver_type;
        break;
      }

      // required uint32 deliver_type = 7;
      case 7: {
        if (tag == 56) {
         parse_deliver_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &deliver_type_)));
          set_has_deliver_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_manager_name;
        break;
      }

      // optional string manager_name = 20;
      case 20: {
        if (tag == 162) {
         parse_manager_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manager_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_manager_portrait;
        break;
      }

      // optional string manager_portrait = 21;
      case 21: {
        if (tag == 170) {
         parse_manager_portrait:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manager_portrait()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMGetDeliverMsgReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMGetDeliverMsgReq)
  return false;
#undef DO_
}

void IMGetDeliverMsgReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMGetDeliverMsgReq)
  // required uint32 old_consult_id = 1;
  if (has_old_consult_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->old_consult_id(), output);
  }

  // required uint32 new_consult_id = 2;
  if (has_new_consult_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->new_consult_id(), output);
  }

  // required uint32 student_id = 3;
  if (has_student_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->student_id(), output);
  }

  // required uint32 duty_id = 4;
  if (has_duty_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->duty_id(), output);
  }

  // required uint32 manager_id = 5;
  if (has_manager_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->manager_id(), output);
  }

  // required uint32 order_id = 6;
  if (has_order_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->order_id(), output);
  }

  // required uint32 deliver_type = 7;
  if (has_deliver_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->deliver_type(), output);
  }

  // optional string manager_name = 20;
  if (has_manager_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      20, this->manager_name(), output);
  }

  // optional string manager_portrait = 21;
  if (has_manager_portrait()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      21, this->manager_portrait(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMGetDeliverMsgReq)
}

int IMGetDeliverMsgReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 old_consult_id = 1;
    if (has_old_consult_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->old_consult_id());
    }

    // required uint32 new_consult_id = 2;
    if (has_new_consult_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->new_consult_id());
    }

    // required uint32 student_id = 3;
    if (has_student_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->student_id());
    }

    // required uint32 duty_id = 4;
    if (has_duty_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duty_id());
    }

    // required uint32 manager_id = 5;
    if (has_manager_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->manager_id());
    }

    // required uint32 order_id = 6;
    if (has_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->order_id());
    }

    // required uint32 deliver_type = 7;
    if (has_deliver_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->deliver_type());
    }

    // optional string manager_name = 20;
    if (has_manager_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manager_name());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string manager_portrait = 21;
    if (has_manager_portrait()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manager_portrait());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetDeliverMsgReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeliverMsgReq*>(&from));
}

void IMGetDeliverMsgReq::MergeFrom(const IMGetDeliverMsgReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_old_consult_id()) {
      set_old_consult_id(from.old_consult_id());
    }
    if (from.has_new_consult_id()) {
      set_new_consult_id(from.new_consult_id());
    }
    if (from.has_student_id()) {
      set_student_id(from.student_id());
    }
    if (from.has_duty_id()) {
      set_duty_id(from.duty_id());
    }
    if (from.has_manager_id()) {
      set_manager_id(from.manager_id());
    }
    if (from.has_order_id()) {
      set_order_id(from.order_id());
    }
    if (from.has_deliver_type()) {
      set_deliver_type(from.deliver_type());
    }
    if (from.has_manager_name()) {
      set_manager_name(from.manager_name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_manager_portrait()) {
      set_manager_portrait(from.manager_portrait());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetDeliverMsgReq::CopyFrom(const IMGetDeliverMsgReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeliverMsgReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void IMGetDeliverMsgReq::Swap(IMGetDeliverMsgReq* other) {
  if (other != this) {
    std::swap(old_consult_id_, other->old_consult_id_);
    std::swap(new_consult_id_, other->new_consult_id_);
    std::swap(student_id_, other->student_id_);
    std::swap(duty_id_, other->duty_id_);
    std::swap(manager_id_, other->manager_id_);
    std::swap(order_id_, other->order_id_);
    std::swap(deliver_type_, other->deliver_type_);
    std::swap(manager_name_, other->manager_name_);
    std::swap(manager_portrait_, other->manager_portrait_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetDeliverMsgReq::GetTypeName() const {
  return "IM.Other.IMGetDeliverMsgReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetDeliverMsgResp::kOldConsultIdFieldNumber;
const int IMGetDeliverMsgResp::kNewConsultIdFieldNumber;
const int IMGetDeliverMsgResp::kStudentIdFieldNumber;
const int IMGetDeliverMsgResp::kDutyIdFieldNumber;
const int IMGetDeliverMsgResp::kManagerIdFieldNumber;
const int IMGetDeliverMsgResp::kOrderIdFieldNumber;
const int IMGetDeliverMsgResp::kDeliverTypeFieldNumber;
const int IMGetDeliverMsgResp::kResultFieldNumber;
const int IMGetDeliverMsgResp::kConsultMsgListFieldNumber;
const int IMGetDeliverMsgResp::kManagerNameFieldNumber;
const int IMGetDeliverMsgResp::kManagerPortraitFieldNumber;
#endif  // !_MSC_VER

IMGetDeliverMsgResp::IMGetDeliverMsgResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMGetDeliverMsgResp)
}

void IMGetDeliverMsgResp::InitAsDefaultInstance() {
}

IMGetDeliverMsgResp::IMGetDeliverMsgResp(const IMGetDeliverMsgResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMGetDeliverMsgResp)
}

void IMGetDeliverMsgResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  old_consult_id_ = 0u;
  new_consult_id_ = 0u;
  student_id_ = 0u;
  duty_id_ = 0u;
  manager_id_ = 0u;
  order_id_ = 0u;
  deliver_type_ = 0u;
  result_ = 0u;
  manager_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  manager_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetDeliverMsgResp::~IMGetDeliverMsgResp() {
  // @@protoc_insertion_point(destructor:IM.Other.IMGetDeliverMsgResp)
  SharedDtor();
}

void IMGetDeliverMsgResp::SharedDtor() {
  if (manager_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manager_name_;
  }
  if (manager_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manager_portrait_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetDeliverMsgResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetDeliverMsgResp& IMGetDeliverMsgResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMGetDeliverMsgResp* IMGetDeliverMsgResp::default_instance_ = NULL;

IMGetDeliverMsgResp* IMGetDeliverMsgResp::New() const {
  return new IMGetDeliverMsgResp;
}

void IMGetDeliverMsgResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetDeliverMsgResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(old_consult_id_, result_);
  }
  if (_has_bits_[8 / 32] & 1536) {
    if (has_manager_name()) {
      if (manager_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        manager_name_->clear();
      }
    }
    if (has_manager_portrait()) {
      if (manager_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        manager_portrait_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  consult_msg_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetDeliverMsgResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMGetDeliverMsgResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 old_consult_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &old_consult_id_)));
          set_has_old_consult_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_new_consult_id;
        break;
      }

      // required uint32 new_consult_id = 2;
      case 2: {
        if (tag == 16) {
         parse_new_consult_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &new_consult_id_)));
          set_has_new_consult_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_student_id;
        break;
      }

      // required uint32 student_id = 3;
      case 3: {
        if (tag == 24) {
         parse_student_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &student_id_)));
          set_has_student_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_duty_id;
        break;
      }

      // required uint32 duty_id = 4;
      case 4: {
        if (tag == 32) {
         parse_duty_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duty_id_)));
          set_has_duty_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_manager_id;
        break;
      }

      // required uint32 manager_id = 5;
      case 5: {
        if (tag == 40) {
         parse_manager_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &manager_id_)));
          set_has_manager_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_order_id;
        break;
      }

      // required uint32 order_id = 6;
      case 6: {
        if (tag == 48) {
         parse_order_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &order_id_)));
          set_has_order_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_deliver_type;
        break;
      }

      // required uint32 deliver_type = 7;
      case 7: {
        if (tag == 56) {
         parse_deliver_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &deliver_type_)));
          set_has_deliver_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_result;
        break;
      }

      // required uint32 result = 8;
      case 8: {
        if (tag == 64) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_consult_msg_list;
        break;
      }

      // repeated .IM.BaseDefine.ConsultMsg consult_msg_list = 9;
      case 9: {
        if (tag == 74) {
         parse_consult_msg_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_consult_msg_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_consult_msg_list;
        if (input->ExpectTag(162)) goto parse_manager_name;
        break;
      }

      // optional string manager_name = 20;
      case 20: {
        if (tag == 162) {
         parse_manager_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manager_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_manager_portrait;
        break;
      }

      // optional string manager_portrait = 21;
      case 21: {
        if (tag == 170) {
         parse_manager_portrait:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manager_portrait()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMGetDeliverMsgResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMGetDeliverMsgResp)
  return false;
#undef DO_
}

void IMGetDeliverMsgResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMGetDeliverMsgResp)
  // required uint32 old_consult_id = 1;
  if (has_old_consult_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->old_consult_id(), output);
  }

  // required uint32 new_consult_id = 2;
  if (has_new_consult_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->new_consult_id(), output);
  }

  // required uint32 student_id = 3;
  if (has_student_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->student_id(), output);
  }

  // required uint32 duty_id = 4;
  if (has_duty_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->duty_id(), output);
  }

  // required uint32 manager_id = 5;
  if (has_manager_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->manager_id(), output);
  }

  // required uint32 order_id = 6;
  if (has_order_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->order_id(), output);
  }

  // required uint32 deliver_type = 7;
  if (has_deliver_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->deliver_type(), output);
  }

  // required uint32 result = 8;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->result(), output);
  }

  // repeated .IM.BaseDefine.ConsultMsg consult_msg_list = 9;
  for (int i = 0; i < this->consult_msg_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->consult_msg_list(i), output);
  }

  // optional string manager_name = 20;
  if (has_manager_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      20, this->manager_name(), output);
  }

  // optional string manager_portrait = 21;
  if (has_manager_portrait()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      21, this->manager_portrait(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMGetDeliverMsgResp)
}

int IMGetDeliverMsgResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 old_consult_id = 1;
    if (has_old_consult_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->old_consult_id());
    }

    // required uint32 new_consult_id = 2;
    if (has_new_consult_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->new_consult_id());
    }

    // required uint32 student_id = 3;
    if (has_student_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->student_id());
    }

    // required uint32 duty_id = 4;
    if (has_duty_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duty_id());
    }

    // required uint32 manager_id = 5;
    if (has_manager_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->manager_id());
    }

    // required uint32 order_id = 6;
    if (has_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->order_id());
    }

    // required uint32 deliver_type = 7;
    if (has_deliver_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->deliver_type());
    }

    // required uint32 result = 8;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // optional string manager_name = 20;
    if (has_manager_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manager_name());
    }

    // optional string manager_portrait = 21;
    if (has_manager_portrait()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manager_portrait());
    }

  }
  // repeated .IM.BaseDefine.ConsultMsg consult_msg_list = 9;
  total_size += 1 * this->consult_msg_list_size();
  for (int i = 0; i < this->consult_msg_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->consult_msg_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetDeliverMsgResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeliverMsgResp*>(&from));
}

void IMGetDeliverMsgResp::MergeFrom(const IMGetDeliverMsgResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  consult_msg_list_.MergeFrom(from.consult_msg_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_old_consult_id()) {
      set_old_consult_id(from.old_consult_id());
    }
    if (from.has_new_consult_id()) {
      set_new_consult_id(from.new_consult_id());
    }
    if (from.has_student_id()) {
      set_student_id(from.student_id());
    }
    if (from.has_duty_id()) {
      set_duty_id(from.duty_id());
    }
    if (from.has_manager_id()) {
      set_manager_id(from.manager_id());
    }
    if (from.has_order_id()) {
      set_order_id(from.order_id());
    }
    if (from.has_deliver_type()) {
      set_deliver_type(from.deliver_type());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_manager_name()) {
      set_manager_name(from.manager_name());
    }
    if (from.has_manager_portrait()) {
      set_manager_portrait(from.manager_portrait());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetDeliverMsgResp::CopyFrom(const IMGetDeliverMsgResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeliverMsgResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->consult_msg_list())) return false;
  return true;
}

void IMGetDeliverMsgResp::Swap(IMGetDeliverMsgResp* other) {
  if (other != this) {
    std::swap(old_consult_id_, other->old_consult_id_);
    std::swap(new_consult_id_, other->new_consult_id_);
    std::swap(student_id_, other->student_id_);
    std::swap(duty_id_, other->duty_id_);
    std::swap(manager_id_, other->manager_id_);
    std::swap(order_id_, other->order_id_);
    std::swap(deliver_type_, other->deliver_type_);
    std::swap(result_, other->result_);
    consult_msg_list_.Swap(&other->consult_msg_list_);
    std::swap(manager_name_, other->manager_name_);
    std::swap(manager_portrait_, other->manager_portrait_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetDeliverMsgResp::GetTypeName() const {
  return "IM.Other.IMGetDeliverMsgResp";
}


// ===================================================================

#ifndef _MSC_VER
const int TeacherQuqueInfo::kTeacherIdFieldNumber;
const int TeacherQuqueInfo::kTeacherStateFieldNumber;
const int TeacherQuqueInfo::kQueueSizeFieldNumber;
#endif  // !_MSC_VER

TeacherQuqueInfo::TeacherQuqueInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.TeacherQuqueInfo)
}

void TeacherQuqueInfo::InitAsDefaultInstance() {
}

TeacherQuqueInfo::TeacherQuqueInfo(const TeacherQuqueInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.TeacherQuqueInfo)
}

void TeacherQuqueInfo::SharedCtor() {
  _cached_size_ = 0;
  teacher_id_ = 0u;
  teacher_state_ = 0u;
  queue_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TeacherQuqueInfo::~TeacherQuqueInfo() {
  // @@protoc_insertion_point(destructor:IM.Other.TeacherQuqueInfo)
  SharedDtor();
}

void TeacherQuqueInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TeacherQuqueInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TeacherQuqueInfo& TeacherQuqueInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

TeacherQuqueInfo* TeacherQuqueInfo::default_instance_ = NULL;

TeacherQuqueInfo* TeacherQuqueInfo::New() const {
  return new TeacherQuqueInfo;
}

void TeacherQuqueInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TeacherQuqueInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(teacher_id_, queue_size_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool TeacherQuqueInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.TeacherQuqueInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 teacher_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &teacher_id_)));
          set_has_teacher_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_teacher_state;
        break;
      }

      // required uint32 teacher_state = 2;
      case 2: {
        if (tag == 16) {
         parse_teacher_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &teacher_state_)));
          set_has_teacher_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_queue_size;
        break;
      }

      // required uint32 queue_size = 3;
      case 3: {
        if (tag == 24) {
         parse_queue_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &queue_size_)));
          set_has_queue_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.TeacherQuqueInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.TeacherQuqueInfo)
  return false;
#undef DO_
}

void TeacherQuqueInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.TeacherQuqueInfo)
  // required uint32 teacher_id = 1;
  if (has_teacher_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->teacher_id(), output);
  }

  // required uint32 teacher_state = 2;
  if (has_teacher_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->teacher_state(), output);
  }

  // required uint32 queue_size = 3;
  if (has_queue_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->queue_size(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.TeacherQuqueInfo)
}

int TeacherQuqueInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 teacher_id = 1;
    if (has_teacher_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->teacher_id());
    }

    // required uint32 teacher_state = 2;
    if (has_teacher_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->teacher_state());
    }

    // required uint32 queue_size = 3;
    if (has_queue_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->queue_size());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TeacherQuqueInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TeacherQuqueInfo*>(&from));
}

void TeacherQuqueInfo::MergeFrom(const TeacherQuqueInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_teacher_id()) {
      set_teacher_id(from.teacher_id());
    }
    if (from.has_teacher_state()) {
      set_teacher_state(from.teacher_state());
    }
    if (from.has_queue_size()) {
      set_queue_size(from.queue_size());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void TeacherQuqueInfo::CopyFrom(const TeacherQuqueInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeacherQuqueInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void TeacherQuqueInfo::Swap(TeacherQuqueInfo* other) {
  if (other != this) {
    std::swap(teacher_id_, other->teacher_id_);
    std::swap(teacher_state_, other->teacher_state_);
    std::swap(queue_size_, other->queue_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TeacherQuqueInfo::GetTypeName() const {
  return "IM.Other.TeacherQuqueInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int StudentQuqueInfo::kStudentIdFieldNumber;
const int StudentQuqueInfo::kTeacherIdFieldNumber;
#endif  // !_MSC_VER

StudentQuqueInfo::StudentQuqueInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.StudentQuqueInfo)
}

void StudentQuqueInfo::InitAsDefaultInstance() {
}

StudentQuqueInfo::StudentQuqueInfo(const StudentQuqueInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.StudentQuqueInfo)
}

void StudentQuqueInfo::SharedCtor() {
  _cached_size_ = 0;
  student_id_ = 0u;
  teacher_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StudentQuqueInfo::~StudentQuqueInfo() {
  // @@protoc_insertion_point(destructor:IM.Other.StudentQuqueInfo)
  SharedDtor();
}

void StudentQuqueInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StudentQuqueInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StudentQuqueInfo& StudentQuqueInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

StudentQuqueInfo* StudentQuqueInfo::default_instance_ = NULL;

StudentQuqueInfo* StudentQuqueInfo::New() const {
  return new StudentQuqueInfo;
}

void StudentQuqueInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<StudentQuqueInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(student_id_, teacher_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StudentQuqueInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.StudentQuqueInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 student_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &student_id_)));
          set_has_student_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_teacher_id;
        break;
      }

      // required uint32 teacher_id = 2;
      case 2: {
        if (tag == 16) {
         parse_teacher_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &teacher_id_)));
          set_has_teacher_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.StudentQuqueInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.StudentQuqueInfo)
  return false;
#undef DO_
}

void StudentQuqueInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.StudentQuqueInfo)
  // required uint32 student_id = 1;
  if (has_student_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->student_id(), output);
  }

  // required uint32 teacher_id = 2;
  if (has_teacher_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->teacher_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.StudentQuqueInfo)
}

int StudentQuqueInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 student_id = 1;
    if (has_student_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->student_id());
    }

    // required uint32 teacher_id = 2;
    if (has_teacher_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->teacher_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StudentQuqueInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StudentQuqueInfo*>(&from));
}

void StudentQuqueInfo::MergeFrom(const StudentQuqueInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_student_id()) {
      set_student_id(from.student_id());
    }
    if (from.has_teacher_id()) {
      set_teacher_id(from.teacher_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StudentQuqueInfo::CopyFrom(const StudentQuqueInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StudentQuqueInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void StudentQuqueInfo::Swap(StudentQuqueInfo* other) {
  if (other != this) {
    std::swap(student_id_, other->student_id_);
    std::swap(teacher_id_, other->teacher_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StudentQuqueInfo::GetTypeName() const {
  return "IM.Other.StudentQuqueInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetConsultQueueReq::kHttpHandleFieldNumber;
#endif  // !_MSC_VER

IMGetConsultQueueReq::IMGetConsultQueueReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMGetConsultQueueReq)
}

void IMGetConsultQueueReq::InitAsDefaultInstance() {
}

IMGetConsultQueueReq::IMGetConsultQueueReq(const IMGetConsultQueueReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMGetConsultQueueReq)
}

void IMGetConsultQueueReq::SharedCtor() {
  _cached_size_ = 0;
  http_handle_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetConsultQueueReq::~IMGetConsultQueueReq() {
  // @@protoc_insertion_point(destructor:IM.Other.IMGetConsultQueueReq)
  SharedDtor();
}

void IMGetConsultQueueReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetConsultQueueReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetConsultQueueReq& IMGetConsultQueueReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMGetConsultQueueReq* IMGetConsultQueueReq::default_instance_ = NULL;

IMGetConsultQueueReq* IMGetConsultQueueReq::New() const {
  return new IMGetConsultQueueReq;
}

void IMGetConsultQueueReq::Clear() {
  http_handle_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetConsultQueueReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMGetConsultQueueReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 http_handle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMGetConsultQueueReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMGetConsultQueueReq)
  return false;
#undef DO_
}

void IMGetConsultQueueReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMGetConsultQueueReq)
  // required uint32 http_handle = 1;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->http_handle(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMGetConsultQueueReq)
}

int IMGetConsultQueueReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 http_handle = 1;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetConsultQueueReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetConsultQueueReq*>(&from));
}

void IMGetConsultQueueReq::MergeFrom(const IMGetConsultQueueReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetConsultQueueReq::CopyFrom(const IMGetConsultQueueReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetConsultQueueReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMGetConsultQueueReq::Swap(IMGetConsultQueueReq* other) {
  if (other != this) {
    std::swap(http_handle_, other->http_handle_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetConsultQueueReq::GetTypeName() const {
  return "IM.Other.IMGetConsultQueueReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetConsultQueueResp::kTeacherMapSizeFieldNumber;
const int IMGetConsultQueueResp::kOnlineTeacherSizeFieldNumber;
const int IMGetConsultQueueResp::kOfflineTeacherSizeFieldNumber;
const int IMGetConsultQueueResp::kLeaveTeacherSizeFieldNumber;
const int IMGetConsultQueueResp::kHasQueueTeacherSizeFieldNumber;
const int IMGetConsultQueueResp::kInqueueStudentSizeFromTeacherFieldNumber;
const int IMGetConsultQueueResp::kTeacherQueueInfoFieldNumber;
const int IMGetConsultQueueResp::kInqueueStudentSizeFromStudentFieldNumber;
const int IMGetConsultQueueResp::kStudentQueueInfoFieldNumber;
const int IMGetConsultQueueResp::kHttpHandleFieldNumber;
#endif  // !_MSC_VER

IMGetConsultQueueResp::IMGetConsultQueueResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMGetConsultQueueResp)
}

void IMGetConsultQueueResp::InitAsDefaultInstance() {
}

IMGetConsultQueueResp::IMGetConsultQueueResp(const IMGetConsultQueueResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMGetConsultQueueResp)
}

void IMGetConsultQueueResp::SharedCtor() {
  _cached_size_ = 0;
  teacher_map_size_ = 0u;
  online_teacher_size_ = 0u;
  offline_teacher_size_ = 0u;
  leave_teacher_size_ = 0u;
  has_queue_teacher_size_ = 0u;
  inqueue_student_size_from_teacher_ = 0u;
  inqueue_student_size_from_student_ = 0u;
  http_handle_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetConsultQueueResp::~IMGetConsultQueueResp() {
  // @@protoc_insertion_point(destructor:IM.Other.IMGetConsultQueueResp)
  SharedDtor();
}

void IMGetConsultQueueResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetConsultQueueResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetConsultQueueResp& IMGetConsultQueueResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMGetConsultQueueResp* IMGetConsultQueueResp::default_instance_ = NULL;

IMGetConsultQueueResp* IMGetConsultQueueResp::New() const {
  return new IMGetConsultQueueResp;
}

void IMGetConsultQueueResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetConsultQueueResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 191) {
    ZR_(teacher_map_size_, inqueue_student_size_from_teacher_);
    inqueue_student_size_from_student_ = 0u;
  }
  http_handle_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  teacher_queue_info_.Clear();
  student_queue_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetConsultQueueResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMGetConsultQueueResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 teacher_map_size = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &teacher_map_size_)));
          set_has_teacher_map_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_teacher_size;
        break;
      }

      // required uint32 online_teacher_size = 2;
      case 2: {
        if (tag == 16) {
         parse_online_teacher_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_teacher_size_)));
          set_has_online_teacher_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_offline_teacher_size;
        break;
      }

      // required uint32 offline_teacher_size = 3;
      case 3: {
        if (tag == 24) {
         parse_offline_teacher_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offline_teacher_size_)));
          set_has_offline_teacher_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_leave_teacher_size;
        break;
      }

      // required uint32 leave_teacher_size = 4;
      case 4: {
        if (tag == 32) {
         parse_leave_teacher_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leave_teacher_size_)));
          set_has_leave_teacher_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_has_queue_teacher_size;
        break;
      }

      // required uint32 has_queue_teacher_size = 5;
      case 5: {
        if (tag == 40) {
         parse_has_queue_teacher_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &has_queue_teacher_size_)));
          set_has_has_queue_teacher_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_inqueue_student_size_from_teacher;
        break;
      }

      // required uint32 inqueue_student_size_from_teacher = 6;
      case 6: {
        if (tag == 48) {
         parse_inqueue_student_size_from_teacher:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inqueue_student_size_from_teacher_)));
          set_has_inqueue_student_size_from_teacher();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_teacher_queue_info;
        break;
      }

      // repeated .IM.Other.TeacherQuqueInfo teacher_queue_info = 7;
      case 7: {
        if (tag == 58) {
         parse_teacher_queue_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_teacher_queue_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_teacher_queue_info;
        if (input->ExpectTag(64)) goto parse_inqueue_student_size_from_student;
        break;
      }

      // required uint32 inqueue_student_size_from_student = 8;
      case 8: {
        if (tag == 64) {
         parse_inqueue_student_size_from_student:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inqueue_student_size_from_student_)));
          set_has_inqueue_student_size_from_student();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_student_queue_info;
        break;
      }

      // repeated .IM.Other.StudentQuqueInfo student_queue_info = 9;
      case 9: {
        if (tag == 74) {
         parse_student_queue_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_student_queue_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_student_queue_info;
        if (input->ExpectTag(80)) goto parse_http_handle;
        break;
      }

      // required uint32 http_handle = 10;
      case 10: {
        if (tag == 80) {
         parse_http_handle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMGetConsultQueueResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMGetConsultQueueResp)
  return false;
#undef DO_
}

void IMGetConsultQueueResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMGetConsultQueueResp)
  // required uint32 teacher_map_size = 1;
  if (has_teacher_map_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->teacher_map_size(), output);
  }

  // required uint32 online_teacher_size = 2;
  if (has_online_teacher_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_teacher_size(), output);
  }

  // required uint32 offline_teacher_size = 3;
  if (has_offline_teacher_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->offline_teacher_size(), output);
  }

  // required uint32 leave_teacher_size = 4;
  if (has_leave_teacher_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->leave_teacher_size(), output);
  }

  // required uint32 has_queue_teacher_size = 5;
  if (has_has_queue_teacher_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->has_queue_teacher_size(), output);
  }

  // required uint32 inqueue_student_size_from_teacher = 6;
  if (has_inqueue_student_size_from_teacher()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->inqueue_student_size_from_teacher(), output);
  }

  // repeated .IM.Other.TeacherQuqueInfo teacher_queue_info = 7;
  for (int i = 0; i < this->teacher_queue_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->teacher_queue_info(i), output);
  }

  // required uint32 inqueue_student_size_from_student = 8;
  if (has_inqueue_student_size_from_student()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->inqueue_student_size_from_student(), output);
  }

  // repeated .IM.Other.StudentQuqueInfo student_queue_info = 9;
  for (int i = 0; i < this->student_queue_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->student_queue_info(i), output);
  }

  // required uint32 http_handle = 10;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->http_handle(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMGetConsultQueueResp)
}

int IMGetConsultQueueResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 teacher_map_size = 1;
    if (has_teacher_map_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->teacher_map_size());
    }

    // required uint32 online_teacher_size = 2;
    if (has_online_teacher_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_teacher_size());
    }

    // required uint32 offline_teacher_size = 3;
    if (has_offline_teacher_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offline_teacher_size());
    }

    // required uint32 leave_teacher_size = 4;
    if (has_leave_teacher_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->leave_teacher_size());
    }

    // required uint32 has_queue_teacher_size = 5;
    if (has_has_queue_teacher_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->has_queue_teacher_size());
    }

    // required uint32 inqueue_student_size_from_teacher = 6;
    if (has_inqueue_student_size_from_teacher()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inqueue_student_size_from_teacher());
    }

    // required uint32 inqueue_student_size_from_student = 8;
    if (has_inqueue_student_size_from_student()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inqueue_student_size_from_student());
    }

  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // required uint32 http_handle = 10;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

  }
  // repeated .IM.Other.TeacherQuqueInfo teacher_queue_info = 7;
  total_size += 1 * this->teacher_queue_info_size();
  for (int i = 0; i < this->teacher_queue_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->teacher_queue_info(i));
  }

  // repeated .IM.Other.StudentQuqueInfo student_queue_info = 9;
  total_size += 1 * this->student_queue_info_size();
  for (int i = 0; i < this->student_queue_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->student_queue_info(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetConsultQueueResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetConsultQueueResp*>(&from));
}

void IMGetConsultQueueResp::MergeFrom(const IMGetConsultQueueResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  teacher_queue_info_.MergeFrom(from.teacher_queue_info_);
  student_queue_info_.MergeFrom(from.student_queue_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_teacher_map_size()) {
      set_teacher_map_size(from.teacher_map_size());
    }
    if (from.has_online_teacher_size()) {
      set_online_teacher_size(from.online_teacher_size());
    }
    if (from.has_offline_teacher_size()) {
      set_offline_teacher_size(from.offline_teacher_size());
    }
    if (from.has_leave_teacher_size()) {
      set_leave_teacher_size(from.leave_teacher_size());
    }
    if (from.has_has_queue_teacher_size()) {
      set_has_queue_teacher_size(from.has_queue_teacher_size());
    }
    if (from.has_inqueue_student_size_from_teacher()) {
      set_inqueue_student_size_from_teacher(from.inqueue_student_size_from_teacher());
    }
    if (from.has_inqueue_student_size_from_student()) {
      set_inqueue_student_size_from_student(from.inqueue_student_size_from_student());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetConsultQueueResp::CopyFrom(const IMGetConsultQueueResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetConsultQueueResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x000002bf) != 0x000002bf) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->teacher_queue_info())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->student_queue_info())) return false;
  return true;
}

void IMGetConsultQueueResp::Swap(IMGetConsultQueueResp* other) {
  if (other != this) {
    std::swap(teacher_map_size_, other->teacher_map_size_);
    std::swap(online_teacher_size_, other->online_teacher_size_);
    std::swap(offline_teacher_size_, other->offline_teacher_size_);
    std::swap(leave_teacher_size_, other->leave_teacher_size_);
    std::swap(has_queue_teacher_size_, other->has_queue_teacher_size_);
    std::swap(inqueue_student_size_from_teacher_, other->inqueue_student_size_from_teacher_);
    teacher_queue_info_.Swap(&other->teacher_queue_info_);
    std::swap(inqueue_student_size_from_student_, other->inqueue_student_size_from_student_);
    student_queue_info_.Swap(&other->student_queue_info_);
    std::swap(http_handle_, other->http_handle_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetConsultQueueResp::GetTypeName() const {
  return "IM.Other.IMGetConsultQueueResp";
}


// ===================================================================

#ifndef _MSC_VER
const int DBServerInfo::kIpFieldNumber;
const int DBServerInfo::kPortFieldNumber;
#endif  // !_MSC_VER

DBServerInfo::DBServerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.DBServerInfo)
}

void DBServerInfo::InitAsDefaultInstance() {
}

DBServerInfo::DBServerInfo(const DBServerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.DBServerInfo)
}

void DBServerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DBServerInfo::~DBServerInfo() {
  // @@protoc_insertion_point(destructor:IM.Other.DBServerInfo)
  SharedDtor();
}

void DBServerInfo::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DBServerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DBServerInfo& DBServerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

DBServerInfo* DBServerInfo::default_instance_ = NULL;

DBServerInfo* DBServerInfo::New() const {
  return new DBServerInfo;
}

void DBServerInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
    port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DBServerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.DBServerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes ip = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // required uint32 port = 2;
      case 2: {
        if (tag == 16) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.DBServerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.DBServerInfo)
  return false;
#undef DO_
}

void DBServerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.DBServerInfo)
  // required bytes ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->ip(), output);
  }

  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.DBServerInfo)
}

int DBServerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ip());
    }

    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DBServerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DBServerInfo*>(&from));
}

void DBServerInfo::MergeFrom(const DBServerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DBServerInfo::CopyFrom(const DBServerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DBServerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DBServerInfo::Swap(DBServerInfo* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DBServerInfo::GetTypeName() const {
  return "IM.Other.DBServerInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOtherGetDbServerCntReq::kHttpHandleFieldNumber;
const int IMOtherGetDbServerCntReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMOtherGetDbServerCntReq::IMOtherGetDbServerCntReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMOtherGetDbServerCntReq)
}

void IMOtherGetDbServerCntReq::InitAsDefaultInstance() {
}

IMOtherGetDbServerCntReq::IMOtherGetDbServerCntReq(const IMOtherGetDbServerCntReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMOtherGetDbServerCntReq)
}

void IMOtherGetDbServerCntReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  http_handle_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOtherGetDbServerCntReq::~IMOtherGetDbServerCntReq() {
  // @@protoc_insertion_point(destructor:IM.Other.IMOtherGetDbServerCntReq)
  SharedDtor();
}

void IMOtherGetDbServerCntReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOtherGetDbServerCntReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOtherGetDbServerCntReq& IMOtherGetDbServerCntReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMOtherGetDbServerCntReq* IMOtherGetDbServerCntReq::default_instance_ = NULL;

IMOtherGetDbServerCntReq* IMOtherGetDbServerCntReq::New() const {
  return new IMOtherGetDbServerCntReq;
}

void IMOtherGetDbServerCntReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    http_handle_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOtherGetDbServerCntReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMOtherGetDbServerCntReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 http_handle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMOtherGetDbServerCntReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMOtherGetDbServerCntReq)
  return false;
#undef DO_
}

void IMOtherGetDbServerCntReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMOtherGetDbServerCntReq)
  // required uint32 http_handle = 1;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->http_handle(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMOtherGetDbServerCntReq)
}

int IMOtherGetDbServerCntReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 http_handle = 1;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOtherGetDbServerCntReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOtherGetDbServerCntReq*>(&from));
}

void IMOtherGetDbServerCntReq::MergeFrom(const IMOtherGetDbServerCntReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOtherGetDbServerCntReq::CopyFrom(const IMOtherGetDbServerCntReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOtherGetDbServerCntReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMOtherGetDbServerCntReq::Swap(IMOtherGetDbServerCntReq* other) {
  if (other != this) {
    std::swap(http_handle_, other->http_handle_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOtherGetDbServerCntReq::GetTypeName() const {
  return "IM.Other.IMOtherGetDbServerCntReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOtherGetDbServerCntResp::kHttpHandleFieldNumber;
const int IMOtherGetDbServerCntResp::kDbServerLoginCountFieldNumber;
const int IMOtherGetDbServerCntResp::kDbServerCountFieldNumber;
const int IMOtherGetDbServerCntResp::kResultFieldNumber;
const int IMOtherGetDbServerCntResp::kDbServerInfoListFieldNumber;
const int IMOtherGetDbServerCntResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMOtherGetDbServerCntResp::IMOtherGetDbServerCntResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMOtherGetDbServerCntResp)
}

void IMOtherGetDbServerCntResp::InitAsDefaultInstance() {
}

IMOtherGetDbServerCntResp::IMOtherGetDbServerCntResp(const IMOtherGetDbServerCntResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMOtherGetDbServerCntResp)
}

void IMOtherGetDbServerCntResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  http_handle_ = 0u;
  db_server_login_count_ = 0u;
  db_server_count_ = 0u;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOtherGetDbServerCntResp::~IMOtherGetDbServerCntResp() {
  // @@protoc_insertion_point(destructor:IM.Other.IMOtherGetDbServerCntResp)
  SharedDtor();
}

void IMOtherGetDbServerCntResp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOtherGetDbServerCntResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOtherGetDbServerCntResp& IMOtherGetDbServerCntResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMOtherGetDbServerCntResp* IMOtherGetDbServerCntResp::default_instance_ = NULL;

IMOtherGetDbServerCntResp* IMOtherGetDbServerCntResp::New() const {
  return new IMOtherGetDbServerCntResp;
}

void IMOtherGetDbServerCntResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMOtherGetDbServerCntResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 47) {
    ZR_(http_handle_, result_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  db_server_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOtherGetDbServerCntResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMOtherGetDbServerCntResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 http_handle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_db_server_login_count;
        break;
      }

      // required uint32 db_server_login_count = 2;
      case 2: {
        if (tag == 16) {
         parse_db_server_login_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &db_server_login_count_)));
          set_has_db_server_login_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_db_server_count;
        break;
      }

      // required uint32 db_server_count = 3;
      case 3: {
        if (tag == 24) {
         parse_db_server_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &db_server_count_)));
          set_has_db_server_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_result;
        break;
      }

      // required uint32 result = 4;
      case 4: {
        if (tag == 32) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_db_server_info_list;
        break;
      }

      // repeated .IM.Other.DBServerInfo db_server_info_list = 5;
      case 5: {
        if (tag == 42) {
         parse_db_server_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_db_server_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_db_server_info_list;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMOtherGetDbServerCntResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMOtherGetDbServerCntResp)
  return false;
#undef DO_
}

void IMOtherGetDbServerCntResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMOtherGetDbServerCntResp)
  // required uint32 http_handle = 1;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->http_handle(), output);
  }

  // required uint32 db_server_login_count = 2;
  if (has_db_server_login_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->db_server_login_count(), output);
  }

  // required uint32 db_server_count = 3;
  if (has_db_server_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->db_server_count(), output);
  }

  // required uint32 result = 4;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->result(), output);
  }

  // repeated .IM.Other.DBServerInfo db_server_info_list = 5;
  for (int i = 0; i < this->db_server_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->db_server_info_list(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMOtherGetDbServerCntResp)
}

int IMOtherGetDbServerCntResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 http_handle = 1;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

    // required uint32 db_server_login_count = 2;
    if (has_db_server_login_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->db_server_login_count());
    }

    // required uint32 db_server_count = 3;
    if (has_db_server_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->db_server_count());
    }

    // required uint32 result = 4;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.Other.DBServerInfo db_server_info_list = 5;
  total_size += 1 * this->db_server_info_list_size();
  for (int i = 0; i < this->db_server_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->db_server_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOtherGetDbServerCntResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOtherGetDbServerCntResp*>(&from));
}

void IMOtherGetDbServerCntResp::MergeFrom(const IMOtherGetDbServerCntResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  db_server_info_list_.MergeFrom(from.db_server_info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
    if (from.has_db_server_login_count()) {
      set_db_server_login_count(from.db_server_login_count());
    }
    if (from.has_db_server_count()) {
      set_db_server_count(from.db_server_count());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOtherGetDbServerCntResp::CopyFrom(const IMOtherGetDbServerCntResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOtherGetDbServerCntResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->db_server_info_list())) return false;
  return true;
}

void IMOtherGetDbServerCntResp::Swap(IMOtherGetDbServerCntResp* other) {
  if (other != this) {
    std::swap(http_handle_, other->http_handle_);
    std::swap(db_server_login_count_, other->db_server_login_count_);
    std::swap(db_server_count_, other->db_server_count_);
    std::swap(result_, other->result_);
    db_server_info_list_.Swap(&other->db_server_info_list_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOtherGetDbServerCntResp::GetTypeName() const {
  return "IM.Other.IMOtherGetDbServerCntResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOtherSetDbServerCntReq::kHttpHandleFieldNumber;
const int IMOtherSetDbServerCntReq::kDbServerLoginCountFieldNumber;
const int IMOtherSetDbServerCntReq::kDbServerCountFieldNumber;
const int IMOtherSetDbServerCntReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMOtherSetDbServerCntReq::IMOtherSetDbServerCntReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMOtherSetDbServerCntReq)
}

void IMOtherSetDbServerCntReq::InitAsDefaultInstance() {
}

IMOtherSetDbServerCntReq::IMOtherSetDbServerCntReq(const IMOtherSetDbServerCntReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMOtherSetDbServerCntReq)
}

void IMOtherSetDbServerCntReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  http_handle_ = 0u;
  db_server_login_count_ = 0u;
  db_server_count_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOtherSetDbServerCntReq::~IMOtherSetDbServerCntReq() {
  // @@protoc_insertion_point(destructor:IM.Other.IMOtherSetDbServerCntReq)
  SharedDtor();
}

void IMOtherSetDbServerCntReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOtherSetDbServerCntReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOtherSetDbServerCntReq& IMOtherSetDbServerCntReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMOtherSetDbServerCntReq* IMOtherSetDbServerCntReq::default_instance_ = NULL;

IMOtherSetDbServerCntReq* IMOtherSetDbServerCntReq::New() const {
  return new IMOtherSetDbServerCntReq;
}

void IMOtherSetDbServerCntReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMOtherSetDbServerCntReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(http_handle_, db_server_login_count_);
    db_server_count_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOtherSetDbServerCntReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMOtherSetDbServerCntReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 http_handle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_db_server_login_count;
        break;
      }

      // required uint32 db_server_login_count = 2;
      case 2: {
        if (tag == 16) {
         parse_db_server_login_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &db_server_login_count_)));
          set_has_db_server_login_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_db_server_count;
        break;
      }

      // required uint32 db_server_count = 3;
      case 3: {
        if (tag == 24) {
         parse_db_server_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &db_server_count_)));
          set_has_db_server_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMOtherSetDbServerCntReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMOtherSetDbServerCntReq)
  return false;
#undef DO_
}

void IMOtherSetDbServerCntReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMOtherSetDbServerCntReq)
  // required uint32 http_handle = 1;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->http_handle(), output);
  }

  // required uint32 db_server_login_count = 2;
  if (has_db_server_login_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->db_server_login_count(), output);
  }

  // required uint32 db_server_count = 3;
  if (has_db_server_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->db_server_count(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMOtherSetDbServerCntReq)
}

int IMOtherSetDbServerCntReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 http_handle = 1;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

    // required uint32 db_server_login_count = 2;
    if (has_db_server_login_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->db_server_login_count());
    }

    // required uint32 db_server_count = 3;
    if (has_db_server_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->db_server_count());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOtherSetDbServerCntReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOtherSetDbServerCntReq*>(&from));
}

void IMOtherSetDbServerCntReq::MergeFrom(const IMOtherSetDbServerCntReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
    if (from.has_db_server_login_count()) {
      set_db_server_login_count(from.db_server_login_count());
    }
    if (from.has_db_server_count()) {
      set_db_server_count(from.db_server_count());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOtherSetDbServerCntReq::CopyFrom(const IMOtherSetDbServerCntReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOtherSetDbServerCntReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMOtherSetDbServerCntReq::Swap(IMOtherSetDbServerCntReq* other) {
  if (other != this) {
    std::swap(http_handle_, other->http_handle_);
    std::swap(db_server_login_count_, other->db_server_login_count_);
    std::swap(db_server_count_, other->db_server_count_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOtherSetDbServerCntReq::GetTypeName() const {
  return "IM.Other.IMOtherSetDbServerCntReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOtherSetDbServerCntResp::kHttpHandleFieldNumber;
const int IMOtherSetDbServerCntResp::kDbServerLoginCountFieldNumber;
const int IMOtherSetDbServerCntResp::kDbServerCountFieldNumber;
const int IMOtherSetDbServerCntResp::kResultFieldNumber;
const int IMOtherSetDbServerCntResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMOtherSetDbServerCntResp::IMOtherSetDbServerCntResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMOtherSetDbServerCntResp)
}

void IMOtherSetDbServerCntResp::InitAsDefaultInstance() {
}

IMOtherSetDbServerCntResp::IMOtherSetDbServerCntResp(const IMOtherSetDbServerCntResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMOtherSetDbServerCntResp)
}

void IMOtherSetDbServerCntResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  http_handle_ = 0u;
  db_server_login_count_ = 0u;
  db_server_count_ = 0u;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOtherSetDbServerCntResp::~IMOtherSetDbServerCntResp() {
  // @@protoc_insertion_point(destructor:IM.Other.IMOtherSetDbServerCntResp)
  SharedDtor();
}

void IMOtherSetDbServerCntResp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOtherSetDbServerCntResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOtherSetDbServerCntResp& IMOtherSetDbServerCntResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMOtherSetDbServerCntResp* IMOtherSetDbServerCntResp::default_instance_ = NULL;

IMOtherSetDbServerCntResp* IMOtherSetDbServerCntResp::New() const {
  return new IMOtherSetDbServerCntResp;
}

void IMOtherSetDbServerCntResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMOtherSetDbServerCntResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(http_handle_, result_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOtherSetDbServerCntResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMOtherSetDbServerCntResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 http_handle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_db_server_login_count;
        break;
      }

      // required uint32 db_server_login_count = 2;
      case 2: {
        if (tag == 16) {
         parse_db_server_login_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &db_server_login_count_)));
          set_has_db_server_login_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_db_server_count;
        break;
      }

      // required uint32 db_server_count = 3;
      case 3: {
        if (tag == 24) {
         parse_db_server_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &db_server_count_)));
          set_has_db_server_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_result;
        break;
      }

      // required uint32 result = 4;
      case 4: {
        if (tag == 32) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMOtherSetDbServerCntResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMOtherSetDbServerCntResp)
  return false;
#undef DO_
}

void IMOtherSetDbServerCntResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMOtherSetDbServerCntResp)
  // required uint32 http_handle = 1;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->http_handle(), output);
  }

  // required uint32 db_server_login_count = 2;
  if (has_db_server_login_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->db_server_login_count(), output);
  }

  // required uint32 db_server_count = 3;
  if (has_db_server_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->db_server_count(), output);
  }

  // required uint32 result = 4;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->result(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMOtherSetDbServerCntResp)
}

int IMOtherSetDbServerCntResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 http_handle = 1;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

    // required uint32 db_server_login_count = 2;
    if (has_db_server_login_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->db_server_login_count());
    }

    // required uint32 db_server_count = 3;
    if (has_db_server_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->db_server_count());
    }

    // required uint32 result = 4;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOtherSetDbServerCntResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOtherSetDbServerCntResp*>(&from));
}

void IMOtherSetDbServerCntResp::MergeFrom(const IMOtherSetDbServerCntResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
    if (from.has_db_server_login_count()) {
      set_db_server_login_count(from.db_server_login_count());
    }
    if (from.has_db_server_count()) {
      set_db_server_count(from.db_server_count());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOtherSetDbServerCntResp::CopyFrom(const IMOtherSetDbServerCntResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOtherSetDbServerCntResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void IMOtherSetDbServerCntResp::Swap(IMOtherSetDbServerCntResp* other) {
  if (other != this) {
    std::swap(http_handle_, other->http_handle_);
    std::swap(db_server_login_count_, other->db_server_login_count_);
    std::swap(db_server_count_, other->db_server_count_);
    std::swap(result_, other->result_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOtherSetDbServerCntResp::GetTypeName() const {
  return "IM.Other.IMOtherSetDbServerCntResp";
}


// ===================================================================

#ifndef _MSC_VER
const int TeacherInfo::kIdFieldNumber;
const int TeacherInfo::kOnlineStatFieldNumber;
const int TeacherInfo::kQueueCntFieldNumber;
#endif  // !_MSC_VER

TeacherInfo::TeacherInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.TeacherInfo)
}

void TeacherInfo::InitAsDefaultInstance() {
}

TeacherInfo::TeacherInfo(const TeacherInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.TeacherInfo)
}

void TeacherInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  online_stat_ = 0u;
  queue_cnt_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TeacherInfo::~TeacherInfo() {
  // @@protoc_insertion_point(destructor:IM.Other.TeacherInfo)
  SharedDtor();
}

void TeacherInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TeacherInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TeacherInfo& TeacherInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

TeacherInfo* TeacherInfo::default_instance_ = NULL;

TeacherInfo* TeacherInfo::New() const {
  return new TeacherInfo;
}

void TeacherInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TeacherInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, queue_cnt_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool TeacherInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.TeacherInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_online_stat;
        break;
      }

      // required uint32 online_stat = 2;
      case 2: {
        if (tag == 16) {
         parse_online_stat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_stat_)));
          set_has_online_stat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_queue_cnt;
        break;
      }

      // required uint32 queue_cnt = 3;
      case 3: {
        if (tag == 24) {
         parse_queue_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &queue_cnt_)));
          set_has_queue_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.TeacherInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.TeacherInfo)
  return false;
#undef DO_
}

void TeacherInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.TeacherInfo)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 online_stat = 2;
  if (has_online_stat()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->online_stat(), output);
  }

  // required uint32 queue_cnt = 3;
  if (has_queue_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->queue_cnt(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.TeacherInfo)
}

int TeacherInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 online_stat = 2;
    if (has_online_stat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_stat());
    }

    // required uint32 queue_cnt = 3;
    if (has_queue_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->queue_cnt());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TeacherInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TeacherInfo*>(&from));
}

void TeacherInfo::MergeFrom(const TeacherInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_online_stat()) {
      set_online_stat(from.online_stat());
    }
    if (from.has_queue_cnt()) {
      set_queue_cnt(from.queue_cnt());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void TeacherInfo::CopyFrom(const TeacherInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeacherInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void TeacherInfo::Swap(TeacherInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(online_stat_, other->online_stat_);
    std::swap(queue_cnt_, other->queue_cnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TeacherInfo::GetTypeName() const {
  return "IM.Other.TeacherInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOtherPlatFormGetTeacherInfoReq::kHttpHandleFieldNumber;
const int IMOtherPlatFormGetTeacherInfoReq::kTeacherIdListFieldNumber;
const int IMOtherPlatFormGetTeacherInfoReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMOtherPlatFormGetTeacherInfoReq::IMOtherPlatFormGetTeacherInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMOtherPlatFormGetTeacherInfoReq)
}

void IMOtherPlatFormGetTeacherInfoReq::InitAsDefaultInstance() {
}

IMOtherPlatFormGetTeacherInfoReq::IMOtherPlatFormGetTeacherInfoReq(const IMOtherPlatFormGetTeacherInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMOtherPlatFormGetTeacherInfoReq)
}

void IMOtherPlatFormGetTeacherInfoReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  http_handle_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOtherPlatFormGetTeacherInfoReq::~IMOtherPlatFormGetTeacherInfoReq() {
  // @@protoc_insertion_point(destructor:IM.Other.IMOtherPlatFormGetTeacherInfoReq)
  SharedDtor();
}

void IMOtherPlatFormGetTeacherInfoReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOtherPlatFormGetTeacherInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOtherPlatFormGetTeacherInfoReq& IMOtherPlatFormGetTeacherInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMOtherPlatFormGetTeacherInfoReq* IMOtherPlatFormGetTeacherInfoReq::default_instance_ = NULL;

IMOtherPlatFormGetTeacherInfoReq* IMOtherPlatFormGetTeacherInfoReq::New() const {
  return new IMOtherPlatFormGetTeacherInfoReq;
}

void IMOtherPlatFormGetTeacherInfoReq::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    http_handle_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  teacher_id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOtherPlatFormGetTeacherInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMOtherPlatFormGetTeacherInfoReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 http_handle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_teacher_id_list;
        break;
      }

      // repeated uint32 teacher_id_list = 2;
      case 2: {
        if (tag == 16) {
         parse_teacher_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_teacher_id_list())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_teacher_id_list())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_teacher_id_list;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMOtherPlatFormGetTeacherInfoReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMOtherPlatFormGetTeacherInfoReq)
  return false;
#undef DO_
}

void IMOtherPlatFormGetTeacherInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMOtherPlatFormGetTeacherInfoReq)
  // required uint32 http_handle = 1;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->http_handle(), output);
  }

  // repeated uint32 teacher_id_list = 2;
  for (int i = 0; i < this->teacher_id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->teacher_id_list(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMOtherPlatFormGetTeacherInfoReq)
}

int IMOtherPlatFormGetTeacherInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 http_handle = 1;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 teacher_id_list = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->teacher_id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->teacher_id_list(i));
    }
    total_size += 1 * this->teacher_id_list_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOtherPlatFormGetTeacherInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOtherPlatFormGetTeacherInfoReq*>(&from));
}

void IMOtherPlatFormGetTeacherInfoReq::MergeFrom(const IMOtherPlatFormGetTeacherInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  teacher_id_list_.MergeFrom(from.teacher_id_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOtherPlatFormGetTeacherInfoReq::CopyFrom(const IMOtherPlatFormGetTeacherInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOtherPlatFormGetTeacherInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMOtherPlatFormGetTeacherInfoReq::Swap(IMOtherPlatFormGetTeacherInfoReq* other) {
  if (other != this) {
    std::swap(http_handle_, other->http_handle_);
    teacher_id_list_.Swap(&other->teacher_id_list_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOtherPlatFormGetTeacherInfoReq::GetTypeName() const {
  return "IM.Other.IMOtherPlatFormGetTeacherInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOtherPlatFormGetTeacherInfoResp::kHttpHandleFieldNumber;
const int IMOtherPlatFormGetTeacherInfoResp::kTeacherInfoListFieldNumber;
const int IMOtherPlatFormGetTeacherInfoResp::kResultFieldNumber;
const int IMOtherPlatFormGetTeacherInfoResp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMOtherPlatFormGetTeacherInfoResp::IMOtherPlatFormGetTeacherInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMOtherPlatFormGetTeacherInfoResp)
}

void IMOtherPlatFormGetTeacherInfoResp::InitAsDefaultInstance() {
}

IMOtherPlatFormGetTeacherInfoResp::IMOtherPlatFormGetTeacherInfoResp(const IMOtherPlatFormGetTeacherInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMOtherPlatFormGetTeacherInfoResp)
}

void IMOtherPlatFormGetTeacherInfoResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  http_handle_ = 0u;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOtherPlatFormGetTeacherInfoResp::~IMOtherPlatFormGetTeacherInfoResp() {
  // @@protoc_insertion_point(destructor:IM.Other.IMOtherPlatFormGetTeacherInfoResp)
  SharedDtor();
}

void IMOtherPlatFormGetTeacherInfoResp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOtherPlatFormGetTeacherInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOtherPlatFormGetTeacherInfoResp& IMOtherPlatFormGetTeacherInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMOtherPlatFormGetTeacherInfoResp* IMOtherPlatFormGetTeacherInfoResp::default_instance_ = NULL;

IMOtherPlatFormGetTeacherInfoResp* IMOtherPlatFormGetTeacherInfoResp::New() const {
  return new IMOtherPlatFormGetTeacherInfoResp;
}

void IMOtherPlatFormGetTeacherInfoResp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMOtherPlatFormGetTeacherInfoResp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 13) {
    ZR_(http_handle_, result_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  teacher_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOtherPlatFormGetTeacherInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMOtherPlatFormGetTeacherInfoResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 http_handle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &http_handle_)));
          set_has_http_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_teacher_info_list;
        break;
      }

      // repeated .IM.Other.TeacherInfo teacher_info_list = 2;
      case 2: {
        if (tag == 18) {
         parse_teacher_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_teacher_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_teacher_info_list;
        if (input->ExpectTag(24)) goto parse_result;
        break;
      }

      // required uint32 result = 3;
      case 3: {
        if (tag == 24) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMOtherPlatFormGetTeacherInfoResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMOtherPlatFormGetTeacherInfoResp)
  return false;
#undef DO_
}

void IMOtherPlatFormGetTeacherInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMOtherPlatFormGetTeacherInfoResp)
  // required uint32 http_handle = 1;
  if (has_http_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->http_handle(), output);
  }

  // repeated .IM.Other.TeacherInfo teacher_info_list = 2;
  for (int i = 0; i < this->teacher_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->teacher_info_list(i), output);
  }

  // required uint32 result = 3;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->result(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMOtherPlatFormGetTeacherInfoResp)
}

int IMOtherPlatFormGetTeacherInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 http_handle = 1;
    if (has_http_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->http_handle());
    }

    // required uint32 result = 3;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.Other.TeacherInfo teacher_info_list = 2;
  total_size += 1 * this->teacher_info_list_size();
  for (int i = 0; i < this->teacher_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->teacher_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOtherPlatFormGetTeacherInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOtherPlatFormGetTeacherInfoResp*>(&from));
}

void IMOtherPlatFormGetTeacherInfoResp::MergeFrom(const IMOtherPlatFormGetTeacherInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  teacher_info_list_.MergeFrom(from.teacher_info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_http_handle()) {
      set_http_handle(from.http_handle());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOtherPlatFormGetTeacherInfoResp::CopyFrom(const IMOtherPlatFormGetTeacherInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOtherPlatFormGetTeacherInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->teacher_info_list())) return false;
  return true;
}

void IMOtherPlatFormGetTeacherInfoResp::Swap(IMOtherPlatFormGetTeacherInfoResp* other) {
  if (other != this) {
    std::swap(http_handle_, other->http_handle_);
    teacher_info_list_.Swap(&other->teacher_info_list_);
    std::swap(result_, other->result_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOtherPlatFormGetTeacherInfoResp::GetTypeName() const {
  return "IM.Other.IMOtherPlatFormGetTeacherInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRPCMsgData::kUserIdFieldNumber;
const int IMRPCMsgData::kUserNameFieldNumber;
const int IMRPCMsgData::kUserPortraitFieldNumber;
const int IMRPCMsgData::kUserImIdFieldNumber;
const int IMRPCMsgData::kMsgTypeFieldNumber;
const int IMRPCMsgData::kMsgDataFieldNumber;
const int IMRPCMsgData::kCreateTimeFieldNumber;
const int IMRPCMsgData::kGroupMsgResListFieldNumber;
const int IMRPCMsgData::kTarsInfoFieldNumber;
const int IMRPCMsgData::kMsgsInfoListFieldNumber;
const int IMRPCMsgData::kResultFieldNumber;
const int IMRPCMsgData::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMRPCMsgData::IMRPCMsgData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Other.IMRPCMsgData)
}

void IMRPCMsgData::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(
      ::IM::RPC::TarsInfo::internal_default_instance());
#else
  tars_info_ = const_cast< ::IM::RPC::TarsInfo*>(&::IM::RPC::TarsInfo::default_instance());
#endif
}

IMRPCMsgData::IMRPCMsgData(const IMRPCMsgData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Other.IMRPCMsgData)
}

void IMRPCMsgData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_portrait_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_im_id_ = 0u;
  msg_type_ = 0u;
  msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  create_time_ = 0u;
  tars_info_ = NULL;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRPCMsgData::~IMRPCMsgData() {
  // @@protoc_insertion_point(destructor:IM.Other.IMRPCMsgData)
  SharedDtor();
}

void IMRPCMsgData::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_portrait_;
  }
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete tars_info_;
  }
}

void IMRPCMsgData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRPCMsgData& IMRPCMsgData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eOther_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eOther_2eproto();
#endif
  return *default_instance_;
}

IMRPCMsgData* IMRPCMsgData::default_instance_ = NULL;

IMRPCMsgData* IMRPCMsgData::New() const {
  return new IMRPCMsgData;
}

void IMRPCMsgData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRPCMsgData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(user_id_, user_im_id_);
    ZR_(msg_type_, create_time_);
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_name_->clear();
      }
    }
    if (has_user_portrait()) {
      if (user_portrait_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_portrait_->clear();
      }
    }
    if (has_msg_data()) {
      if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_data_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 3328) {
    if (has_tars_info()) {
      if (tars_info_ != NULL) tars_info_->::IM::RPC::TarsInfo::Clear();
    }
    result_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  group_msg_res_list_.Clear();
  msgs_info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRPCMsgData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Other.IMRPCMsgData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // required string user_name = 2;
      case 2: {
        if (tag == 18) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_user_portrait;
        break;
      }

      // required string user_portrait = 3;
      case 3: {
        if (tag == 26) {
         parse_user_portrait:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_portrait()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_user_im_id;
        break;
      }

      // required uint32 user_im_id = 4;
      case 4: {
        if (tag == 32) {
         parse_user_im_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_im_id_)));
          set_has_user_im_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_msg_type;
        break;
      }

      // required uint32 msg_type = 5;
      case 5: {
        if (tag == 40) {
         parse_msg_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_type_)));
          set_has_msg_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_msg_data;
        break;
      }

      // required bytes msg_data = 6;
      case 6: {
        if (tag == 50) {
         parse_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_create_time;
        break;
      }

      // required uint32 create_time = 7;
      case 7: {
        if (tag == 56) {
         parse_create_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &create_time_)));
          set_has_create_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_group_msg_res_list;
        break;
      }

      // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 8;
      case 8: {
        if (tag == 66) {
         parse_group_msg_res_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_group_msg_res_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_group_msg_res_list;
        if (input->ExpectTag(74)) goto parse_tars_info;
        break;
      }

      // required .IM.RPC.TarsInfo tars_info = 9;
      case 9: {
        if (tag == 74) {
         parse_tars_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tars_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_msgs_info_list;
        break;
      }

      // repeated .IM.BaseDefine.GroupMsgInfo msgs_info_list = 10;
      case 10: {
        if (tag == 82) {
         parse_msgs_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_msgs_info_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_msgs_info_list;
        if (input->ExpectTag(88)) goto parse_result;
        break;
      }

      // required uint32 result = 11;
      case 11: {
        if (tag == 88) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Other.IMRPCMsgData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Other.IMRPCMsgData)
  return false;
#undef DO_
}

void IMRPCMsgData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Other.IMRPCMsgData)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required string user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->user_name(), output);
  }

  // required string user_portrait = 3;
  if (has_user_portrait()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->user_portrait(), output);
  }

  // required uint32 user_im_id = 4;
  if (has_user_im_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->user_im_id(), output);
  }

  // required uint32 msg_type = 5;
  if (has_msg_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->msg_type(), output);
  }

  // required bytes msg_data = 6;
  if (has_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->msg_data(), output);
  }

  // required uint32 create_time = 7;
  if (has_create_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->create_time(), output);
  }

  // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 8;
  for (int i = 0; i < this->group_msg_res_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->group_msg_res_list(i), output);
  }

  // required .IM.RPC.TarsInfo tars_info = 9;
  if (has_tars_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->tars_info(), output);
  }

  // repeated .IM.BaseDefine.GroupMsgInfo msgs_info_list = 10;
  for (int i = 0; i < this->msgs_info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->msgs_info_list(i), output);
  }

  // required uint32 result = 11;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->result(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Other.IMRPCMsgData)
}

int IMRPCMsgData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required string user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required string user_portrait = 3;
    if (has_user_portrait()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_portrait());
    }

    // required uint32 user_im_id = 4;
    if (has_user_im_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_im_id());
    }

    // required uint32 msg_type = 5;
    if (has_msg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_type());
    }

    // required bytes msg_data = 6;
    if (has_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg_data());
    }

    // required uint32 create_time = 7;
    if (has_create_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->create_time());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required .IM.RPC.TarsInfo tars_info = 9;
    if (has_tars_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tars_info());
    }

    // required uint32 result = 11;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.RPC.GroupMsgRes group_msg_res_list = 8;
  total_size += 1 * this->group_msg_res_list_size();
  for (int i = 0; i < this->group_msg_res_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->group_msg_res_list(i));
  }

  // repeated .IM.BaseDefine.GroupMsgInfo msgs_info_list = 10;
  total_size += 1 * this->msgs_info_list_size();
  for (int i = 0; i < this->msgs_info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->msgs_info_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRPCMsgData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRPCMsgData*>(&from));
}

void IMRPCMsgData::MergeFrom(const IMRPCMsgData& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_msg_res_list_.MergeFrom(from.group_msg_res_list_);
  msgs_info_list_.MergeFrom(from.msgs_info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_user_portrait()) {
      set_user_portrait(from.user_portrait());
    }
    if (from.has_user_im_id()) {
      set_user_im_id(from.user_im_id());
    }
    if (from.has_msg_type()) {
      set_msg_type(from.msg_type());
    }
    if (from.has_msg_data()) {
      set_msg_data(from.msg_data());
    }
    if (from.has_create_time()) {
      set_create_time(from.create_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_tars_info()) {
      mutable_tars_info()->::IM::RPC::TarsInfo::MergeFrom(from.tars_info());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRPCMsgData::CopyFrom(const IMRPCMsgData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRPCMsgData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000057f) != 0x0000057f) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->group_msg_res_list())) return false;
  if (has_tars_info()) {
    if (!this->tars_info().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->msgs_info_list())) return false;
  return true;
}

void IMRPCMsgData::Swap(IMRPCMsgData* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(user_name_, other->user_name_);
    std::swap(user_portrait_, other->user_portrait_);
    std::swap(user_im_id_, other->user_im_id_);
    std::swap(msg_type_, other->msg_type_);
    std::swap(msg_data_, other->msg_data_);
    std::swap(create_time_, other->create_time_);
    group_msg_res_list_.Swap(&other->group_msg_res_list_);
    std::swap(tars_info_, other->tars_info_);
    msgs_info_list_.Swap(&other->msgs_info_list_);
    std::swap(result_, other->result_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRPCMsgData::GetTypeName() const {
  return "IM.Other.IMRPCMsgData";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Other
}  // namespace IM

// @@protoc_insertion_point(global_scope)
